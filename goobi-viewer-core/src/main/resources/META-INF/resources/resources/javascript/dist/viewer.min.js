/*!
 * This file is part of the Goobi viewer - a content presentation and management application for digitized objects.
 *
 * Visit these websites for more information.
 * - http://www.intranda.com
 * - http://digiverso.com
 *
 * This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program. If not, see <http://www.gnu.org/licenses/>.
 */var viewerJS = (function () {
    'use strict';

    var _debug = false;
    var _defaults = {
        currentPage: '',
        browser: '',
        theme: '',
        sidebarSelector: '#sidebar',
        contentSelector: '#main',
        messageBoxSelector: '.messages .alert',
        messageBoxInterval: 1000,
        messageBoxTimeout: 8000,
        pageScrollSelector: '.icon-totop',
        pageScrollAnchor: '#top',
        widgetNerSidebarRight: false,
        accessDeniedImage: '',
        notFoundImage: '',
        activateFacetsFilter: true
    };
    

    var viewer = {};
    viewer.initialized = new rxjs.Subject();
    viewer.toggledCollapseable = new rxjs.Subject();
    
    viewer.init = function (config) {
        if (_debug) {
            console.log('Initializing: viewerJS.init');
            console.log('--> config = ', config);
        }

        $.extend(true, _defaults, config);
        if(_debug)console.log("init ", _defaults);
        // detect current browser
        _defaults.browser = getCurrentBrowser();

        // write theme name to viewer object so submodules can use it
        viewer.theme = _defaults.theme;

        // throw some console infos about the page
        console.info('Current Browser = ', _defaults.browser);
        console.info('Current Theme = ', _defaults.theme);
        console.info('Current Page = ', _defaults.currentPage);
 
 		viewer.disclaimerModal.init(this.disclaimerConfig);

        //init websocket
        if(viewer.useWebSocket) {
	        viewer.webSocket = new viewerJS.WebSocket(window.location.host, currentPath, viewerJS.WebSocket.PATH_SESSION_SOCKET);
        }
        
  
        // init Bootstrap features
        viewerJS.helper.initBsFeatures();
        
        viewerJS.helper.initRestrictedInputFields();

        // init mobile Toggles for old responisive themes
        viewerJS.mobileToggles.init();

        // init save scroll positions
        viewerJS.scrollPositions.init();
        
        viewerJS.helper.initNumberOnlyInput();

        // init user login
        viewerJS.userLogin.init();
        
        viewerJS.popovers.init();
	    viewerJS.userDropdown.init();
	    
	    //init toggle hide/show
	    viewerJS.toggle.init();
	    
	    viewerJS.initWidgetUsage();

        viewerJS.initFragmentActions();
       
        viewerJS.initRequiredInputs();
        
        viewerJS.initDisallowDownload();
               
        // init bookmarks if enabled
        if ( bookmarksEnabled ) { 
            viewerJS.bookmarks.init( {
                root: rootURL,
                rest: this.getRestApiUrl(),
                userLoggedIn: userLoggedIn,
                language: currentLang
                
            });
        } 

        // init scroll page animated
        this.pageScroll.init(_defaults.pageScrollSelector, _defaults.pageScrollAnchor);
        this.pageScroll.scrollToFragment();
        
        // init some image methods
        viewer.initFragmentNavigation();
        viewer.initStoreScrollPosition();
        viewer.initSidebarCollapseable();

        // AJAX Loader Eventlistener
        viewerJS.jsfAjax.init(_defaults);
        
        //input validation status
        viewerJS.validationStatus.init();
        
        

        // render warning if local storage is not useable
        if (!viewer.localStoragePossible) {
            var warningPopover = this.helper
                .renderWarningPopover('Ihr Browser befindet sich im privaten Modus und unterstützt die Möglichkeit Informationen zur Seite lokal zu speichern nicht. Aus diesem Grund sind nicht alle Funktionen des viewers verfügbar. Bitte verlasen Sie den privaten Modus oder benutzen einen alternativen Browser. Vielen Dank.');

            $('body').append(warningPopover);

            $('body').on('click', '[data-toggle="warning-popover"]', function () {
                $('.warning-popover').fadeOut('fast', function () {
                    $('.warning-popover').remove();
                });
            });
        }
        
        // toggle work title body
        $('body').on( 'click', '.title__header h1', function () {
        	$( this ).find( '.fa' ).toggleClass( 'in' );
        	$( '.title__body' ).slideToggle( 'fast' );        	
        } );





        // fade out message box if it exists
        (function () {
            var fadeoutScheduled = false;

            setInterval(function () {
                if ($(_defaults.messageBoxSelector).length > 0) {
                    if (!fadeoutScheduled) {
                        fadeoutScheduled = true;
                        var messageTimer = setTimeout(function () {
                            $(_defaults.messageBoxSelector).each(function () {
                                $(this).fadeOut('slow', function () {
                                    $(this).remove();
                                })
                            });

                            fadeoutScheduled = false;
                        }, _defaults.messageBoxTimeout);
                    }
                }
            }, _defaults.messageBoxInterval);
        })();

        // add class on toggle sidebar widget (CMS individual sidebar widgets)
        $('.collapse').on('show.bs.collapse', function () {
            $(this).prev().find('.fa').removeClass('fa-arrow-down').addClass('fa-arrow-up');
        });

        $('.collapse').on('hide.bs.collapse', function () {
            $(this).prev().find('.fa').removeClass('fa-arrow-up').addClass('fa-arrow-down');
        });

        $('body').on('click', '[data-collapse-show]', function () {
            var href = $(this).data('collapse-show');
            $(href).collapse('show');
        });

        // init search facets filter
        if (_defaults.activateFacetsFilter) {
            this.initFacetsFilters();
            this.jsfAjax.success.subscribe(e => {
            	let collapseLink = $(e.source).attr("data-collapse-link");
            	if(collapseLink) {
            		this.initFacetsFilters();
            	}
        	});
        }

        // disable submit button on feedback
        if (currentPage === 'feedback') {
            $('#submitFeedbackBtn').attr('disabled', true);
        }

        // set sidebar position for NER-Widget
        if ($('#widgetNerFacetting').length > 0) {
            nerFacettingConfig.sidebarRight = _defaults.widgetNerSidebarRight;
            this.nerFacetting.init(nerFacettingConfig);
        }

        // fire search query in autocomplete on enter
        $('body').on('keyup', '#pfAutocomplete_input, [id*=":pfAutocomplete_input"]', function (event) {
            if (event.keyCode == 13) {
                $('#submitSearch, [id*=":submitSearch"]').click();
            }
        });

        // make sure only integer values may be entered in input fields of class
        // 'input-integer'
        $('body').on('keypress', '.input-integer', function (event) {
            if (event.which < 48 || event.which > 57) {
                return false;
            }
        });

        // make sure only integer values may be entered in input fields of class
        // 'input-float'
        $('body').on('keypress', '.input-float', function (event) {
            switch (event.which) {
                case 8: // delete
                case 9: // tab
                case 13: // enter
                case 46: // dot
                case 44: // comma
                case 43: // plus
                case 45: // minus
                    return true;
                case 118:
                    return event.ctrlKey; // copy
                default:
                    switch (event.keyCode) {
                        case 8: // delete
                        case 9: // tab
                        case 13: // enter
                            return true;
                        default:
                            if (event.which < 48 || event.which > 57) {
                                return false;
                            }
                            else {
                                return true;
                            }
                    }
            }
        });

        // set tinymce language

        // init tinymce if it exists
        viewer.initTinyMCE();

        // handle browser bugs
        switch (_defaults.browser) {
            case 'Chrome':
                break;
            case 'Firefox':
                break;
            case 'IE':
                /* SET IE CLASS TO HTML */
                $('html').addClass('is-IE');
                break;
            case 'Edge':
                break;
            case 'Safari':
                break;
        } 
        
        // hide second scrollbar if modal is too long, bootstrap adaption
		$(document.body).on("show.bs.modal", function () {
			$(window.document).find("html").addClass("modal-open");
		});
		$(document.body).on("hide.bs.modal", function () {
			$(window.document).find("html").removeClass("modal-open");
		});

		// Method to select widget chronology input data and hide tooltip on click on input
		$('.widget-chronology-slider__item-input').click(function() {
			$('[data-toggle="tooltip"]').tooltip('hide');
			$(this).select();
		});	
		$('.widget-chronology-slider__item-input').focus(function(){
			$('.widget-chronology-slider__item-input[data-toggle="tooltip"]').tooltip('disable');
		}).blur(function(){
			$('.widget-chronology-slider__item-input[data-toggle="tooltip"]').tooltip('enable');
		});
		
		
		//init empty translator instance
	    var restApiURL = restURL.replace("/rest", "/api/v1");
	    viewer.translator = new viewerJS.Translator(restApiURL, currentLang);
		viewer.initialized.next();
		viewer.initialized.complete();
		viewer.setCheckedStatus();
		viewer.slider.init();
    viewer.accessibility.init();
	// EOL viewerJS function
    };

    
    viewer.showLoader = function() {
        viewer.jsfAjax.complete.pipe(rxjs.operators.first()).subscribe(() => $(".ajax_loader").hide())
        $(".ajax_loader").show();
    }
  
    viewer.initSidebarCollapseable = function() {
    	$('body').on('click', '.widget__title.collapseable', function (e) {
			$(this).toggleClass('in').closest('.widget').find('.widget__body.collapseable').slideToggle(300, function() {
				viewer.toggledCollapseable.next(e);
		    })
		})
    }
   
    viewer.initTinyMCE  = function(event) {
        //trigger initializazion if either no event was given or if it is a jsf event in status 'success'
        if(!event || event.status == "success") {            
            if ($('.tinyMCE').length > 0) {
                viewer.tinyConfig.language = currentLang;
                viewer.tinyConfig.setup = function (ed) {
                    // listen to changes on tinymce input fields
                    ed.on('init', function (e) {
                        viewerJS.stickyElements.refresh.next();
                    });
                    
                    ed.on('change input paste', function (e) {
                       tinymce.triggerSave();
                       //trigger a change event on the underlying textArea
                       $(ed.targetElm).change();
                        if (currentPage === 'adminCmsNewPage') {
                            createPageConfig.prevBtn.attr('disabled', true);
                            createPageConfig.prevDescription.show();
                        }
                    });
                };
                viewerJS.tinyMce.init(viewer.tinyConfig);
            }
        }
    }

	viewer.initDisallowDownload = function() {
		$("[data-allow-download='false']").each( (index, ele) => {
			ele.addEventListener('contextmenu', function(e) {
			  e.preventDefault();
			});
		})
	}

    viewer.initFragmentNavigation = function () {
        if (window.location.hash) {
            $(document).ready(function () {
                var hash = window.location.hash;
                if(!hash.includes("=")) {                    
                    var $hashedElement = $(hash);
                    if ($hashedElement.length > 0) {
                        $hashedElement.get(0).scrollIntoView();
                        
                        var $hashedCollapsible = $hashedElement.find(".collapse");
                        if ($hashedCollapsible.length > 0) {
                            $hashedCollapsible.collapse("show");
                        }
                    }
                }
            })
        }
    }

    viewer.initStoreScrollPosition = function () {
        $(document).ready(function () {
            viewer.checkScrollPosition()
        })
        $('body').on('click', 'a.remember-scroll-position', function () {
            viewer.handleScrollPositionClick(this);
        });
    }

    viewer.checkScrollPosition = function () {
        var scrollPositionString = sessionStorage.getItem('scrollPositions');

        if (scrollPositionString) {
            var scrollPositions = JSON.parse(scrollPositionString);
            var scrollPosition = scrollPositions[currentPage];
            if (scrollPosition) {
                var linkId = scrollPosition.linkId;
                var $element = $('a[data-linkid="' + linkId + '"]');
                if ($element.length > 0) {
                    var scrollTop = scrollPosition.scrollTop;
                    if (_debug) {
                        console.log('scroll to position ', scrollTop);
                    }
                    $('html').scrollTop(scrollTop);
                    //after scrolling to the position, remove the entry
                    scrollPositions[currentPage] = undefined;
                    sessionStorage.setItem('scrollPositions', JSON.stringify(scrollPositions));
                }
            }
        }
    }

    viewer.handleScrollPositionClick = function (element) {
        var scrollPositions = {};
        var scrollPositionString = sessionStorage.getItem('scrollPositions');
        if (scrollPositionString) {
            scrollPositions = JSON.parse(scrollPositionString);
        }

        scrollPositions[currentPage] = {
            scrollTop: $('html').scrollTop(),
            linkId: $(element).data('linkid')
        }
        if (_debug) {
            console.log('saving scrollPositions ', scrollPositions);
        }
        sessionStorage.setItem('scrollPositions', JSON.stringify(scrollPositions));
    }

    viewer.initFacetsFilters = function () {
        var $facets = $('.widget-search-facets__collection');

        $facets.each(function () {
            var filterConfig = {
				inputToggle: $(this).find('[data-toggle="filter-input"]'),
                wrapper: $(this).find('.widget-search-facets__filter'),
                header: $(this).find('h2'),
                input: $(this).find('.widget-search-facets__filter-input'),
                elements: $(this).find('li')
            }

            var filter = new viewerJS.listFilter(filterConfig);
        });
    }
    
    //for all html elements with attribute "data-checked" add the "checked" attribute - or remove it if the value of "data-checked" is "false"
    viewer.setCheckedStatus = function() {
    	$("[data-checked]").each( (index, element) => {
    		let checked = element.getAttribute("data-checked");
    		if(checked == "false") {
    			element.removeAttribute("checked");
    		} else {
    			element.setAttribute("checked", null);
    		}
    		
    	});
    }

    // Helper fn: returns true if OS is iOS
    viewer.iOS = function() {
      return [
          'iPad Simulator',
          'iPhone Simulator',
          'iPod Simulator',
          'iPad',
          'iPhone',
          'iPod'
        ].includes(navigator.platform)
        // iPad on iOS 13 detection
        || (navigator.userAgent.includes("Mac") && "ontouchend" in document)
    }
    
    viewer.getRestApiUrl = function () {
        return restURL.replace("/rest", "/api/v1");
    }
    
    viewer.initWidgetUsage = function() {
    	let $widgetUsage = $(".widget-usage");
    	if($widgetUsage.length > 0) {
    		let $widgetTitles = $widgetUsage.find(".widget-usage__subtitle");
    		$widgetTitles.each((index,element) => {
    			let $title = $(element);
    			let $options = $title.next();
    			if($options.length == 0) {
    				$title.hide();
    			} else {
					// console.log('not empty!');
				}
    		});
    	}
    }

	viewer.initFragmentActions = function() {
		window.onhashchange = () => viewer.handleFragmentAction();
		viewer.handleFragmentAction();
	}
	
	// IF #feedback HASH IS RECOGNIZED MAKE OPEN MODAL LINK OUT OF IT
	viewer.handleFragmentAction = function() {
		let hash = location.hash;
		if(hash) {
			let hashName = hash.replace(/[=:].*/, "");
			switch(hashName) {
				case "#feedback":
					
					$('#feedbackModal').modal();
					let recipientMatch = hash.match(/recipient=([\w-]+)/);
					if(recipientMatch && recipientMatch.length == 2) {
						let recipient = recipientMatch[1];					
						$('#feedbackModal .feedback-modal__recipient-dropdown').find('[data-recipient-id="'+recipient+'"]').attr('selected', 'selected');
					}
					$('#feedbackModal').on('hidden.bs.modal', function (e) {
						history.replaceState({}, '', window.location.href.replace(/#feedback.*$/, ""));
					})
					break;
				case "#?page":
					// SHOW LOADER BEFORE REDIRECT
					$("[data-loader='fullOverlay']").show();
					$("html").addClass('modal-open');
					// SHOW THE LOADER FOR SOME TIME TO AVOID UNWANTED FLASHING OF HALF TRANSPARENT BACKDROP
					// THEN REDIRECT
					setTimeout(function(){
						let url = location.href.replace("#?page", "&page");
						location.replace(url);
					}, 1400);

			}
		}
	}

	// REQUIRED FIELDS/CHECKBOXES CHECK
	viewer.initRequiredInputs = function() {
	
		let $requireElements = $("[data-require-input]");
		
		$requireElements.each((index, element) => {
			let $ele = $(element);
			$ele.attr("disabled", "disabled");
			let id = $(element).attr("data-require-input").replace(/[!"#$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\\\$&");
			let $texts = $("[data-require-input-text='" + id + "']");
			let $checkboxes = $("input[data-require-input-checkbox='" + id + "']");
			let $uncheckedRadios = $('input[data-require-input-checkbox="uncheckedChecker"]');
			
			var allCheckboxesChecked = false;
			var allTextFieldsFilled = false;
			
			if ($checkboxes.length == 0) {
				// console.log('no checkboxes to check, so allCheckboxesChecked is true');
				var allCheckboxesChecked = true;
			}
			
			
			// CHECK ALL REQUIRED CHECKBOXES AND TEXT FIELDS + CHECK IF RADIO BUTTONS "UNCHECKED"
			$checkboxes.add($texts).add($uncheckedRadios).on("change paste keyup cut", (e) => {
				$checkboxes.each((index, element) => {
					if ( $(element).is(':checked') ) {
						let isChecked = true;
						  // console.log("all boxes checked");
						 // console.log(allCheckboxesChecked);
						 allCheckboxesChecked = true;
					} else {
						let isChecked = false;
						allCheckboxesChecked = false;
						// console.log(allCheckboxesChecked);
						// console.log("not all boxes checked");
						return false;
					}
					});
				
					$texts.each((index, element) => {
						let text = $(element).val();
						if(!text) {
							allTextFieldsFilled = false;
							// console.log(allTextFieldsFilled);
							// console.log($texts);
							// console.log('NO - not all texts filled');
							return false;
						} else {
							allTextFieldsFilled = true;
							// console.log($texts);
							// console.log('YES - all texts filled');
						}
					});
				
				
				// ACTIVATE SUBMIT BUTTON IF ALL REQUIRED CHECKBOXES AND TEXTFIELDS ARE FILLED/CHECKED
				if(allCheckboxesChecked && allTextFieldsFilled == true) {
					$ele.removeAttr("disabled");
					// console.log('button activated, removed attribute');
				} else {
					$ele.attr("disabled", "disabled");
					// console.log('button DEactivated, attribute added');
				}
				
				// console.log(allCheckboxesChecked);
							
			});
			
		});
	
	}

	
	
    // CONTENT ITEMS JS DRAFT
	$(document).ready(function(){
		if(typeof SimpleLightbox != "undefined" ) {			
			new SimpleLightbox({elements: '[data-target="imageLightbox"]'});
		}
	});


    // global object for tinymce config
    viewer.tinyConfig = {};

    return viewer;
    
})(jQuery);
  
	// loading screen while page redirect

	

	// overriding enforceFocus for bootstrao modals in general - important: This might be a problem for accessibility
	// $.fn.modal.Constructor.prototype._enforceFocus = function() {};

	//reset global bootstrap boundary of tooltips to window
    if($.fn.tooltip.Constructor) {        
        $.fn.tooltip.Constructor.Default.boundary = "window";
        $.fn.dropdown.Constructor.Default.boundary = "window";
    }

var viewerJS = ( function( viewer ) {
    'use strict';
        
    // default variables
    var _debug = false;
    
    viewer.helper = {
        /**
         * saveSidebarTocPosition Method to truncate a string to a given length.
         * @method truncateString
         * @param {String} str The string to truncate.
         * @param {Number} size The number of characters after the string should be
         * croped.
         * @returns {String} The truncated string.
         * @example
         * 
         * <pre>
         * viewerJS.helper.truncateString( $( '.something' ).text(), 75 );
         * </pre>
         */
        truncateString: function( str, size ) {
            if ( _debug ) {
                console.log( '---------- viewer.helper.truncateString() ----------' );
                console.log( 'viewer.helper.truncateString: str = ', str );
                console.log( 'viewer.helper.truncateString: size = ', size );
            }
            
            var strSize = parseInt( str.length );
            
            if ( strSize > size ) {
                return str.substring( 0, size ) + '...';
            }
            else {
                return str;
            }
        },
        /**
         * @description Returns an JSON object from a API call. 
         * @method getRemoteData
         * @param {String} url The API call URL.
         * @returns {Object} A promise object, which tells about the success of receiving
         * data.
         * @example
         * 
         * <pre>
         * viewerJS.helper.getRemoteData( dataURL );
         * </pre>
         */
        getRemoteData: function( url ) {
            if ( _debug ) {
                console.log( '---------- viewer.helper.getRemoteData() ----------' );
                console.log( 'viewer.helper.getRemoteData: url = ', url );
            }
            
            //alternative using fetch
            /*var promise = fetch(decodeURI(url),  {
            	headers: {
				  'Content-Type': 'application/json'
				},
            })
            .then(resp => resp.json());*/
            
            
            var promise = $.ajax( {
                url: decodeURI( url ),
                type: "GET",
                dataType: "JSON",
                async: true
            } );
            
            return promise;
        },
        /**
         * @description Returns a BS Modal with dynamic content.
         * @method renderModal
         * @param {Object} config An config object which includes the content of the
         * modal.
         * @param {String} config.id The ID of the modal.
         * @param {String} config.label The label of the modal.
         * @param {Object} config.string An object of strings for the modal content.
         * @param {String} config.string.title The title of the modal.
         * @param {String} config.string.body The content of the modal as HTML.
         * @param {String} config.string.closeBtn Buttontext
         * @param {String} config.string.saveBtn Buttontext
         * @returns {String} A HTML-String which renders the modal.
         */
        renderModal: function( config ) {
            if ( _debug ) {
                console.log( '---------- viewer.helper.renderModal() ----------' );
                console.log( 'viewer.helper.renderModal: config = ', config );
            }
            var _defaults = {
                id: 'myModal',
                label: 'myModalLabel',
                closeId: 'closeModal',
                submitId: 'submitModal',
                string: {
                    title: 'Modal title',
                    body: '',
                    closeBtn: 'Close',
                    saveBtn: 'Save changes',
                }
            };
            
            $.extend( true, _defaults, config );
            var modal = '';
            
            modal += '<div class="modal fade" id="' + _defaults.id + '" tabindex="-1" role="dialog" aria-labelledby="' + _defaults.label + '">';
            modal += '<div class="modal-dialog" role="document">';
            modal += '<div class="modal-content">';
            modal += '<div class="modal-header">';
            modal += '<h3 class="modal-title" id="' + _defaults.label + '">' + _defaults.string.title + '</h3>';
            modal += '<button type="button" class="fancy-close" data-dismiss="modal" aria-label="' + _defaults.string.closeBtn + '">';
            modal += '<span aria-hidden="true">x</span>';
            modal += '</button>';
            modal += '</div>';
            modal += '<div class="modal-body">' + _defaults.string.body + '</div>';
            modal += '<div class="modal-footer">';
            modal += '<button type="button" id="' + _defaults.closeId + '"  class="btn" data-dismiss="modal">' + _defaults.string.closeBtn + '</button>';
            modal += '<button type="button" id="' + _defaults.submitId + '" class="btn btn--success">' + _defaults.string.saveBtn + '</button>';
            modal += '</div></div></div></div>';
            
            return modal;
        },

        /**
         * @description Method to return a BS Alert with dynamic content.
         * @method renderAlert
         * @param {String} type The type of the alert.
         * @param {String} content The content of the alert.
         * @param {Boolean} dismissable Sets the option to make the alert dismissable,
         * true = dismissable.
         * @returns {String} A HTML-String which renders the alert.
         */
        renderAlert: function( type, content, dismissable ) {
            if ( _debug ) {
                console.log( '---------- viewer.helper.renderAlert() ----------' );
                console.log( 'viewer.helper.renderAlert: type = ', type );
                console.log( 'viewer.helper.renderAlert: content = ', content );
                console.log( 'viewer.helper.renderAlert: dismissable = ', dismissable );
            }
            var bsAlert = '';
            
            bsAlert += '<div role="alert" class="alert ' + type + ' alert-dismissible fade in show">';
            if ( dismissable ) {
                bsAlert += '<button aria-label="Close" data-dismiss="alert" class="close" type="button"><span aria-hidden="true">×</span></button>';
            }
            bsAlert += content;
            bsAlert += '</div>';
            
            return bsAlert;
        },
        /**
         * @description Method to get the version number of the used MS Internet Explorer.
         * @method detectIEVersion
         * @returns {Number} The browser version.
         */
        detectIEVersion: function() {
            var ua = window.navigator.userAgent;
            
            // IE 10 and older
            var msie = ua.indexOf( 'MSIE ' );
            if ( msie > 0 ) {
                // IE 10 or older => return version number
                return parseInt( ua.substring( msie + 5, ua.indexOf( '.', msie ) ), 10 );
            }
            
            // IE 11
            var trident = ua.indexOf( 'Trident/' );
            if ( trident > 0 ) {
                // IE 11 => return version number
                var rv = ua.indexOf( 'rv:' );
                return parseInt( ua.substring( rv + 3, ua.indexOf( '.', rv ) ), 10 );
            }
            
            // IE 12+
            var edge = ua.indexOf( 'Edge/' );
            if ( edge > 0 ) {
                // Edge (IE 12+) => return version number
                return parseInt( ua.substring( edge + 5, ua.indexOf( '.', edge ) ), 10 );
            }
            
            // other browser
            return false;
        },        
        /**
         * @description Method to check if it´s possible to write to local Storage.
         * @method checkLocalStorage
         * @returns {Boolean} true or false
         */
        checkLocalStorage: function() {
            if ( typeof localStorage === 'object' ) {
                try {
                    sessionStorage.setItem( 'testLocalStorage', 1 );
                    sessionStorage.removeItem( 'testLocalStorage' );
                    
                    return true;
                }
                catch ( error ) {
                    console.error( 'Not possible to write in local Storage: ', error );
                    
                    return false;
                }
            }
        },        
        /**
         * @description Method to render a warning popover.
         * @method renderWarningPopover
         * @param {String} msg The message to show in the popover.
         * @returns {Object} An jQuery Object to append to DOM.
         */
        renderWarningPopover: function( msg ) {
            var popover = $( '<div />' );
            var popoverText = $( '<p />' );
            var popoverButton = $( '<button />' );
            var popoverButtonIcon = $( '<i aria-hidden="true" />' );
            
            popover.addClass( 'warning-popover' );
            
            // build button
            popoverButton.addClass( 'btn btn--clean' );
            popoverButton.attr( 'data-toggle', 'warning-popover' );
            popoverButtonIcon.addClass( 'fa fa-times' );
            popoverButton.append( popoverButtonIcon );
            popover.append( popoverButton );
            
            // build text
            popoverText.html( msg );
            popover.append( popoverText );
            
            return popover;
        },
        /**
         * @description Method to validate the reCAPTCHA response.
         * @method validateReCaptcha
         * @param {String} wrapper The reCAPTCHA widget wrapper.
         * @param {String} key The reCAPTCHA site key.
         * @returns {Boolean} Returns true if the response is valid.
         */
        validateReCaptcha: function( wrapper, key ) {
            var widget = grecaptcha.render( wrapper, {
                sitekey: key,
                callback: function() {
                    var response = grecaptcha.getResponse( widget );
                    
                    if ( response == 0 ) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            } );
        },        
        /**
         * @description Method to initialize Bootstrap features (tooltips).
         * @method initBsFeatures
         */
        initBsFeatures: function() {
        	if ( _debug ) {
        	    console.log( 'EXECUTE: viewerJS.helper.initBsFeatures' );
            }
        	
//        	// (re)-enable BS tooltips
//        	$( '.tooltip' ).remove();
//	    	$( '[data-toggle="tooltip"]' ).tooltip('dispose');
//            $( '[data-toggle="tooltip"]' ).tooltip( {
//                trigger : 'hover'
//            } );
            
            // (re)-enable BS tooltips
            
			/* The manually determine when an item should show and hide a tool tip. */
			$('[data-toggle="tooltip"]').tooltip({ trigger: "manual" })
			.on( "mouseenter.tooltip", event => {
				$('[data-toggle="tooltip"]').tooltip("hide");
				$(event.currentTarget).tooltip("show");
				$(".tooltip").on("mouseleave", function() {
					$(event.currentTarget).tooltip("hide");
				})
			
			})
			.on('mouseleave.tooltip', event => {
				setTimeout(() => {
					if (!$(".tooltip:hover").length) $(event.currentTarget).tooltip("hide");
				}, 100);
			})
			
			// show tooltips on (keyboard) focus
			.focus(event => {
				$(event.currentTarget).tooltip("show");
			})
			.blur(event => {
				$(event.currentTarget).tooltip("hide");
			});

			/* Listen for the "escape key" so tool tips can easily be hidden */
			$("body").keydown(event => {
			  if (event.keyCode === 27) {
			    $('[data-toggle="tooltip"]').tooltip("hide");
			  }
			});
            
            
            if ( window.matchMedia( '(max-width: 768px)' ).matches ) {
            	$( '[data-toggle="tooltip"]' ).tooltip( 'dispose' );
            }
            
            

            // enable bootstrap popovers
            $( '[data-toggle="popover"]' ).popover( {
            	placement: 'bottom',
	            trigger: 'hover',
	            html: true
            } );

			// append all bootstrap modals to body
			  $('.modal').not('.user-login-modal').appendTo("body");
	
			// remove tooltips for deactivated admin cms move order buttons
	    	$( document ).ready(function() {
				$( 'button[class^="admin__content-component-order-arrow"][disabled="disabled"][data-toggle="tooltip"]' ).tooltip('dispose');
	    	});

        },
        
        initNumberOnlyInput: function() {
            $("body").on("keypress", "[data-input='number']", (event) => {
                if(!validateNumber(event)) {
                    event.preventDefault();
                }
            })
            
            function validateNumber(event) {
                var key = window.event ? event.keyCode : event.which;
                if (event.keyCode === 8 || event.keyCode === 46 || event.keyCode === 13) {
                    return true;
                } else if ( key < 48 || key > 57 ) {
                    return false;
                } else {
                    return true;
                }
            };
        },
        
        /**
         * @description Method to get the current year.
         * @method getCurrentYear
         * @returns {Number} The current year.
         * */
        getCurrentYear: function() {
        	if ( _debug ) {
                console.log( 'EXECUTE: viewerJS.helper.getCurrentYear' );
            }
        	
        	return new Date().getFullYear(); 
        },
        /**
         * Get css style values based on one or more class names
         * 
         * @param classes   A string containing all class names determining the styles
         * @param styles    An array containing all style attributes to get
         * @return  An object containing the requested styles
         */
        getCss: function(classes, styles) {
            let $template = $("<span class='"+classes+"'/>");
            $template.appendTo($("body"));
            let values = $template.css(styles);
            $template.remove();
            return values;
        },
        
        getFragmentHash: function( ) {
            let coordsRegex = /xywh=((?:percent:)?[\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+,[\d\.\-\+]+)/;
            let hash = window.location.hash;
            let fragments = [];
            if(hash) {
                let match;// = fragment.match(coordsRegex);
                let count = 0;
                while ((match = coordsRegex.exec(hash)) && count++ < 100) { 
                    let coords = match[1];
                    fragments.push(coords);
                    hash = hash.replace(match[0], "");
                }
            }
            if(fragments.length == 1) {
                return fragments[0];
            } else if(fragments.length > 1) {
                return fragments;
            } else {
                return undefined;
            }
        },
        
        executeFunctionByName: function(functionName, context /*, args */) {
            var args = Array.prototype.slice.call(arguments, 2);
            var namespaces = functionName.split(".");
            var func = namespaces.pop();
            for(var i = 0; i < namespaces.length; i++) {
              context = context[namespaces[i]];
            }
            return context[func].apply(context, args);
         },
         getFunctionByName: function(functionName, context) {
             var namespaces = functionName.split(".");
             var func = namespaces.pop();
             for(var i = 0; i < namespaces.length; i++) {
               context = context[namespaces[i]];
             }
             return context[func];
          },
          getUrlSearchParamMap: function() {
              let searchParams = document.location.search.substr(1).split('&').filter(p => p != undefined && p.length > 0);
              let paramMap = new Map();
              searchParams.forEach(param => {
                  let parts = param.split("=");
                  paramMap.set(parts[0], parts[1]);
              })
              return paramMap;
          },
          getUrlSearchParam: function(key) {
          	return this.getUrlSearchParamMap().get(key);
          },
          setUrlSearchParams: function(map) {
              let paramList = [];
              map.forEach((value, key) => {
                  paramList.push(key + "=" + value);
              })
              document.location.search = paramList.join("&");
          }
         

    };
    
    viewer.localStoragePossible = viewer.helper.checkLocalStorage();
    
    viewer.setUrlQuery = function(param, value) {
        let paramMap = viewer.helper.getUrlSearchParamMap();
        if(!value || value.length == 0) {
            paramMap.delete(param);
        } else {
            paramMap.set(param, value);
        }
        viewer.helper.setUrlSearchParams(paramMap);
        return true;
    }
    
    viewer.setUrlHash = function(hash) {
        document.location.hash = "#" + hash;
        return true;
    }
    
    viewer.getMapBoxToken = function() {
        if(typeof this.mapBoxConfig != "undefined" && typeof this.mapBoxConfig.token != "undefined") {
            return this.mapBoxConfig.token;
        } else if(typeof mapBoxToken != "undefined") {
            return mapBoxToken;
        } else {
            return undefined; 
        }
    }
        
    viewer.getMetadataValue = function(object, language) {
        if(typeof object === "string") {
            return object;
        } else if(Array.isArray(object) && object.length > 0 && typeof object[0] === "string") {
            return object.join(" ");
        }
        return viewer.getOrElse([language, 0], object);
    }   

    viewer.getOrElse = function(p, o) {  
        var reducer = function(xs, x) {
            return (xs && xs[x]) ? xs[x] : ((xs && xs[Object.keys(xs)[0]]) ? xs[Object.keys(xs)[0]] : null);
        }
        return p.reduce(reducer , o);
    };
    
    /**
     * Check if a variable is a string
     */
    viewer.isString = function(variable) {
        return typeof variable === 'string' || variable instanceof String
    }
    
    if(!Array.prototype.includes) {
        Array.prototype.includes = function(element) {
            for ( var int = 0; int < this.length; int++ ) {
                var listEle = this[int];
                if(listEle == element) {
                    return true;
                }
            }
            return false;
        }
    }
    
    if(!Array.prototype.flatMap) {
        Array.prototype.flatMap = function(callback) {
            var res = [];
            for ( var int = 0; int < this.length; int++ ) {
                var listEle = this[int];
                let value = callback(listEle, int, this);
                res.push(value);
            }
            return res;
        }
    }
    
    /**
     * Filter function to keep only unique values in arrays.
     * Use as array.filter(viewerJS.unique);
     */
    viewer.unique = (value, index, self) => {
        return self.indexOf(value) === index;
    } 
    
    /**
    * Create a map from the given object by using the property names as keys and their values as values
    * a missing or empty object results in an empty map
    */
    viewer.parseMap = (object) => {
    	let map = new Map();
    	if(object) {
    		Object.keys(object).forEach(key => {
    			map.set(key, object[key]);
    		});
    	}
    	return map;
    }
 

	viewer.helper.compareNumerical = (a, b) => {
	    let ia = parseInt(a);
	    let ib = parseInt(b);
	    if(isNaN(ia) && isNaN(ib)) {
	        return 0;
	    } else if(isNaN(ia)) {
	        return 1;
	    } else if(isNaN(ib)) {
	    	return -1;
	    } else {
	    	return ia-ib;
	    }
	}
	
	viewer.helper.compareAlphanumerical = (a, b) => {
	    if(a && b) {
	        return a.localeCompare(b);
	    } else if(a) {
	        return 1;
	    } else {
	        return -1;
	    }
	} 

	viewer.helper.initRestrictedInputFields = () => {
		let $inputs = $("[data-input-restricted='url']");
		$inputs.each( (index, element) => {
			let notAllowedMessage = $(element).attr("data-input-restricted-message");
			$(element).on("keypress", (e) => {
				let character = e.originalEvent.key;
				if(character) { 
					if(character.match(/[\s#?]/)) {
						e.preventDefault();
						let message = notAllowedMessage.replace("{}", character);
						viewer.swaltoasts.error(message);
					}
				}
			});
		});
	}
	
	/**
	 * Creates a repeating cancellable promise with a specified delay between repetitions.
	 *
	 * @param {Promise} promise - The promise to repeat.
	 * @param {number} delay - The delay (in milliseconds) between repetitions. The delay timer starts after a promise is returned
	 * @returns {object} - An object with methods for cancellation and result handling.
	 */
	viewer.helper.repeatPromise = (promise, delay) => {
		const cancelSubject = new rxjs.Subject();
		const observable = rxjs.of(null).pipe(rxjs.operators.flatMap(promise), rxjs.operators.delay(delay), rxjs.operators.repeat(), rxjs.operators.takeUntil(cancelSubject));
		return {
			/**
		     * Cancels the repeating promise, preventing further repetitions.
		     */
			cancel: () => cancelSubject.next(),
			/**
		     * Subscribes to the observable and executes the provided function
		     * with the result of the promise each time it resolves.
		     *
		     * @param {function} f - The function to execute with the result of the promise.
		     */
			then: f => observable.subscribe(result => f(result))
		}
	}

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // Default variables
    var _debug = false;
    
    viewer.accessibility = {
      // Detect if a user uses the tab key to navigate
      // And add/remove a class to the body accordingly
      // The class helps adding styles specific to keyboard navigation 
      detectKeyboardUsage: function() {
        // Keyboard is used
        document.body.addEventListener('keydown', function(e) {
          // Check if tab key was pressed 
          if (e.keyCode === 9 || e.key == 'Tab') {
            document.body.classList.add('using-keyboard');
          }
        });
        // Mouse is used
        document.body.addEventListener('mousedown', function() {
          document.body.classList.remove('using-keyboard');
        });
      },

	  // Jump to footer if link or button in footer is focused with keyboard (tab)
      jumpToFooter: function() {

		if( $('#pageFooter').length ) {
			$(document).on('keydown',function(e) {
			    if(e.which == 9) {
				setTimeout(function(){ 
			        if ($("#pageFooter a").is(":focus") || $("#pageFooter button").is(":focus")) {
					    window.scrollTo(0,document.body.scrollHeight);
					}
					}, 20);
	
			    }
			});
		}
      },

      // ###########################
      // WHAT: Make certain elements behave like buttons
      // Condition: Elements must have a role="button" attribute
      // WHY: Sometimes click events are assigned to non interactive elements (like <span>) or <a> tags should actually be marked up as buttons
      // if this markup cannot be changed, these fns create the same ux as a native <button> element when using keyboard navigation or assistive techonlogy

      // Find elements (role="button")
      // Assign an event listener + fire triggerClick()
      findPseudoBtns: function() {
        const interactiveEls = document.querySelectorAll('[role="button"]');
        interactiveEls.forEach( el => el.addEventListener('keydown', this.triggerClick));
      },

      // Trigger a click when pressing the space bar or Enter on a Pseudo button
      triggerClick: function(e)  {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          this.click();
        }
      },
      // ###########################

      init: function() {
        if(_debug) console.log('init `viewerJS.accessibility`');
        this.detectKeyboardUsage();
		    this.jumpToFooter();
        this.findPseudoBtns();
      },
    };     

    return viewer;
} )( viewerJS );


var viewerJS = ( function( viewer ) {
    'use strict';

    var _debug = false;
    
    var _defaults = {
            initHcSticky: false,
            initSearch: false,
            initTextTree: false
    };
 
    viewer.archives = { 
    	recordPi : "", //pi of the current record. Read from [data-name="recordPi"] and used to create image display and record links
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.archivesSeparate.init' );
                console.log( '##############################' );
                console.log( 'viewer.archivesSeparate.init: config - ', config );
            }
            this.config = $.extend( true, {}, _defaults, config );
			$(".archives__object-image").hide();
            
            
            jQuery(document).ready(($) => {
				
				this.initImageDisplay();
				
                if(this.config.initHcSticky) {                    
                    this.initHcStickyWithChromeHack();
                }
                viewerJS.jsfAjax.success
                .pipe(rxjs.operators.filter(e => $(e.source).attr("data-select-entry") != undefined))
                .subscribe(e => {
                    $(".archives__object-image").hide();
                	this.initImageDisplay()
                	.then(() => {
	                    if(this.config.initHcSticky) {                        
	                        this.refreshStickyWithChromeHack();
	                    }
	                    this.setLocation(e.source);
                	});
                });
                
                if(this.config.initSearch) {
                    this.initSearch();
                }
            	 
            	 if(this.config.initTextTree) {
            	     this.initTextTree();
            	 }

            	 // execute when expanding or collapsing entries after ajax success
                 viewerJS.jsfAjax.success
                 .pipe(rxjs.operators.filter(e => $(e.source).attr("data-expand-entry") != undefined))
                 .subscribe(e => {
                     $(".archives__object-image").hide();
                 	this.initImageDisplay()
                 	.then(() => {
 	                    if(this.config.initHcSticky) {                        
 	                        this.refreshStickyWithChromeHack();
 	                    }
                 	});
                 });
            });            
            
        },
        
        initImageDisplay() {
        	let $recordPiInput = $('[data-name="recordPi"]');
        	//console.log("record pi", $recordPiInput, $recordPiInput.val());
        	this.hideLoader("load_record_image");
        	if($recordPiInput.length > 0) {
        		let containsImage = $recordPiInput.attr("data-contains-image");
        		let recordPi = $recordPiInput.val();
        		let oldPi = this.recordPi;
        		this.recordPi = recordPi;
        		//console.log("record pi is " + recordPi + " old pi is " + oldPi);
        		if(!containsImage || containsImage.toLowerCase() == "false") {
        			return Promise.resolve();
        		} else if(this.recordPi && this.recordPi != oldPi) {
        			let manifestUrl = rootURL + "/api/v2/records/" + recordPi + "/manifest/";
        			this.showLoader("load_record_image");
        			//console.log("load ", manifestUrl);
        			return fetch(manifestUrl)
        			.then(response => {if(response.ok) return response.json(); else throw(response.json());})
        			.then(manifest => {
        				//if the manifest contains struct elements, show them as thumbnail gallery
        				if(manifest.structures && manifest.structures.length > 1) {
				        	riot.mount(".archives__object-thumbnails", "thumbnails", {
					        	language : currentLang, 
					        	type: "structures",
					        	source: manifest,
					        	imagesize: ",250",
					        	label: "MD_SHELFMARK",
					        	onload: () => {
					        		this.hideLoader("load_record_image");
					        		this.refreshStickyWithChromeHack();
					        	},
					        	link: (canvas) => {
					        		if(canvas.homepage && canvas.homepage.length > 0) {
										return canvas.homepage[0].id.replace("/image/", "/fullscreen/");
									} else {
										return undefined;
									}
					        	} 
				        	});
        				} else {
        					let thumbnail = viewerJS.iiif.getId(manifest.thumbnail[0]);
        					//console.log("show thumbnail", thumbnail);
	        				if(thumbnail) {
	        				let $img = $(".archives__object-image").find("img");
	        					$img.on("load", () => {
	        						this.hideLoader("load_record_image");
		        					$(".archives__object-image").show();
									$(".archives__object-metadata").addClass("-singleImage");
	        					});
	        					$img.on("error", () => {
	        						this.hideLoader("load_record_image");
	        						$(".archives__object-image").hide();
	        					});
	        					$img.attr("src", thumbnail);

								// Add alternative text to images
								try  {
								let altText =  viewerJS.iiif.getId(manifest.label.none[0]);
								$img.attr("alt", altText);
								//console.log(1)
								//console.log(viewerJS.iiif.getId(manifest.label.none[0]))
								}
								catch (e) {
									// console.log(e);
									$img.attr("alt", "Sorry, no alternative text available.");
								}

	        				} else {
	        					this.hideLoader("load_record_image");
	        					$(".archives__object-image").hide();
	        				}
	        			}
        			})
        			.catch(error => {
        			console.log("error", error);
	        			this.hideLoader("load_record_image");
        				error.then( (e) => {
	        				console.log("error loading record '" + recordPi + "'", e);
	        				//viewer.notifications.error(e.message);
        				});
        			});
        		}
        	}
        	return Promise.resolve();
        },

        showLoader: function(loader) {
        	let $loader = $("[data-loader='"+loader+"']");
        	if($loader.length > 0) {
        		$loader.show();
        	}
        },

        hideLoader: function(loader) {
        	let $loader = $("[data-loader='"+loader+"']");
        	if($loader.length > 0) {
        		$loader.hide();
        	}
        },

        initTextTree: function() {
         // toggle text-tree view from stairs to one line
            $('body').on("click", '.archives__text-tree', function() {
                $('.archives__text-tree').toggleClass('-showAsOneLine');
            });
        },

        initSearch: function() {
			/* Trigger for search */
			$('#archivesSearchTrigger').on('click', function(){
				$(this).toggleClass('-active');
				
				if ($('.archives__search-input-wrapper').is(":visible")) {
				$('.archives__search-input-wrapper').slideToggle('fast');
				
				setTimeout(
				  function() {
					$('.archives__search-input').val("");
                	/* trigger empty search on click */
                	$('.archives__search-submit-button').click();
				  }, 200);

				}
				else {
					$('.archives__search-input-wrapper').slideToggle('fast');
					$('.archives__search-input').focus();
				}
		
			});

            /* check search field for input value and show clear button */
            if(!$('.archives__search-input').val() == ''){
                $('.archives__search-clear').show();
            }
            $('body').on("click", '.archives__search-clear', function(){
                /* clear value on click*/
            $('.archives__search-input').val("");
                /* trigger empty search on click */
                $('.archives__search-submit-button').click();
            });

             // auto submit search after typing
             let timeSearchInputField = 0;

             $('body').on('input', '.archives__search-input', function () {
                 // Reset the timer while still typing
                 clearTimeout(timeSearchInputField);

                 timeSearchInputField = setTimeout(function() {
                     // submit search query
                     $('.archives__search-submit-button').click();
                 }, 1300);
             });
        },

        /**
         * In chome with small window size (1440x900) hcSticky breaks on ajax reload if the page is scrolled
         * all the way to the button. To prevent this we quickly scroll to the top, refresh hcSticky and then scroll back down.
         * The scolling appears to be invisible to the user, probably because it is reset before actually being carried out
         */
        refreshStickyWithChromeHack: function() {
            let currentScrollPosition = $('html').scrollTop();
            $('html').scrollTop(0);
            this.refreshHcSticky();
            if(currentScrollPosition) {
                $('html').scrollTop(currentScrollPosition);
            }
        },

        refreshHcSticky: function() {
            if(_debug)console.log("update hc sticky");
			// $('.archives__left-side, .archives__right-side').hcSticky('refresh');
            $('.archives__left-side, .archives__right-side').hcSticky('update', {
                stickTo: $('.archives__wrapper')[0],
                top: 20,
                bottom: 20,
                responsive: {
                    993: {
                      disable: true
                    }
                }
           });
        },

        /**
         * In chome with small window size (1440x900) hcSticky breaks on page load if the view was previously scrolled
         * all the way to the bottom. To prevent this we scroll 5 px up before refreshing hcSticky.
         * The scolling appears to be invisible to the user, probably because it is reset before actually being carried out
         */
        initHcStickyWithChromeHack: function() {
            let currentScrollPosition = $('html').scrollTop();
            $('html').scrollTop(currentScrollPosition-5);
            this.initHcSticky();
        },

        initHcSticky: function() {
            if(_debug)console.log("init hc sticky");
                        
            // Sticky right side of archives view
            $('.archives__right-side').hcSticky({
                stickTo: $('.archives__wrapper')[0],
                top: 20,
                bottom: 20,
                responsive: {
                    993: {
                      disable: true
                    }
                }
            });

            // Sticky left side of archives view
            $('.archives__left-side').hcSticky({
                stickTo: $('.archives__wrapper')[0],
                top: 80,
                bottom: 20,
                responsive: {
                    993: {
                      disable: true
                    }
                }
            });
        },

        setLocation: function(element) {
            if(_debug)console.log(" clicked data-select-entry", element);
            let select = $(element).attr("data-select-entry");
            let url = window.location.origin + window.location.pathname;
            if(select) {
                url += ("?selected=" + select + "#selected");
            }
            if(_debug)console.log("set url ", url);
            window.history.pushState({}, '', url);
            //Call the commandscript "updateUrl" in archivesTreeView.xhtml to trigger an ajax call 
            //and update the page url to show the selected record 
            updateUrl();
        },

    };

    return viewer;
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) { 
    'use strict';
    
    var _debug = false;
    var _messageKeys = ['bookmarkList_reset', 'bookmarkList_delete', 'bookmarkList_session_mail_sendList', 
        'action__search_in_bookmarks', 'bookmarkList_resetConfirm', 'bookmarkList_noItemsAvailable', 
        'bookmarkList_selectBookmarkList', 'bookmarkList_addNewBookmarkList', 'viewMiradorComparison',
        'bookmarkList_type_label', 'bookmarkList_typeRecord', 'bookmarkList_typePage', 'bookmarkList_overview_all',
        'admin__crowdsourcing_campaign_statistics_numRecords', 'bookmarkList_removeFromBookmarkList', 'bookmarks'];

    var _defaults = {
        root: '',
        rest: '',
        counter: ".bookmark-navigation__counter",
        typePage: false,
        userLoggedIn: false,
        language: 'en'
    };
    var _bookmarks = {
             
            listsNeedUpdate: new rxjs.Subject(),
            listsUpdated: new rxjs.Subject(),
            bookmarkLists: [],
            init: function( config ) {
                if ( _debug ) {
                    console.log( '##############################' );
                    console.log( 'viewer.bookmarks.init' );
                    console.log( '##############################' );
                    console.log( 'viewer.bookmarks.init: config - ', config );
                }
                
                this.config = $.extend( true, {}, _defaults, config );
                this.typePage = this.config.typePage;
                this.listsNeedUpdate.subscribe( () => this.updateLists());
                this.listsUpdated.subscribe( (list) => {
                    this.updateAddedStatus();
                })
                this.translator = new viewerJS.Translator(this.config.rest, this.config.language);
                this.translator.init(_messageKeys)
                .then(() => this.updateLists())
                .then(() => {                    
                    this.prepareBookmarksPopup();
                    this.renderBookmarksNavigationList();
                })
                .catch(e => {
					console.error("Error loading bookmark lists: ", e);
				})
            },
            
            updateAddedStatus: function() {
                $('[data-bookmark-list-type="add"]').each( (index, button) => { 
                    let $button = $(button);
                    var pi = $button.attr( 'data-pi' );
                    var logid = $button.attr( 'data-logid' );
                    var page = $button.attr( 'data-page' );
                    
                    let added = this.contained(pi, page, logid);
                    if(_debug)console.log("set added to " + added + " for ", pi, page);
                    let $span = $button.find("span");
                    if(added) {
                        $button.addClass("added");
                        $span.tooltip('hide').attr("title", $span.attr("data-bookmark-list-title-added")).tooltip("_fixTitle");
                        $button.attr('aria-checked', true);
                    } else {
                        $button.removeClass("added");
                        $span.tooltip('hide').attr("title", $span.attr("data-bookmark-list-title-add")).tooltip("_fixTitle");
                        $button.attr('aria-checked', false);
                    }
                    
                } );
            },
            
            
            
            renderCounter: function() {
                var $counter = $(this.config.counter);
                if($counter.length > 0) {
                    this.listsUpdated.pipe(rxjs.operators.merge(rxjs.of(""))).subscribe((list) => {
                        let count = 0;
                        if(this.bookmarkLists) {
                            count = this.getBookmarksCount();
                        }
                        this.updateCounter(count);
                    })
                }
            },
            getBookmarksCount: function() {
                if(this.bookmarkLists) {                    
                    return this.bookmarkLists.flatMap(list => list.items).length;
                } else {
                    return 0;
                }
            },
            getBookmarkListsCount: function() {
                if(this.bookmarkLists) {                    
                    return this.bookmarkLists.length;
                } else {
                    return 0;
                }
            },
            updateCounter: function(count) {
                $(this.config.counter).html(count);
            },
            renderBookmarksNavigationList: function() {
                
                if(!this.config.userLoggedIn) {                    
                    
                    if(this.getBookmarksCount() > 0) {                        
                        this.renderSessionBookmarksDropdown();
                        this.renderCounter();
                    }
                    this.listsUpdated.subscribe(() => {
                        let sessionListMounted = $("bookmarklistsession").length > 0;
                        if(!sessionListMounted && this.getBookmarksCount() > 0) {
                            this.renderSessionBookmarksDropdown();
                            this.renderCounter();
                        } else if(sessionListMounted && this.getBookmarksCount() == 0){
                            this.hideSessionBookmarksDropdown();
                        }
                    });
                   
                } else {
                    this.renderUserBookmarksDropdown();                    
                }
                
            },
            renderUserBookmarksDropdown: function() {
                
                var $button = $('[data-bookmark-list-type="dropdown"]');
                if($button.length == 0) {
                    return;
                }
                
                var $bookmarkPosition = $('.login-navigation__bookmarks-list');
                var $dropdownUserLogin = $("<bookmarkListLoggedIn></bookmarkListLoggedIn>");
                $dropdownUserLogin.addClass("login-navigation__bookmarks-dropdown");
                
                $bookmarkPosition.after($dropdownUserLogin);
                riot.mount('bookmarkListLoggedIn', {
                    data: {        
                        pi: '',
                        logid: '',
                        page: ''
                    },
                    style: {
                        mainClass : "login-navigation__bookmarks"
                    },
                    bookmarkPosition: '.login-navigation__bookmarks-list',
                    bookmarks: this,
                });

                // handle closing dropdown
                let toggle = function() {
                    $dropdown.slideToggle( 'fast' );
                    $("body").off("click", toggle);
                }
                // bookmark list dropdown toggle 
                $button.on("click", (event) => {
                    if( (this.config.userLoggedIn && this.getBookmarkListsCount() > 0) || this.getBookmarksCount() > 0) {                        
                        $(event.currentTarget).next('.bookmark-navigation__dropdown').fadeToggle('fast');
                    }
                })
                $("body").on("click", (event) => {
                    let $target = $(event.target);
                    if( $target.closest('[data-bookmark-list-type="dropdown"]').length > 0 ) {
                        return; // click on bookmarks button. Don't close
                    }
                    if( $target.closest('bookmarkList').length > 0 ) {
                        return; // click on bookmark list. Don't close
                    }
                    if ($('.bookmark-navigation__dropdown').is(":visible")) {                        
                        $('.bookmark-navigation__dropdown').fadeOut( 'fast');
                    }
                })
                
                // Trigger bookmarks dropdown in login navigation dropdown
                $('body').on('click', '.login-navigation__bookmarks-trigger', function(){
                    event.preventDefault();
                    $('.login-navigation__bookmarks-small-list').slideToggle('fast');
                    $('.login-navigation__bookmarks-list').toggleClass('-opened');
                });
                   
//                $dropdown.on("click", (event) => event.stopPropagation());
            },
            calcDropDownPos: function(dropdown, button) {
              var dropDownRect = dropdown.getBoundingClientRect();

              if (dropDownRect.width === 0) {
                dropdown.style.transform = '';
                // change display prop to get BoundingClientRect values 
                dropdown.style.display = 'block';
                dropDownRect = dropdown.getBoundingClientRect();
                // change it back, so it will not appear visually
                dropdown.style.display = 'none';

                // if negativ value: dropdown overflows left
                if(dropDownRect.x < 0) {
                  return Math.floor(-dropDownRect.x) +'px';
                }
                // if positiv value: dropdown overflows right
                var overflowRight = (dropDownRect.x + dropDownRect.width) - document.documentElement.clientWidth;
                if(overflowRight > 0) {
                  return Math.ceil(-overflowRight) +'px';
                }
                return undefined;
              }
            },
            renderSessionBookmarksDropdown: function() {
                var $button = $('[data-bookmark-list-type="dropdown"]');
                if($button.length == 0) {
                    return;
                }
                $button.css("display", "flex");
                var buttonPosition = $button.offset();
                var buttonSize = {
                        width: $button.width(),
                        height: $button.height()
                }

                var $dropdown = $("<bookmarklistsession></bookmarklistsession>");
                $dropdown.addClass("bookmark-navigation__dropdown");
                $button.on("click", (event) => {

                    // make sure the dropdown does not overflow the viewport  
                    var transformVal = this.calcDropDownPos($dropdown[0]);

                    // show/hide dropdown + and set it's width 
                    $(event.currentTarget).next('.bookmark-navigation__dropdown')
                      .fadeToggle('fast')
                      .css("transform", "translate(" + transformVal + ")");
                })
                $button.after($dropdown);
                this.sessionBookmarkDropdown = riot.mount('bookmarklistsession', {
                    data: {        
                        pi: '',
                        logid: '',
                        page: ''
                    },
                    style: {
                        mainClass : "bookmark-navigation__dropdown-list"
                    },
                    button: '[data-bookmark-list-type="dropdown"]',
                    bookmarks: this,
                });
            },
            hideSessionBookmarksDropdown: function() {
                var $button = $('[data-bookmark-list-type="dropdown"]');
                if($button.length == 0) {
                    return;
                }
                $button.off("click");
                $button.css("display", "none");
                if(this.sessionBookmarkDropdown) {
                    this.sessionBookmarkDropdown.forEach(component => {
                        component.unmount();
                    })
                }
            },
            prepareBookmarksPopup: function() {
                
                // render bookmarks popup
                $( '[data-bookmark-list-type="add"]' ).off().on( 'click', function( event ) {
                                        
                    var currBtn = $( event.target ).closest('[data-bookmark-list-type="add"]');
                    var currPi = currBtn.attr( 'data-pi' );
                    var currLogid = currBtn.attr( 'data-logid' );
                    var currPage = currBtn.attr( 'data-page' );
                    var currType = currBtn.attr( 'data-type' );
                    
                    if(this.config.userLoggedIn) {                        
                        // render bookmarks popup with timeout to finish handling click event first.
                        setTimeout(() => this.renderBookmarksPopup( currPi, currLogid, currPage, currBtn ), 0);
                    } else if(this.contained(currPi, currPage, currLogid)){
                        this.removeFromBookmarkList(0, currPi, undefined, undefined, false )
                        .then( () => this.listsNeedUpdate.next());
                    } else {
                        this.addToBookmarkList(0, currPi, undefined, undefined, false )
                        .then( () => this.listsNeedUpdate.next());
                    }
                }.bind(this) );  
            },
            renderBookmarksPopup: function(pi, logid, page, button) {
                var $popup = $("<bookmarksPopup></bookmarksPopup>");
                $('body').append($popup);
                riot.mount('bookmarksPopup', {
                    data: {        
                        pi: pi,
                        logid: logid,
                        page: page
                    },
                    button: button,
                    bookmarks: this,
                });
            },

            getUrl: function(id) {
                let url = this.config.rest + "bookmarks/";
                if(id !== undefined) {
                    url += (id + "/");
                };
                return url;
            },
            
            getBookmarkLists: function() {
                return this.bookmarkLists;
            },

            loadBookmarkLists: function() {
                
                let url = this.getUrl();
                
                return fetch(url, {
                    cache: "no-cache",
                    method: "GET"
                 })
                .then( data => data.json())
                .then(json => {
                    if(!Array.isArray(json)) {
                        return [json];
                    } else {
                        return json
                    }
                })
                
            },
            
            updateLists: function() {
                return this.loadBookmarkLists()
                .then(lists => this.bookmarkLists = lists)
                .then(() => this.listsUpdated.next(this.bookmarkLists));
            },


            addToBookmarkList: function(listId, pi, page, logid) {
                
                let url = this.getUrl(listId) 
                
                let item = {
                    pi: pi,
                    logId: logid,
                    order: page
                }
                
                return fetch(url, {
                    method:"POST",
                    body: JSON.stringify(item),
                    headers: {'Content-Type': 'application/json'}
                })
                .then( res => res.json())
                .then(data => {
                    if(data.success === false) {
                        return Promise.reject("Failed to add bookmark: " + data.message);
                    }
                })
                .catch(error => {
                    console.log(error);
                })
                
            },

            removeFromBookmarkList: function(listId, pi, page, logid) {
                
                if(_debug) {
                    console.log("removeFromBookmarkList, listId", listId);
                    console.log("removeFromBookmarkList, pi", pi);
                    console.log("removeFromBookmarkList, page", page);
                    console.log("removeFromBookmarkList, logid", logid);
                }

                let list = this.getList(listId);
                let item = this.getItem(list, pi, page, logid);
                // console.log("got from list ", list, item);
                if(item) {
                    let url = this.getUrl(listId) + "items/" + item.id + "/";
                    // console.log("fetch ", url);
                    return fetch(url, {method:"DELETE"})
                    .then( res => res.json())
                    .then(data => {
                        if(data.success === false) {
                            return Promise.reject("Failed to remove bookmark: " + data.message);
                        } else {
                            
                        }
                    })
                    .catch(error => {
                        console.log(error);
                    })
                    
                } else {
                    return Promise.reject("Item not found");
                }
            },
            
            addBookmarkList: function(name) {
                
                let url = this.getUrl();
                let listToAdd = {
                        name: name
                }
                
             
                return fetch(url, {
                    method:"POST",
                    body: JSON.stringify(listToAdd),
                    headers: {'Content-Type': 'application/json'}
                 })
                .then( res => res.json())
                .then(data => {
                    if(data.success === false) {
                        return Promise.reject("Failed to create bookmarklist: " + data.message);
                    } else {
                        
                    }
                })
                .catch(error => {
                    console.log(error);
                })
                
            },
            
            removeBookmarkList: function(id) {
                
                let url = this.getUrl(id)
                
                return fetch(url, {method:"DELETE"})
                .then( res => res.json())
                .then(data => {
                    if(data.success === false) {
                        return Promise.reject("Failed to delete bookmarklist: " + data.message);
                    } else {
                        
                    }
                })
                .catch(error => {
                    console.log(error);
                })
                
            },
            
            getList: function(id) {
                if(this.config.userLoggedIn) {
                    return this.bookmarkLists.find(list => list.id == id);                    
                } else {
                    return this.bookmarkLists[0];
                }
            },

            getItem: function(list, pi, page, logid) {
                if(list) {    
                    return list.items.find(item => {
                        return item.pi == pi && (page == undefined  || page == item.order) && (logid == undefined || logid == item.logId);
                    })
                    
                }
                return undefined;
            },

            contained: function(pi, page, logid) {
                for(var list of this.bookmarkLists) {
                    if(this.inList(list, pi, page, logid)) {
                        return true;
                    }
                }
                return false;
            },
                    
            inList: function(list, pi, page, logid) {
                    for(var item of list.items) {
                        if(this.isTypeRecord() && item.pi == pi && item.order == null && item.logId == null) {
                            return true;
                        } else if(this.isTypePage() && item.pi == pi && page == item.order ) {
                            return true;
                        }
                    }
                return false;
            },
            
            getBookmarkListUrl(listId) {
                return this.config.root + "/user/bookmarks/show/" + listId;
            },

            isTypePage: function() {
                return this.typePage;
            },
            isTypeRecord: function() {
                return !this.typePage;
            },
            setTypePage: function() {
                this.typePage = true;
            },
            setTypeRecord: function() {
                this.typePage = false;
            }
            
    }
    viewer.bookmarks = _bookmarks;
    return viewer;
    
} )( viewerJS || {}, jQuery );


var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _this = null;
    var _currApiCall = '';
    var _json = {};
    var _popoverConfig = {};
    var _popoverContent = null;
    var _defaults = {
        appUrl: '',
        indexResourceUrl: '',
        calendarWrapperSelector: '.search-calendar__months',
        popoverTriggerSelector: '[data-popover-trigger="calendar-po-trigger"]',
        popoverTitle: 'Bitte übergeben Sie den Titel des Werks',
    };
    
    viewer.calendarPopover = {
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.calendarPopover.init' );
                console.log( '##############################' );
                console.log( 'viewer.calendarPopover.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // TODO: Fehlermeldung in der Konsole beseitigen, wenn man auf den Tag ein
            // zweites Mal klickt.
            
            // show popover for current day
            $( _defaults.popoverTriggerSelector ).on( 'click', function() {
                _this = $( this );

                let query = _this.attr("data-query");
                let fields = _this.attr("data-fields").split(",");
                let requestBody = JSON.stringify({
                        "query": query,
                        "resultFields": fields
                    })
                
                fetch(_defaults.indexResourceUrl, {
                    method: "POST",
                    body: requestBody,
                    headers: {
                        "Content-Type": "application/json"
                    }
                })
                .then(response => response.json())
                .then(response => {
                    _popoverContent = _getPopoverContent( response, _defaults );
                    _popoverConfig = {
                        placement: 'bottom',
                        title: _defaults.popoverTitle,
                        content: _popoverContent,
                        viewport: {
                            selector: _defaults.calendarWrapperSelector
                        },
                        html: true
                    };
                    
                    $( _defaults.popoverTriggerSelector ).popover( 'dispose' );
                    _this.popover( _popoverConfig );
                    _this.popover( 'show' );
                })
                .catch(error => {
                	console.log("Error calling " + _defaults.indexResourceUrl + " :" + error);
                });

            } );
            
            // remove all popovers by clicking on body
            $( 'body' ).on( 'click', function( event ) {
                if ( $( event.target ).closest( _defaults.popoverTriggerSelector ).length ) {
                    return;
                }
                else {
                    $( _defaults.popoverTriggerSelector ).popover( 'dispose' );
                }
            } );
        }
    };
    
    /**
     * Method to render the popover content.
     * 
     * @method _getPopoverContent
     * @param {Object} data A JSON-Object which contains the necessary data.
     * @param {Object} config The config object of the module.
     * @returns {String} The HTML-String of the popover content.
     */
    function _getPopoverContent( data, config ) {
        if ( _debug ) {
            console.log( '---------- _getPopoverContent() ----------' );
            console.log( '_getPopoverContent: data = ', data );
            console.log( '_getPopoverContent: config = ', config );
        }
        
        var workList = '';
        var workListLink = '';
        
        workList += '<ul class="list">';
        if(data && data.docs) {
	        data.docs.forEach(item => {
	            workListLink = config.appUrl + 'image/' + item.PI_TOPSTRUCT + '/' + item.THUMBPAGENO + '/' + item.LOGID + '/';
	            
	            workList += '<li>';
	            workList += '<a href="' + workListLink + '">';
	            workList += item.LABEL;
	            workList += '</a>';
	            workList += '</li>';
	        })
        } else {
        	console.error("Unexpected json data: ", data);
        }
        
        workList += '</ul>';
        
        return workList;
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _parsedFontSize = 0;
    var _currFontSize = '';
    var _defaults = {
        fontDownBtn: '',
        fontUpBtn: '',
        maxFontSize: 18,
        minFontSize: 12,
        baseFontSize: '14px'
    };
    
    viewer.changeFontSize = {
        /**
         * Method which initializes the font size switcher.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.fontDownBtn The ID/Class of the font degrade button.
         * @param {String} config.fontUpBtn The ID/Class of the font upgrade button.
         * @param {String} config.maxFontSize The maximum font size the document should
         * scale up.
         * @param {String} config.minFontSize The minimum font size the document should
         * scale down.
         * @param {String} config.baseFontSize The base font size of the HTML-Element.
         * @example
         * 
         * <pre>
         * var changeFontSizeConfig = {
         *     fontDownBtn: '#fontSizeDown',
         *     fontUpBtn: '#fontSizeUp',
         *     maxFontSize: 18,
         *     minFontSize: 14
         * };
         * 
         * viewerJS.changeFontSize.init( changeFontSizeConfig );
         * </pre>
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.changeFontSize.init' );
                console.log( '##############################' );
                console.log( 'viewer.changeFontSize.init: config - ' );
                console.log( config );
            }
            
            $.extend( true, _defaults, config );
            
            if ( viewer.localStoragePossible ) {
                // set current font-size
                _setFontSize();
                
                // set button state
                _setButtonState();
                
                $( _defaults.fontDownBtn ).on( 'click', function() {
                    // set current font-size
                    _currFontSize = $( 'html' ).css( 'font-size' );
                    
                    // save font-size
                    _saveFontSize( _currFontSize );
                    
                    // parse number of font-size
                    _parsedFontSize = _parseFontSize( _currFontSize );
                    
                    // degrade font-size
                    _degradeFontSize( _parsedFontSize );
                } );
                
                $( _defaults.fontUpBtn ).on( 'click', function() {
                    // set current font-size
                    _currFontSize = $( 'html' ).css( 'font-size' );
                    
                    // save font-size
                    _saveFontSize( _currFontSize );
                    
                    // parse number of font-size
                    _parsedFontSize = _parseFontSize( _currFontSize );
                    
                    // raise font-size
                    _raiseFontSize( _parsedFontSize );
                } );
            }
        }
    };
    
    /**
     * Method to degrade the page font-size.
     * 
     * @method _degradeFontSize
     * @param {Number} current The current font-size of the HTML-Element.
     */
    function _degradeFontSize( current ) {
        if ( _debug ) {
            console.log( '---------- _degradeFontSize() ----------' );
            console.log( '_degradeFontSize: current = ', current );
        }
        
        var size = current;
        size--;
        
        if ( size >= _defaults.minFontSize ) {
            $( _defaults.fontDownBtn ).prop( 'disabled', false );
            $( _defaults.fontUpBtn ).prop( 'disabled', false );
            $( 'html' ).css( 'font-size', size + 'px' );
            
            // save font-size
            _saveFontSize( size + 'px' );
        }
        else {
            $( _defaults.fontDownBtn ).prop( 'disabled', true );
            $( _defaults.fontUpBtn ).prop( 'disabled', false );
        }
    }
    
    /**
     * Method to raise the page font-size.
     * 
     * @method _raiseFontSize
     * @param {Number} current The current font-size of the HTML-Element.
     */
    function _raiseFontSize( current ) {
        if ( _debug ) {
            console.log( '---------- _raiseFontSize() ----------' );
            console.log( '_raiseFontSize: current = ', current );
        }
        
        var size = current;
        size++;
        
        if ( size <= _defaults.maxFontSize ) {
            $( _defaults.fontDownBtn ).prop( 'disabled', false );
            $( _defaults.fontUpBtn ).prop( 'disabled', false );
            $( 'html' ).css( 'font-size', size + 'px' );
            
            // save font-size
            _saveFontSize( size + 'px' );
        }
        else {
            $( _defaults.fontDownBtn ).prop( 'disabled', false );
            $( _defaults.fontUpBtn ).prop( 'disabled', true );
        }
    }
    
    /**
     * Method which parses a given pixel value to a number and returns it.
     * 
     * @method _parseFontSize
     * @param {String} string The string to parse.
     */
    function _parseFontSize( string ) {
        if ( _debug ) {
            console.log( '---------- _parseFontSize() ----------' );
            console.log( '_parseFontSize: string = ', string );
        }
        
        return parseInt( string.replace( 'px' ) );
    }
    
    /**
     * Method to save the current font-size to local storage as a string.
     * 
     * @method _saveFontSize
     * @param {String} size The String to save in local storage.
     */
    function _saveFontSize( size ) {
        if ( _debug ) {
            console.log( '---------- _saveFontSize() ----------' );
            console.log( '_parseFontSize: size = ', size );
        }
        
        sessionStorage.setItem( 'currentFontSize', size );
    }
    
    /**
     * Method to set the current font-size from local storage to the HTML-Element.
     * 
     * @method _setFontSize
     */
    function _setFontSize() {
        if ( _debug ) {
            console.log( '---------- _setFontSize() ----------' );
        }
        var fontSize = sessionStorage.getItem( 'currentFontSize' );
        
        if ( fontSize === null || fontSize === '' ) {
            sessionStorage.setItem( 'currentFontSize', _defaults.baseFontSize );
        }
        else {
            $( 'html' ).css( 'font-size', fontSize );
        }
        
    }
    
    /**
     * Method to set the state of the font-size change buttons.
     * 
     * @method _setButtonState
     */
    function _setButtonState() {
        if ( _debug ) {
            console.log( '---------- _setButtonState() ----------' );
        }
        var fontSize = sessionStorage.getItem( 'currentFontSize' );
        var newFontSize = _parseFontSize( fontSize );
        
        if ( newFontSize === _defaults.minFontSize ) {
            $( _defaults.fontDownBtn ).prop( 'disabled', true );
        }
        
        if ( newFontSize === _defaults.maxFontSize ) {
            $( _defaults.fontUpBtn ).prop( 'disabled', true );
        }
        
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _firstHandlePos;
    var _lastHandlePos;
    var _defaults = {
    	yearList: [],            		
        startValue: 0,
        endValue: 0,
        currentMinRangeValue: '',
        currentMaxRangeValue: '',
    };
    
    viewer.chronoSlider = {
    	/**
    	 * Method to initialize the chronology slider.
    	 * 
    	 * @method init
    	 * @param {Object} config An config object which overwrites the defaults.
    	 * @param {Array} config.yearList An Array of all possible years.
    	 * @param {Number} config.startValue The value of the first year.
    	 * @param {Number} config.endValue The value of the last year.
    	 * @param {String} config.currentMinRangeValue The lower range value.
    	 * @param {String} config.currentMaxRangeValue The higher range value.
    	 */
    	init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.chronoSlider.init' );
                console.log( '##############################' );
                console.log( 'viewer.chronoSlider.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            let rtl = $( "#chronoSlider" ).closest('[dir="rtl"]').length > 0;
            
            var sliderHandle1 = $('.ui-slider-handle').first();
            var sliderHandle2 = $('.ui-slider-handle').last();
            
            $( "#chronoSlider" ).slider({
        		range: true,
        		isRTL: rtl,
				min: 0,
        		max: _defaults.yearList.length - 1,
				values: [ _defaults.yearList.indexOf( _defaults.currentMinRangeValue ), _defaults.yearList.indexOf( _defaults.currentMaxRangeValue) ],
        		slide: function( event, ui ) {
        			
        			$( '.chronology-slider-start input' ).val( _defaults.yearList[ ui.values[ 0 ] ] );
        			$( '.chronology-slider-end input' ).val( _defaults.yearList[ ui.values[ 1 ] ] );

        			if (rtl) {
        				// RTL
        				// method used here for handling the RTL position is not pixel-perfect
						// set handler position
						if ( ui.values[ 0 ] == ui.values[ 1 ] ) {
			        		$( "#chronoSlider .ui-slider-handle" ).first().css('margin-right', '0px');
			        		$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', '-10px');
			        		console.log('uebereinander');
			        	}	else {
								$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', '0px');
							}

        				$( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', '-10px');


        				// NOT WORKING YET
//        				$( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', 1 * $( "#chronoSlider .ui-slider-handle" ).last().width() * ($( "#chronoSlider" ).slider( "values", 1 ) / $( "#chronoSlider" ).slider('option', 'max')));
//        				$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', 1 * $( "#chronoSlider .ui-slider-handle" ).first().width() * ($( "#chronoSlider" ).slider( "values", 0 ) / $( "#chronoSlider" ).slider('option', 'max')));
        			}
        			else {
        				// LTR
        				// working JS calculation method for handling slider handle positions (jQuery slider)
	        			// set handler position
        				$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', -1 * $( "#chronoSlider .ui-slider-handle" ).last().width() * ($( "#chronoSlider" ).slider( "values", 1 ) / $( "#chronoSlider" ).slider('option', 'max')));
        				$( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', -1 * $( "#chronoSlider .ui-slider-handle" ).first().width() * ($( "#chronoSlider" ).slider( "values", 0 ) / $( "#chronoSlider" ).slider('option', 'max')));
        			}

        		},
        		change: function( event, ui ) {
        			var startDate = parseInt( $( '.chronology-slider-start input' ).val() );
        			var endDate = parseInt( $( '.chronology-slider-end input' ).val() );
        			
        			startDate =  _defaults.yearList[ui.values[0]];
        			endDate =  _defaults.yearList[ui.values[1]];
//        			console.log("move to ", startDate, endDate);
        			
        			if(endDate >= startDate) {        			    
        			    // show loader
        			    $( '.chronology-slider-action-loader' ).addClass( 'active' );
        			    
        			    // set query to hidden input
        			    let value = '[' + startDate + ' TO ' + endDate + ']' ;
        			    $( '[id*="chronologySliderInput"]' ).val(value);
//        			   console.log("set slider value ", value)
        			    // submit form
        			    $( '[id*="chronologySliderSet' ).click();
        			}
        		},
        	});
            $( '.chronology-slider-start input' ).on("change", (event) => {
//                console.log("change event ", event);
                let value = parseInt(event.target.value);
                if(!isNaN(value)) {                    
                    let yearIndex = _getClosestYearIndexAbove(value, _defaults.yearList);
//                    console.log("changed start ", value, yearIndex);
                    $( "#chronoSlider" ).slider( "values", 0, yearIndex );
                }
            })
            $( '.chronology-slider-end input' ).on("change", (event) => {
                let value = parseInt(event.target.value);
                if(!isNaN(value)) {                    
                    let yearIndex = _getClosestYearIndexBelow(value, _defaults.yearList);
//                    console.log("changed end ", value, yearIndex);
                    $( "#chronoSlider" ).slider( "values", 1, yearIndex );
                }
            })
            
            // set handler position
        	_firstHandlePos = parseInt( $( "#chronoSlider .ui-slider-handle:first" ).css('left') );
        	_lastHandlePos = parseInt( $( "#chronoSlider .ui-slider-handle:last" ).css('left') );
        	
			if (rtl) {
				
	        	$( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', '-10px');
	        	$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', '0px');
	        	
	        	if ( _firstHandlePos == _lastHandlePos ) {
	        		$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', '-10px');	
	        	}
	        	
	        	// NOT PERFECTLY WORKING YET
	        	// $( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', 1 * $( "#chronoSlider .ui-slider-handle" ).last().width() * ($( "#chronoSlider" ).slider( "values", 1 ) / $( "#chronoSlider" ).slider('option', 'max')));
				// $( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', 1 * $( "#chronoSlider .ui-slider-handle" ).first().width() * ($( "#chronoSlider" ).slider( "values", 0 ) / $( "#chronoSlider" ).slider('option', 'max')));
			}
			else {
				$( "#chronoSlider .ui-slider-handle" ).last().css('margin-left', -1 * $( "#chronoSlider .ui-slider-handle" ).last().width() * ($( "#chronoSlider" ).slider( "values", 1 ) / $( "#chronoSlider" ).slider('option', 'max')));
				$( "#chronoSlider .ui-slider-handle" ).first().css('margin-left', -1 * $( "#chronoSlider .ui-slider-handle" ).first().width() * ($( "#chronoSlider" ).slider( "values", 0 ) / $( "#chronoSlider" ).slider('option', 'max')));
			}

        	// reset slider
        	if ( _defaults.startValue > _defaults.yearList[ 0 ] || _defaults.endValue < _defaults.yearList[ _defaults.yearList.length - 1 ] ) {
        		$( '.chronology-slider-action-reset' ).addClass( 'active' );
        		$( '[data-reset="chrono-slider"]' ).on( 'click', function() {
            		_resetChronoSlider( _defaults.yearList );
            	} );
        	} 
        }
    };
    
    function _getClosestYearIndexAbove(value, years) {
        for (var i = 0; i < years.length; i++) {
            let year = years[i];
            if(year >= value) {
                return i;
            }
        }
        return years.length-1;
    }
    
    function _getClosestYearIndexBelow(value, years) {
        for (var i = years.length; i > -1 ; i--) {
            let year = years[i];
            if(year <= value) {
                return i;
            }
        }
        return 0;
    }
    
    /**
     * Method to reset the chronology slider.
     * 
     * @method _resetChronoSlider
     * @param {Array} years An Array of all possible years.
     * */
    function _resetChronoSlider( years ) {
    	if ( _debug ) {
            console.log( '---------- _resetChronoSlider() ----------' );
            console.log( '_resetChronoSlider: years = ', years );
        }
    	
		var $slider = $( '#chronoSlider' );
		
		$slider.slider( {
			min: 0,
			max: years.length - 1
		} );
		
//		$( '[id*="chronologySliderInput"]' ).val( '[' + years[ 0 ] + ' TO ' + years[years.length - 1] + ']' );
//		$( '[id*="chronologySliderForm"] input[type="submit"]' ).click();
		$( '[id*="chronologySliderReset"]' ).click();
	}  

    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = (function(viewer) {
	'use strict';

	const _defaultSelector = "[data-copy-value]";

	viewer.clipboard = {
		init: function(selector, dataTarget) {

			/* SYNTAX TO DEFINE NON STANDARD TARGET SELECTOR/VALUE:
				viewerJS.clipboard.init("[data-copy-special-selector]", "data-copy-special-value");
				first the data attribute as selector for the tooltip + then the data attribute for the value
			*/

			if (!selector) {
				var tooltipValueSelector = _defaultSelector;
			}
			else {
				var tooltipValueSelector = selector;
			}

			// ACTIVATE TOOLTIP ONLY IF DATA COPY VALUE SELECTORS AVAILABLE
			$(tooltipValueSelector)
				  // .attr("tabindex", 0)
				.tooltip({ trigger: "manual" })
	
				.mouseenter(event => {
					$('[data-toggle="tooltip"]').tooltip("hide");
					$(event.currentTarget).tooltip("show");
					$(".tooltip").on("mouseleave", function() {
						$(event.currentTarget).tooltip("hide");
					});
				})
				
				.mouseleave(event => {
					setTimeout(() => {
						if (!$(".tooltip:hover").length) $(event.currentTarget).tooltip("hide");
					}, 100);
				})
				
				// show tooltips on (keyboard) focus
				.focus(event => {
					$(event.currentTarget).tooltip("show");
				})
				.blur(event => {
					$(event.currentTarget).tooltip("hide");
				});
				
				
				/* Listen for the "escape key" so tool tips can easily be hidden */
				$("body").keydown(event => {
				  if (event.keyCode === 27) {
				    $(tooltipValueSelector).tooltip("hide");
				  }
				});

			// COPY BUTTON VAR
			var copyClipboardButton = $(tooltipValueSelector);

			$(copyClipboardButton).click(function() {

				var thisCopyButton = $(this);

				// GET VALUE OF DATA ATTRIBUTE COPY VALUE
				// define dataTarget to get other data attribute value than data-copy-value
				if (!dataTarget) {
					var copyValue = $(this).data('copy-value');
					// console.log('datatarget is OFF ' + dataTarget);
				}
				else {
					var copyValue = $(this).attr(dataTarget);
					// console.log('datatarget is ON ' + dataTarget);
					// console.log('value of special: ' + copyValue);
				}

				// var copyValue = $(this).data('copy-value');
				// console.log(copyValue);

				// CREATE TEMPORARY TEXTAREA TO COPY VALUE INTO CLIPBOARD
				var $temp = $("<textarea />");
				$("body").append($temp);
				$temp.val(copyValue).select();
				document.execCommand("copy");
				$temp.remove();

				// CHANGE TOOLTIP TO COPY DONE MESSAGE
				var copyThisMessage = $(thisCopyButton).data('original-title');

				// IF NO COPY DONE MSG FOUND JUST USE STANDARD TEXT
				if (!$(this).data('copy-done-msg')) {
					// TO DO: TRANSLATE MSG KEY
					var copyDoneMessage = 'Copied to clipboard';
				}
				else {
					var copyDoneMessage = $(thisCopyButton).data('copy-done-msg');
				}

				$(thisCopyButton).tooltip('hide');
				$(thisCopyButton).tooltip('dispose');
				$(thisCopyButton).tooltip({ trigger: "manual", placement: "top", title: 'Copy' });
				$(thisCopyButton).attr('data-original-title', copyDoneMessage);
				$(thisCopyButton).tooltip('show');

				// KEEP COPIED SUCCESS MSG FOR 2 SECONDS THEN REENABLE NORMAL TOOLTIP 
				setTimeout(function() {

					$(thisCopyButton).tooltip('hide');
					$(thisCopyButton).on('hidden.bs.tooltip', function() {
						$(thisCopyButton).tooltip('dispose');
						$(thisCopyButton).attr('data-original-title', copyThisMessage);
						$(thisCopyButton).tooltip({ trigger: "hover", placement: "top", title: copyThisMessage });
					})

				}, 2000);
				
				$(this).focus();

			});

		}
	}

	return viewer;

})(viewerJS || {}, jQuery);

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _defaults = {
    	lastEditedHash: '',
    	active : true,
    };
    
    viewer.cookieBanner = {
        bannerStatus : true,
   		bannerHash : '',
        /**
         * Method to initialize the cookie banner.
         * 
         * @method init
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.cookieBanner.init' );
                console.log( '##############################' );
                console.log( 'viewer.cookieBanner.init: config - ', config );
            }
            
            this.config = $.extend(true, {}, _defaults, config );
            if(_debug)console.log("init cookie banner with config", this.config);
            if(this.config.active) {
            
		        // set global variables
		        this.bannerStatus = this.getStoredBannerStatus();
		        this.bannerHash = this.getStoredLastEditedHash();
		        if(_debug)console.log("banner status: ", this.bannerStatus, "; hash: ", this.bannerHash);
		        // set last edit hash
		        if ( this.bannerHash === undefined) {
		        	this.storeLastEditedHash(this.config.lastEditedHash );
		        	this.bannerHash = this.getStoredLastEditedHash();
		        }
				if(_debug)console.log("banner status: ", this.bannerStatus, "; hash: ", this.bannerHash);
				
            	// get/set banner status
            	if ( this.bannerStatus === undefined ) {
            		if(_debug)console.log("banner status unset");
            		this.storeBannerStatus( true );
            		this.bannerStatus = this.getStoredBannerStatus();
            		$( '#cookieBanner' ).show();
            		this.initHideBanner();
            	} else {
            		// check last edited hash
            		if ( this.config.lastEditedHash === this.bannerHash ) {
            			if(_debug)console.log("last edited hash equals stored value. Banner status = ", this.bannerStatus);
            			// check banner status
            			if ( this.bannerStatus ) {
            				$( '#cookieBanner' ).show();
            				this.initHideBanner();
            			} else {
            				$( '#cookieBanner' ).hide();  
            				this.startPiwikTracking();          	
            			}            			
            		} else {
            			this.storeBannerStatus( true );
            			$( '#cookieBanner' ).show();
        				this.initHideBanner();
            		}
            		
            	}            	
            } else {
            	$( '#cookieBanner' ).hide();
            	this.startPiwikTracking(true);
            }

			// Only for style
			$(".cookie-banner__accept-button").hover(function() {
				$(".cookie-banner__icon-wrapper").addClass("-jumpAnimation");
			});
        },
        startPiwikTracking(force) {
        	if(typeof startPiwikTracking !== "undefined") {
        		if(this.getStoredCookiesAccepted() || force) {
	        		startPiwikTracking();
        		}
        	}
        },
        getStoredLastEditedHash() {
        	let string = localStorage.getItem( 'cookieBannerHash' );
        	if(string) {
        		return parseInt(string);
        	} else {
        		return undefined;
        	}
        },
        getStoredBannerStatus() {
        	let string = localStorage.getItem( 'cookieBannerStatus' );
        	if(!string) {
        		return undefined;
        	} else {
        		return string.toLowerCase() == "true";
			}        	
        },
        getStoredCookiesAccepted() {
        	let string = localStorage.getItem( 'cookiesAccepted' );
        	if(!string) {
        		return undefined;
        	} else {
        		return string.toLowerCase() == "true";
			}        	
        },
        storeLastEditedHash(hash) {
        	localStorage.setItem( 'cookieBannerHash', String(hash) );
        },
        storeBannerStatus(status) {
        	localStorage.setItem( 'cookieBannerStatus', String(status) );
        },
        storeCookiesAccepted(accepted) {
        	localStorage.setItem( 'cookiesAccepted', String(accepted) );
        },
	    initHideBanner() {
	    	if ( _debug ) {
	    		console.log( 'EXECUTE: _initHideBanner' );
	    	}
	    	
	    	$( '[data-set="cookie-banner-accept"]' ).off().on( 'click', () => this.hideBanner(true) );
	    	$( '[data-set="cookie-banner-decline"]' ).off().on( 'click', () => this.hideBanner(false) );
	    },
	    hideBanner(acceptCookies) {
	   	 	if ( _debug ) {
	    		console.log( 'EXECUTE: _hideBanner', acceptCookies );
	    	}
	    	$( '.cookie-banner__info' ).slideUp( function() {
				$( '#cookieBanner' ).fadeOut( 'fast' );
				this.storeBannerStatus(false);
				this.storeLastEditedHash(this.config.lastEditedHash);
				this.storeCookiesAccepted(acceptCookies);
				this.config.bannerStatus = this.getStoredBannerStatus();
				this.config.bannerHash = this.getStoredLastEditedHash();
				this.startPiwikTracking();
				if(_debug)console.log("accepted cookie banner ",acceptCookies,". Set banner status to ", this.config.bannerStatus, ", hash to ", this.config.bannerHash);
			}.bind(this) ); 
	    }
	    
    };
    

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _dataTablePaginator = null;
    var _txtField1 = null;
    var _txtField2 = null;
    var _totalCount = null;
    var _reloadBtn = null;
    var _defaults = {
        dataTablePaginator: '',
        txtField1: '',
        txtField2: '',
        totalCount: '',
        reloadBtn: '',
    };
    
    viewer.dataTable = {
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.dataTable.init' );
                console.log( '##############################' );
                console.log( 'viewer.dataTable.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            viewer.dataTable.paginator.init();
            
            if ( $( '.column-filter-wrapper' ).length > 0 ) {
                viewer.dataTable.filter.init();
            }
        },
        /**
         * Pagination
         */
        paginator: {
            setupAjax: false,
            init: function() {
                if ( _debug ) {
                    console.log( '---------- dataTable.paginator.init() ----------' );
                }
                
                _dataTablePaginator = $( _defaults.dataTablePaginator );
                _txtField1 = $( _defaults.txtField1 );
                _txtField2 = $( _defaults.txtField2 );
                _totalCount = $( _defaults.totalCount );
                _reloadBtn = $( _defaults.reloadBtn );
                
                _txtField1.on( 'click', function() {
                    $( this ).hide();
                    viewer.dataTable.paginator.inputFieldHandler();
                } );
                
                _totalCount.on( 'click', function() {
                    _txtField1.hide();
                    viewer.dataTable.paginator.inputFieldHandler();
                } );
                
                /*
                 * AJAX Eventlistener
                 */
                if ( !this.setupAjax ) {
                    jsf.ajax.addOnEvent( function( data ) {
                        var ajaxstatus = data.status;
                        
                        if ( _defaults.dataTablePaginator.length > 0 ) {
                            switch ( ajaxstatus ) {
                                case "begin":
                                    if ( _txtField1 !== null && _txtField2 !== null ) {
                                        _txtField1.off();
                                        _txtField2.off();
                                    }
                                    break;
                                case "complete":
                                    break;
                                case "success":
                                    viewer.dataTable.paginator.init();
                                    break;
                            }
                        }
                    } );
                    this.setupAjax = true;
                }
            },
            inputFieldHandler: function() {
                if ( _debug ) {
                    console.log( '---------- dataTable.paginator.inputFieldHandler() ----------' );
                }
                
                _txtField2.show().find( 'input' ).focus().select();
                
                _txtField2.find( 'input' ).on( 'blur', function() {
                    $( this ).hide();
                    _txtField1.show();
                    _reloadBtn.click();
                } );
                
                _txtField2.find( 'input' ).on( 'keypress', function( event ) {
                    if ( event.keyCode == 13 ) {
                        _reloadBtn.click();
                    }
                    else {
                        return;
                    }
                } );
            },
        },
        /**
         * Filter
         */
        filter: {
            setupAjax: false,
            init: function() {
                if ( _debug ) {
                    console.log( '---------- dataTable.filter.init() ----------' );
                }
                
                $( '#adminAllUserForm' ).on( 'submit', function( event ) {
                    event.preventDefault();
                    
                    $( '.column-filter-wrapper' ).find( '.btn-filter' ).click();
                } );
                
                /*
                 * AJAX Eventlistener
                 */
                if ( !this.setupAjax ) {
                    jsf.ajax.addOnEvent( function( data ) {
                        var ajaxstatus = data.status;
                        
                        if ( _defaults.dataTablePaginator.length > 0 ) {
                            switch ( ajaxstatus ) {
                                case "begin":
                                    break;
                                case "complete":
                                    break;
                                case "success":
                                    viewer.dataTable.filter.init();
                                    break;
                            }
                        }
                    } );
                    this.setupAjax = true;
                }
            },
        },
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _promise = null;
    var _defaults = {
        path: null,
        dataSortOrder: null,
        dataCount: null,
        dataEncoding: null,
        feedBox: null,
        monthNames: [ '', 'Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember' ]
    };
    
    viewer.dateSortedFeed = {
        /**
         * Method which initializes the date sorted RSS-Feed.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.path The rootpath of the application.
         * @param {Object} config.feedBox An jQuery object of the wrapper DIV.
         * @example
         * 
         * <pre>
         * var dateSortedFeedConfig = {
         *     path: '#{request.contextPath}',
         *     feedBox: $( '#dateSortedFeed' )
         * };
         * 
         * viewerJS.dateSortedFeed.setDataSortOrder( '#{cc.attrs.sorting}' );
         * viewerJS.dateSortedFeed.setDataCount( '#{cc.attrs.count}' );
         * viewerJS.dateSortedFeed.setDataEncoding( '#{cc.attrs.encoding}' );
         * viewerJS.dateSortedFeed.init( dateSortedFeedConfig );
         * </pre>
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.dateSortedFeed.init' );
                console.log( '##############################' );
                console.log( 'viewer.dateSortedFeed.init: feedBoxObj - ' + feedBoxObj );
                console.log( 'viewer.dateSortedFeed.init: path - ' + path );
            }
            
            $.extend( true, _defaults, config );
            
            var dataURL = _defaults.path;
            dataURL += '/api?action=query&q=PI:*&jsonFormat=datecentric&sortField=DATECREATED';
            dataURL += '&sortOrder=';
            dataURL += _defaults.dataSortOrder;
            dataURL += '&count=';
            dataURL += _defaults.dataCount;
            dataURL += '&encoding=';
            dataURL += _defaults.dataEncoding;
            
            if ( _debug ) {
                console.log( 'viewer.dateSortedFeed.init: dataURL - ' + dataURL );
            }
            
            // checking for feedbox element and render feed
            if ( _defaults.feedBox ) {
                _promise = viewer.helper.getRemoteData( dataURL );
                
                _promise.then( function( data ) {
                    _renderFeed( data );
                } ).then( null, function() {
                    console.error( 'ERROR: viewer.dateSortedFeed.init - ', error );
                } );
            }
            else {
                return;
            }
        },
        /**
         * Returns the sorting order of the feed.
         * 
         * @method getDataSortOrder
         * @returns {String} The sorting order.
         * 
         */
        getDataSortOrder: function() {
            return _defaults.dataSortOrder;
        },
        /**
         * Sets the sorting order of the feed.
         * 
         * @method getDataSortOrder
         * @param {String} str The sorting order (asc/desc)
         * 
         */
        setDataSortOrder: function( str ) {
            _defaults.dataSortOrder = str;
        },
        /**
         * Returns the number of entries from the feed.
         * 
         * @method getDataSortOrder
         * @returns {String} The number of entries.
         * 
         */
        getDataCount: function() {
            return _defaults.dataCount;
        },
        /**
         * Sets the number of entries from the feed.
         * 
         * @method setDataCount
         * @param {String} The number of entries.
         * 
         */
        setDataCount: function( num ) {
            _defaults.dataCount = num;
        },
        /**
         * Returns the type of encoding.
         * 
         * @method getDataEncoding
         * @returns {String} The type of encoding.
         * 
         */
        getDataEncoding: function() {
            return _defaults.dataEncoding;
        },
        /**
         * Sets the type of encoding.
         * 
         * @method setDataEncoding
         * @param {String} The type of encoding.
         * 
         */
        setDataEncoding: function( str ) {
            _defaults.dataEncoding = str;
        }
    };
    
    /**
     * Renders the feed and appends it to the wrapper.
     * 
     * @method _renderFeed
     * @param {Object} data An JSON object of the feed data.
     * 
     */
    function _renderFeed( data ) {
        var feed = '';
        $.each( data, function( i, j ) {
            feed += '<h3>' + _dateConverter( j.date ) + '</h3>';
            $.each( j, function( m, n ) {
                if ( n.title ) {
                    for ( var x = 0; x <= n.title.length; x++ ) {
                        if ( n.title[ x ] !== undefined ) {
                            feed += '<div class="sorted-feed-title"><a href="';
                            feed += n.url;
                            feed += '" title="';
                            feed += n.title[ x ];
                            feed += '">';
                            feed += n.title[ x ];
                            feed += '</a></div>';
                        }
                    }
                }
            } );
        } );
        
        _defaults.feedBox.append( feed );
    }
    
    /**
     * Converts a date to this form: 16. November 2015
     * 
     * @method _dateConverter
     * @param {String} str The date to convert.
     * @returns {String} The new formated date.
     * 
     */
    function _dateConverter( str ) {
        var strArr = str.split( '-' );
        var monthIdx = parseInt( strArr[ 1 ] );
        var newDate = strArr[ 2 ] + '. ' + _defaults.monthNames[ monthIdx ] + ' ' + strArr[ 0 ];
        
        return newDate;
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _defaults = {
    	lastEdited: '',
    	active : false,
    	storage : 'local',
    	daysToLive : '14',
    };
    
    viewer.disclaimerModal = {
        /**
         * Method to initialize the cookie banner.
         * 
         * @method init
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.disclaimerModal.init' );
                console.log( '##############################' );
                console.log( 'viewer.disclaimerModal.init: config - ', config );
            }
            
            this.config = $.extend(true, {}, _defaults, config );
            if(_debug)console.log("init disclaimer modal with config", this.config);
            if(this.config.active) {
            	this.settings = this.getStoredSettings(this.config.storage);
            	if(this.settings.lastAccepted) {
            		let lastEditedDate = new Date(this.config.lastEdited);
            		let lastAcceptedDate = new Date(this.settings.lastAccepted);
            		if(_debug)console.log("disclaimer last edited ", lastEditedDate);
            		if(_debug)console.log("disclaimer last accepted ", lastAcceptedDate);
            		if(_debug)console.log("disclaimer valid for session ", this.settings.sessionId, this.config.sessionId);
            		if(this.config.storage.toLowerCase() === 'session' && this.config.sessionId !== this.settings.sessionId) { //disclaimer valid for session and stored session id differs from current session
            			this.showDisclaimer();
            		} else if(this.settings.lastAccepted < this.config.lastEdited) { //accepted disclaimer before last disclaimer update --> need to accept again
            			this.showDisclaimer();
            		} else { //check if daysToLive days have passed since last edited
            			let timeoutDate = new Date(this.settings.lastAccepted);
            			timeoutDate.setDate(timeoutDate.getDate() + this.config.daysToLive);
            			if(_debug)console.log("disclaimer timeout date", timeoutDate, timeoutDate.getTime(), Date.now());
            			if(timeoutDate.getTime() < Date.now()) { //now is later than the timeout day of the disclaimer --> need to accept again
            				this.showDisclaimer();
            			}
            		}
            	} else {	//either the disclaimer has never been shown in this browser or within this session
            			this.showDisclaimer();
            	}
			}
        },
        showDisclaimer() {
        	Swal.fire({
        		html : this.config.disclaimerText,
        		allowOutsideClick: false,
				scrollbarPadding: false,
        		customClass: {
        			popup: 'disclaimer-modal__alert',
			    	confirmButton: 'btn btn--full'
			    },
				buttonsStyling: false,
        	})
        	.then(() => {
        		// console.log("accepted disclaimer");
        		this.setStoredSettings({lastAccepted : Date.now(), sessionId: this.config.sessionId}, this.config.storage);        		
        	});
        	
        },
        getStoredSettings(location) {
        	let string = undefined;
        	if(location && location.toLowerCase() === 'session') {
        		string = sessionStorage.getItem("goobi.viewer.disclaimer.settings");
        	} else {
        		string = localStorage.getItem("goobi.viewer.disclaimer.settings");
        	}
        	if(_debug)console.log("retrieve disclaimer setings ", string, " from ", location);
        	if(string) {
        		try {
	        		return JSON.parse(string);
				} catch(e) {
					console.error("Error loading disclaimer settings from " + location, e);
					return {};
				}        		
        	} else {
        		return {};
        	}
        },
        setStoredSettings(settings, location) {
        	if(_debug)console.log("save disclaimer setings ", settings, " to ", location);
        	if(location && location.toLowerCase() === 'session') {
        		sessionStorage.setItem("goobi.viewer.disclaimer.settings", JSON.stringify(settings));
        	} else {
        		localStorage.setItem("goobi.viewer.disclaimer.settings", JSON.stringify(settings));
        	}
        },
	    
    };
    

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // default variables
    var _debug = false;
    var _checkbox = null;
    var _downloadBtn = null;
    
    viewer.download = {
        /**
         * Method to initialize the download view.
         * 
         * @method init
         */
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.download.init' );
                console.log( '##############################' );
            }
            _checkbox = $( '#agreeLicense' );
            _downloadBtn = $( '#downloadBtn' );
            
            _downloadBtn.prop( 'disabled', true );
            
            _checkbox.on( 'click', function() {
                var currState = $( this ).prop( 'checked' );
                
                viewer.download.checkboxValidation( currState );
            } );
        },
        /**
         * Method which validates the checkstate of a checkbox and enables the download
         * button.
         * 
         * @method checkboxValidation
         * @param {String} state The current checkstate of the checkbox.
         */
        checkboxValidation: function( state ) {
            if ( _debug ) {
                console.log( '---------- viewer.download.checkboxValidation() ----------' );
                console.log( 'viewer.download.checkboxValidation: state = ', state );
            }
            
            if ( state ) {
                _downloadBtn.prop( 'disabled', false );
            }
            else {
                _downloadBtn.prop( 'disabled', true );
                return false;
            }
        },
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // default variables
    var _debug = false;
    var _defaults = {
        dataType: null,
        dataTitle: null,
        dataId: null,
        dataPi: null,
        downloadBtn: null,
        reCaptchaSiteKey: '',
        useReCaptcha: true,
        path: '',
        iiifPath: '',
        apiUrl: '',
        userEmail: null,
        workInfo: {},
        modal: {
            id: '',
            label: '',
            string: {
                title: '',
                body: '',
                closeBtn: '',
                saveBtn: '',
            }
        },
        messages: {
            downloadInfo: {
                text: 'Informationen zum angeforderten Download',
                title: 'Werk',
                part: 'Teil',
                fileSize: 'Größe'
            },
            reCaptchaText: 'Um die Generierung von Dokumenten durch Suchmaschinen zu verhindern bestätigen Sie bitte das reCAPTCHA.',
            rcInvalid: 'Die Überprüfung war nicht erfolgreich. Bitte bestätigen Sie die reCAPTCHA Anfrage.',
            rcValid: 'Vielen Dank. Sie können nun ihre ausgewählte Datei generieren lassen.',
            eMailText: 'Um per E-Mail informiert zu werden sobald der Download zur Verfügung steht, können Sie hier optional Ihre E-Mail Adresse hinterlassen',
            eMailTextLoggedIn: 'Sie werden über Ihre registrierte E-Mail Adresse von uns über den Fortschritt des Downloads informiert.',
            eMail: ''
        }
    };
    var _loadingOverlay = null;
    
    viewer.downloadModal = {
        /**
         * Method to initialize the download modal mechanic.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.dataType The data type of the current file to download.
         * @param {String} config.dataTitle The title of the current file to download.
         * @param {String} config.dataId The LOG_ID of the current file to download.
         * @param {String} config.dataPi The PI of the current file to download.
         * @param {Object} config.downloadBtn A collection of all buttons with the class
         * attribute 'download-modal'.
         * @param {String} config.reCaptchaSiteKey The site key for the google reCAPTCHA,
         * fetched from the viewer config.
         * @param {String} config.path The current application path.
         * @param {String} config.apiUrl The URL to trigger the ITM download task.
         * @param {String} config.userEmail The current user email if the user is logged
         * in. Otherwise the one which the user enters or leaves blank.
         * @param {Object} config.modal A configuration object for the download modal.
         * @param {String} config.modal.id The ID of the modal.
         * @param {String} config.modal.label The label of the modal.
         * @param {Object} config.modal.string An object of strings for the modal content.
         * @param {String} config.modal.string.title The title of the modal.
         * @param {String} config.modal.string.body The content of the modal as HTML.
         * @param {String} config.modal.string.closeBtn Buttontext
         * @param {String} config.modal.string.saveBtn Buttontext
         * @param {Object} config.messages An object of strings for the used text
         * snippets.
         * @example
         * 
         * <pre>
         * var downloadModalConfig = {
         *     downloadBtn: $( '.download-modal' ),
         *     path: '#{navigationHelper.applicationUrl}',
         *     userEmail: $( '#userEmail' ).val(),
         *     messages: {
         *         reCaptchaText: '#{msg.downloadReCaptchaText}',
         *         rcInvalid: '#{msg.downloadRcInvalid}',
         *         rcValid: '#{msg.downloadRcValid}',
         *         eMailText: '#{msg.downloadEMailText}',
         *         eMailTextLoggedIn: '#{msg.downloadEMailTextLoggedIn}',
         *         eMail: '#{msg.downloadEmail}',
         *         closeBtn: '#{msg.downloadCloseModal}',
         *         saveBtn: '#{msg.downloadGenerateFile}',
         *     }
         * };
         * 
         * viewerJS.downloadModal.init( downloadModalConfig );
         * </pre>
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.downloadModal.init' );
                console.log( '##############################' );
                console.log( 'viewer.downloadModal.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // build loading overlay
            _loadingOverlay = $( '<div />' );
            _loadingOverlay.addClass( 'dl-modal__overlay' );
            $( 'body' ).append( _loadingOverlay );
            
            $(_defaults.downloadBtn).on( 'click', function(e) {
                // show loading overlay
                $( '.dl-modal__overlay' ).fadeIn( 'fast' );
                
                _defaults.dataType = $( this ).attr( 'data-type' );
                _defaults.dataTitle = $( this ).attr( 'data-title' );
                if ( $( this ).attr( 'data-id' ) !== '' ) {
                    _defaults.dataId = $( this ).attr( 'data-id' );
                }
                else {
                    _defaults.dataId = '-';
                }
                _defaults.dataPi = $( this ).attr( 'data-pi' );
                _getWorkInfo( _defaults.dataPi, _defaults.dataId, _defaults.dataType ).done( function( info ) {
                    _defaults.workInfo = info;
                    
                    _defaults.modal = {
                        id: _defaults.dataPi + '-Modal',
                        label: _defaults.dataPi + '-Label',
                        string: {
                            title: _defaults.dataTitle,
                            body: viewer.downloadModal.renderModalBody( _defaults.dataType, _defaults.workInfo ),
                            closeBtn: _defaults.messages.closeBtn,
                            saveBtn: _defaults.messages.saveBtn,
                        }
                    };
                    
                    // hide loading overlay
                    $( '.dl-modal__overlay' ).fadeOut( 'fast' );
                    
                    // init modal
                    viewer.downloadModal.initModal( _defaults );
                } );
            } );
        },
        /**
         * Method which initializes the download modal and its content.
         * 
         * @method initModal
         * @param {Object} params An config object which overwrites the defaults.
         */
        initModal: function( params ) {
            if ( _debug ) {
                console.log( '---------- viewer.downloadModal.initModal() ----------' );
                console.log( 'viewer.downloadModal.initModal: params = ', params );
            }
            $( 'body' ).append( viewer.helper.renderModal( params.modal ) );
            
            // disable submit button
            $( '#submitModal' ).attr( 'disabled', 'disabled' );
            
            // show modal
            $( '#' + params.modal.id ).modal( 'show' );
            
            // render reCAPTCHA to modal
            $( '#' + params.modal.id ).on( 'shown.bs.modal', function( e ) {
                if ( _defaults.useReCaptcha ) {
                    var rcWidget = grecaptcha.render( 'reCaptchaWrapper', {
                        sitekey: _defaults.reCaptchaSiteKey,
                        callback: function() {
                            var rcWidgetResponse = viewer.downloadModal.validateReCaptcha( grecaptcha.getResponse( rcWidget ) );
                            
                            if ( rcWidgetResponse ) {
                                $( '#modalAlerts' ).append( viewer.helper.renderAlert( 'alert-success', _defaults.messages.rcValid, true ) );
                                
                                // enable submit button
                                $( '#submitModal' ).removeAttr( 'disabled' ).on( 'click', function() {
                                    _defaults.userEmail = $( '#recallEMail' ).val();
                                    
                                    _defaults.apiUrl = viewer.downloadModal
                                            .buildAPICall( _defaults.path, _defaults.dataType, _defaults.dataPi, _defaults.dataId, _defaults.userEmail );
                                    
                                    fetch(_defaults.apiUrl, {method: 'PUT'})
                                    .then(response => response.json())
                                    .then(response => window.location.href = response.url);
                                    
                                } );
                            }
                            else {
                                $( '#modalAlerts' ).append( viewer.helper.renderAlert( 'alert-danger', _defaults.messages.rcInvalid, true ) );
                            }
                        }
                    } );
                }
                else {
                    // hide paragraph
                    $( this ).find( '.modal-body h3' ).next( 'p' ).hide();
                    
                    // enable submit button
                    $( '#submitModal' ).removeAttr( 'disabled' ).on( 'click', function() {
                        _defaults.userEmail = $( '#recallEMail' ).val();
                        
                        _defaults.apiUrl = viewer.downloadModal.buildAPICall( _defaults.path, _defaults.dataType, _defaults.dataPi, _defaults.dataId, _defaults.userEmail );
                        
                        fetch(_defaults.apiUrl, {method: 'PUT'})
                        .then(response => response.json())
                        .then(response => window.location.href = response.url);
                    } );
                }
            } );
            
            // remove modal from DOM after closing
            $( '#' + params.modal.id ).on( 'hidden.bs.modal', function( e ) {
                $( this ).remove();
            } );
        },
        /**
         * Method which returns a HTML-String to render the download modal body.
         * 
         * @method renderModalBody
         * @param {String} type The current file type to download.
         * @param {String} title The title of the current download file.
         * @returns {String} The HTML-String to render the download modal body.
         */
        renderModalBody: function( type, infos ) {
            if ( _debug ) {
                console.log( '---------- viewer.downloadModal.renderModalBody() ----------' );
                console.log( 'viewer.downloadModal.renderModalBody: type = ', type );
                console.log( 'viewer.downloadModal.renderModalBody: infos = ', infos );
            }
            var rcResponse = null;
            var modalBody = '';
            
            modalBody += '';
            // alerts
            modalBody += '<div id="modalAlerts"></div>';
            // Title
            if ( type === 'pdf' ) {
                modalBody += '<h3>';
                modalBody += '<i class="fa fa-file-pdf-o" aria-hidden="true"></i> PDF-Download: ';
                modalBody += '</h3>';
            }
            else {
                modalBody += '<h3>';
                modalBody += '<i class="fa fa-file-text-o" aria-hidden="true"></i> ePub-Download: ';
                modalBody += '</h3>';
            }
            // Info
            modalBody += '<p>' + _defaults.messages.downloadInfo.text + ':</p>';
            modalBody += '<dl class="dl-horizontal">';
            modalBody += '<dt>' + _defaults.messages.downloadInfo.title + ':</dt>';
            modalBody += '<dd>' + infos.title + '</dd>';
            if ( infos.div !== null ) {
                modalBody += '<dt>' + _defaults.messages.downloadInfo.part + ':</dt>';
                modalBody += '<dd>' + infos.div + '</dd>';
            }
            if ( infos.size ) {
                modalBody += '<dt>' + _defaults.messages.downloadInfo.fileSize + ':</dt>';
                modalBody += '<dd>~' + infos.size + '</dd>';
                modalBody += '</dl>';
            }
            // reCAPTCHA
            if ( _defaults.useReCaptcha ) {
                modalBody += '<hr />';
                modalBody += '<p><strong>reCAPTCHA</strong></p>';
                modalBody += '<p>' + _defaults.messages.reCaptchaText + ':</p>';
                modalBody += '<div id="reCaptchaWrapper"></div>';
            }
            // E-Mail
            modalBody += '<hr />';
            modalBody += '<form class="email-form">';
            modalBody += '<div class="form-group">';
            modalBody += '<label for="recallEMail">' + _defaults.messages.eMail + '</label>';
            if ( _defaults.userEmail != undefined ) {
                modalBody += '<p class="help-block">' + _defaults.messages.eMailTextLoggedIn + '</p>';
                modalBody += '<input type="email" class="form-control" id="recallEMail" value="' + _defaults.userEmail + '" disabled="disabled" />';
            }
            else {
                modalBody += '<p class="help-block">' + _defaults.messages.eMailText + ':</p>';
                modalBody += '<input type="email" class="form-control" id="recallEMail" />';
            }
            modalBody += '</div>';
            modalBody += '</form>';
            
            return modalBody;
        },
        /**
         * Method which checks the reCAPTCHA response.
         * 
         * @method validateReCaptcha
         * @param {String} response The reCAPTCHA response.
         * @returns {Boolean} Returns true if the reCAPTCHA sent a response.
         */
        validateReCaptcha: function( response ) {
            if ( _debug ) {
                console.log( '---------- viewer.downloadModal.validateReCaptcha() ----------' );
                console.log( 'viewer.downloadModal.validateReCaptcha: response = ', response );
            }
            if ( response == 0 ) {
                return false;
            }
            else {
                return true;
            }
        },
        /**
         * Method which returns an URL to trigger the ITM download task.
         * 
         * @method buildAPICall
         * @param {String} path The current application path.
         * @param {String} type The current file type to download.
         * @param {String} pi The PI of the current work.
         * @param {String} logid The LOG_ID of the current work.
         * @param {String} email The current user email.
         * @returns {String} The URL to trigger the ITM download task.
         */
        buildAPICall: function( path, type, pi, logid, email ) {
            if ( _debug ) {
                console.log( '---------- viewer.downloadModal.buildAPICall() ----------' );
                console.log( 'viewer.downloadModal.buildAPICall: path = ', path );
                console.log( 'viewer.downloadModal.buildAPICall: type = ', type );
                console.log( 'viewer.downloadModal.buildAPICall: pi = ', pi );
                console.log( 'viewer.downloadModal.buildAPICall: logid = ', logid );
                console.log( 'viewer.downloadModal.buildAPICall: email = ', email );
            } 
            var url = '';
            
            url += path + 'api/v1/downloads/';
            url += type;
            url += "/records/";
            url += pi;
            if(logid) {
                url += "/sections/";
                url += logid;
            }
            url += "/";
            if(email) {
                url += "?email=";
                url += email;
            }
            
            return encodeURI( url );
        }
    };
    
    /**
     * Method which returns a promise if the work info has been reached.
     * 
     * @method getWorkInfo
     * @param {String} pi The PI of the work.
     * @param {String} logid The LOG_ID of the work.
     * @returns {Promise} A promise object if the info has been reached.
     */
    function _getWorkInfo( pi, logid, type ) {
        if ( _debug ) {
            console.log( '---------- _getWorkInfo() ----------' );
            console.log( '_getWorkInfo: pi = ', pi );
            console.log( '_getWorkInfo: logid = ', logid );
            console.log( '_getWorkInfo: type = ', type );
        }
        
        var restCall = '';
        var workInfo = {}; 
        var iiifPath = _defaults.iiifPath.replace("/rest", "/api/v1");
        if ( logid !== '' && logid !== undefined && logid != '-' ) {
            restCall = iiifPath + "records/" + pi + "/sections/" + logid + '/' + type + '/info.json';
             
            if ( _debug ) {
                console.log( 'if' ); 
                console.log( '_getWorkInfo: restCall = ', restCall );
            }
        }
        else {
            restCall = iiifPath + "records/" + pi + "/" + type + '/info.json';
            
            if ( _debug ) {
                console.log( 'else' );
                console.log( '_getWorkInfo: restCall = ', restCall );
            }
        }
        
        return viewerJS.helper.getRemoteData( restCall );
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _fadeout;
    var _sidebarWidth;
    var _sidebarLeft;
    var _sidebarId;
    var _lastKeyCode;
    var _lastKeyPress;
    var _maxDoubleClickDelay = 250 //ms
    var _defaults = {
    	resizeSelector: '#fullscreenViewSidebar',
    	openPanel: "panel-1",
    	sidebarOpen: true,
    	msg: {}
    };
    
    viewer.fullscreen = {
        /**
         * Method to initialize the viewer fullscreen.
         * 
         * @method init
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.fullscreen.init' );
                console.log( '##############################' );
                console.log( 'viewer.fullscreen.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );

            // hide header
            _hideHeader( true, 5000 );
            
            // display header on mousemove/touchmove
            $( '#fullscreenViewImage, #fullscreenViewSidebar' ).on( 'mousemove', function() {
            	_hideHeader( true );
            } );
            $( '#fullscreenViewSidebar' ).on( 'click', function() {
            	_hideHeader( false );
            } );
            $( '#fullscreenHeader' ).on( 'mousemove', function() {
            	_hideHeader( false );
            } );
            $( window ).on( 'touchstart touchend touchcancel touchmove', function() {
            	_hideHeader( true, 1000 );
            } );
            $( '#fullscreenViewImage, #fullscreenViewSidebar' ).on( 'touchstart touchend touchcancel touchmove', function() {
                _hideHeader( true, 1000 );
            } );
            
            // make elements resizable
            if ( window.matchMedia( '(min-width: 769px)' ).matches ) {
            	_setResizable( _defaults.resizeSelector );
            	
                // set position on resize/orientationchange
                $( window ).on( 'resize', function(e) {
                    _sidebarId = $( '#fullscreenViewSidebar' ).attr( 'id' );
                    
                    // check if sidebar is resizing
                    if ( e.target[ 'id' ] != _sidebarId ) {
                        $( 'body' ).hide();
                        window.location.href = window.location.href;                    
                    }
                } );
            } 
            else {
                // set position on resize/orientationchange
                $( window ).on( 'orientationchange', function(e) {
                    $( 'body' ).hide();                    
                    window.location.href = window.location.href;                    
                } );   
            }
            
            // set sidebar panel, status and width
            _getSidebarWidth();
            _setPanelStatus();
            _setSidebarStatus();
            _getSidebarScrollPosition();
            _hideEmptyPanels();

            // toggle sidebar
            $( '[data-close="fs-sidebar"]' ).on( 'click', function() {
            	// set global variables
            	_sidebarWidth = $( '#fullscreenViewSidebar' ).outerWidth();
            	_sidebarLeft = $( '#fullscreenViewSidebar' ).css( 'left' );
            	// save sidebar width
            	_setSidebarWidth( _sidebarWidth );
            	
            	// set sidebar left position
            	$( '#fullscreenViewSidebar' ).css( 'left', 'inherit' );

            	
            	// reset resizable
            	if ( window.matchMedia( '(min-width: 769px)' ).matches) {
            		_unsetResizable( _defaults.resizeSelector );
            	}

            	// hide panel controls
            	$( '#fullscreenSidebarPanelControls' ).hide();
            	
            	// slide out sidebar
            	$( '#fullscreenViewSidebar' ).animate( {
            		right: '-' + _sidebarWidth + 'px'
            	}, 300, function() {            		

            		// show sidebar open
                let sidebarOpenDiv = $( '#viewSidebarOpen' );
                let sidebarOpenBtn = sidebarOpenDiv[0].querySelector('[data-open="fs-sidebar"]');
            		sidebarOpenDiv.addClass( 'in' );

                // ACCESSIBILITY
                // make btn focusable 
                sidebarOpenBtn.setAttribute('tabindex', '0');
                // add display:none
                // prevents focusable elements in the sidebar from beeing focused using the tab key
            	  $( '#fullscreenViewSidebar' ).css( 'display', 'none' );

            		// show back and forward on small devices
                	if ( window.matchMedia( '(max-width: 480px)' ).matches ) {
                		$( '.image-controls__action.back, .image-controls__action.forward' ).show();
                	}

            		// save sidebar status
            		sessionStorage.setItem( 'fsSidebarStatus', false );
            	} );

            	
            	if ( $( '.fullscreen__view-image-thumbs-wrapper' ).is( ':visible' ) ) {
            		$( '.fullscreen__view-image-thumbs-wrapper' ).animate( {
            			width: '100%'
            		}, 300 );
    			}
            } );

            // Open Sidebar
            $( '[data-open="fs-sidebar"]' ).on( 'click', function() {
                let sidebarOpenDiv = $( '#viewSidebarOpen' );
                let sidebarOpenBtn = sidebarOpenDiv[0].querySelector('[data-open="fs-sidebar"]');

                // hide sidebar open
                sidebarOpenDiv.removeClass( 'in' );

                // ACCESIBILITY
                // prevent hidden btn from being focusable
                sidebarOpenBtn.setAttribute('tabindex', '-1');
            	
            	// show back and forward on small devices
            	if ( window.matchMedia( '(max-width: 480px)' ).matches ) {
            		$( '.image-controls__action.back, .image-controls__action.forward' ).hide();
            	}
            	
              // Remove display:none => make slide in animation possible (see below)
              // Originally set so focusable elements in the closed sidebar cannot be reached using the tab key 
              $( '#fullscreenViewSidebar' ).css( 'display', '' );

            	// slide in sidebar
            	$( '#fullscreenViewSidebar' ).animate( {
            		right: 0
            	}, 300, function() {

            		// set sidebar left position
            		$( '#fullscreenViewSidebar' ).css( 'left', _sidebarLeft );
            		
            		// show panel controls
            		$( '#fullscreenSidebarPanelControls' ).show();

            		// set resizable
            		if ( window.matchMedia( '(min-width: 769px)' ).matches ) {
            			_setResizable( _defaults.resizeSelector );
            		}
            		
            		// save sidebar status
            		sessionStorage.setItem( 'fsSidebarStatus', true );

            	} );
            	
            	if ( $( '.fullscreen__view-image-thumbs-wrapper' ).is( ':visible' ) ) {
            		$( '.fullscreen__view-image-thumbs-wrapper' ).animate( {
            			width: $( '#fullscreenView' ).outerWidth() - _sidebarWidth
            		}, 300 );
    			}
            } );
            
            // scroll resize handle and hide panel controls
            $( '#fullscreenViewSidebar' ).on( 'scroll', function() {
            	var currScrollPosition = $( this ).scrollTop();
            	
            	$( '.ui-resizable-handle' ).css( 'top', $( this ).scrollTop() );
            	
            	_setSidebarScrollPosition( currScrollPosition );
            	
            	if ( $( this ).scrollTop() > 0 ) {
            		$( '#fullscreenSidebarPanelControls' ).addClass( 'hidden' );
            	}
            	else {
            		$( '#fullscreenSidebarPanelControls' ).removeClass( 'hidden' );
            	}
            } );
            
            // toggle sidebar panels
            $( '.fullscreen__view-sidebar-accordeon-panel-title' ).on( 'click keydown', function(e) {

              if((e.type == 'keydown' && e.key == 'Enter') || e.type == 'click') {

                var parentPanelId = $( this ).parent().attr( 'id' );
                var panelSessionStatus = JSON.parse( sessionStorage.getItem( 'fsPanelStatus' ) );
                // scroll sidebar to top
                $( '#fullscreenViewSidebar' ).scrollTop( 0 );
                
                if ( $( this ).hasClass( 'in' ) ) {
                    $( this ).toggleClass( 'in' );
                    $( this ).next().slideToggle( 'fast' );
                    panelSessionStatus[ parentPanelId ] = false;
                    sessionStorage.setItem( 'fsPanelStatus', JSON.stringify( panelSessionStatus ) );
                }
                else {                	
                    $( '.fullscreen__view-sidebar-accordeon-panel-title' ).each( function() {
                        $( this ).removeClass( 'in' );
                    } );
                    $( '.fullscreen__view-sidebar-accordeon-panel-body' ).each( function() {
                        $( this ).slideUp( 'fast' );
                    } );

                    $( this ).toggleClass( 'in' );
                    $( this ).next().slideToggle( 'fast' );
//                    viewer.GeoMap.allMaps.forEach(geomap => {
//                    	geomap.map.invalidateSize();
//                    	geomap.layers.find(layer => !layer.isEmpty())?.setViewToFeatures(true);
//                    });
                    for ( var status in panelSessionStatus ) {
                        if(status.startsWith("panel-")) {                       
                            panelSessionStatus[ status ] = false;
                        }
                    }

                    panelSessionStatus[ parentPanelId ] = true;
                    sessionStorage.setItem( 'fsPanelStatus', JSON.stringify( panelSessionStatus ) );
                }

              }

            } );

            // hide all panels
            $( '[data-close="all-tabs"]' ).on( 'click', function() {
            	var panelSessionStatus = JSON.parse( sessionStorage.getItem( 'fsPanelStatus' ) );
            	
            	$( '.fullscreen__view-sidebar-accordeon-panel-title' ).each( function() {
            		$( this ).removeClass( 'in' );
                    $( this ).next().slideUp( 'fast' );
            	} );
            	for ( var status in panelSessionStatus ) {
            	    if(status.startsWith("panel-")) {            	        
            	        panelSessionStatus[ status ] = false;
            	    }
                }
            	
            	sessionStorage.setItem( 'fsPanelStatus', JSON.stringify( panelSessionStatus ) );
            } );

            // show all panels
            $( '[data-open="all-tabs"]' ).on( 'click', function() {
            	var panelSessionStatus = JSON.parse( sessionStorage.getItem( 'fsPanelStatus' ) );

            	$( '.fullscreen__view-sidebar-accordeon-panel-title' ).each( function() {
            		$( this ).addClass( 'in' );
            		$( this ).next().slideDown( 'fast' );
            	} );
            	
            	for ( var status in panelSessionStatus ) {
                    if(status.startsWith("panel-")) {                       
                        panelSessionStatus[ status ] = true;
                    }
                }
            	
            	sessionStorage.setItem( 'fsPanelStatus', JSON.stringify( panelSessionStatus ) );
            } ); 
            
            $(document.body).off( 'keyup' , _handleKeypress);
            $(document.body).on( 'keyup' , _handleKeypress);
        },
    };
    
    /**
     * @description Method to set the sidebar status.
     * @method _setSidebarStatus
     * */
    function _setSidebarStatus() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setSidebarStatus' );
    	}
    	
    	let sidebarOpen = sessionStorage.getItem( 'fsSidebarStatus' );
    	if(sidebarOpen == undefined) {
    	    sidebarOpen = _defaults.sidebarOpen;
    	    sessionStorage.setItem( 'fsSidebarStatus', sidebarOpen );
    	} else {    	    
    	    sidebarOpen = (sidebarOpen == 'true');
    	}

    	if(sidebarOpen) {
    		if ( window.matchMedia( '(max-width: 480px)' ).matches ) {
    			// hide sidebar
    			_hideSidebar( $( '#fullscreenViewSidebar' ).outerWidth() );
				// always set fssidebarstatus to false for very small screens (this is needed for the thumbnail view size calculation)
    			sessionStorage.setItem( 'fsSidebarStatus', false );    
    		} else {
    			sessionStorage.setItem( 'fsSidebarStatus', true );    
    		}
    	} else {
    			// hide sidebar
    			_hideSidebar( $( '#fullscreenViewSidebar' ).outerWidth() );
    			// reset resizable
    			if ( window.matchMedia( '(min-width: 769px)' ).matches ) {
    				_unsetResizable( _defaults.resizeSelector );
    			}
    	}
    	
    	// show sidebar
    	$( '.fullscreen__view-sidebar-inner' ).show();
    }
    
    function _hideEmptyPanels() {
        document.querySelectorAll(".fullscreen__view-sidebar-accordeon-panel").forEach(panel => {
            let childCount = [...panel.querySelectorAll(".fullscreen__view-sidebar-accordeon-panel-body")].flatMap(body => body.children).map(child => child.length).reduce((acc, v) => acc+v );
            if(childCount < 1) {
                panel.classList.add("d-none");
            }
          })
    }

    /**
     * @description Method to set the sidebar scroll position.
     * @method _setSidebarScrollPosition
     * */
    function _setSidebarScrollPosition( scroll ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setSidebarScrollPosition' );
    		console.log( '--> scroll: ', scroll );
    	}
    	
    	sessionStorage.setItem( 'fsSidebarScrollPosition', scroll );
    }
    
    /**
     * @description Method to get the sidebar scroll position.
     * @method _getSidebarScrollPosition
     * */
    function _getSidebarScrollPosition() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _getSidebarScrollPosition' );
    	}
    	
    	var pos = sessionStorage.getItem( 'fsSidebarScrollPosition' );
    	
    	// check if session storage value exists
    	if ( pos == undefined || pos === null ) {
    		sessionStorage.setItem( 'fsSidebarScrollPosition', 0 );
    		pos = sessionStorage.getItem( 'fsSidebarScrollPosition' );    		
    	}

    	// set sidebar scroll position
    	$( '.ui-resizable-handle' ).css( 'top', pos );
    	
    	if ( pos > 0 ) {
    		$( '#fullscreenSidebarPanelControls' ).addClass( 'hidden' );
    	}
    	else {
    		$( '#fullscreenSidebarPanelControls' ).removeClass( 'hidden' );
    	}
    	
    	$( '#fullscreenViewSidebar' ).scrollTop( pos );
    }
    
    /**
     * @description Method which hides the sidebar.
     * @method _hideSidebar
     * @param {Number} width The current sidebar width.
     * */
    function _hideSidebar( width ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _hideSidebar' );
    		console.log( 'width: ', width );
    	}
    	
      // set sidebar left position
      $( '#fullscreenViewSidebar' ).css( {
        'right': '-' + width + 'px',
        'left': 'inherit'
      } );
      
      // hide panel controls
      $( '#fullscreenSidebarPanelControls' ).hide();
      
      // show sidebar open
      let sidebarOpenDiv = $( '#viewSidebarOpen' );
      let sidebarOpenBtn = sidebarOpenDiv[0].querySelector('[data-open="fs-sidebar"]');
      sidebarOpenDiv.addClass( 'in' );

      // ACCESSIBILITY
      // prevent hidden btn from being focused
      sidebarOpenBtn.setAttribute('tabindex', '-1');
    }
    
    /**
     * @description Method to set the accordeon panel status.
     * @method _setPanelStatus
     * */
    function _setPanelStatus() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setPanelStatus' );
    	}
    	            
        let openPanelFromUrl = _getPanelStatusFromUrlParameter();
        if(_debug)console.log("Open panel url query param: " + openPanelFromUrl);
            
    	
    	var panelStatus;
    	var fsPanelStatus = sessionStorage.getItem( 'fsPanelStatus' );
    	if(fsPanelStatus) {
    	    panelStatus = JSON.parse(fsPanelStatus);
    	    if(panelStatus.persistentIdentifier !== _defaults.persistentIdentifier) {
    	        panelStatus = undefined;
    	    }
    	} else {
    	    panelStatus = undefined;
    	}
        
    	if ( !panelStatus ) {
    		panelStatus = {};
    		panelStatus.persistentIdentifier = _defaults.persistentIdentifier;
    		let openPanel = openPanelFromUrl ? openPanelFromUrl : _defaults.openPanel;
    		// build panel status object
    		$( '.fullscreen__view-sidebar-accordeon-panel' ).each( function() {
    			var currId = $( this ).attr( 'id' );
    			
    			if ( !panelStatus.hasOwnProperty( currId ) ) {
    				// disable all panels
    				if(openPanel == currId) {
    					panelStatus[ currId ] = true;
    				} else {    					
    					panelStatus[ currId ] = false;
    				}
    				
    				// enable first panel
    				// panelStatus[Object.keys(panelStatus)[_defaults.openPanel]] = true;
		    		
		    		// show active panels
		    		if ( panelStatus[ currId ] ) {
		    			$( this ).find( '.fullscreen__view-sidebar-accordeon-panel-title' ).addClass( 'in' );
		    			$( this ).find( '.fullscreen__view-sidebar-accordeon-panel-body' ).show();
		    		}    			        	
    			}
    			else {
    				return false;
    			}        	
    		} );
		
    	}
    	else {
    		
    		if( _debug ) {
    			console.log( '--> panelStatus: ', panelStatus );
    		}
    		
    		
    		$( '.fullscreen__view-sidebar-accordeon-panel' ).each( function() {
    			var currId = $( this ).attr( 'id' );

				//set active panel status from url query param    			
	    		if(openPanelFromUrl) {
	    			if(currId == openPanelFromUrl) {
	    				panelStatus[ currId ] = true;
	    			} else {
	    				panelStatus[ currId ] = false;
	    			}
	    		} 

    			// show active panels
	    		if ( panelStatus[ currId ] ) {
    				$( this ).find( '.fullscreen__view-sidebar-accordeon-panel-title' ).addClass( 'in' );
					$( this ).find( '.fullscreen__view-sidebar-accordeon-panel-body' ).show();
    			}    			        	
    		} );    		
    	}
    	    		
		// write object to session storage  
		sessionStorage.setItem( 'fsPanelStatus', JSON.stringify( panelStatus ) );    
    } 

	function _getPanelStatusFromUrlParameter() {
		
		let activetab = viewerJS.helper.getUrlSearchParam("activetab");
		if(activetab) {
			if(_debug)console.log("Set active tab from query param ", activetab);
			//find panel-id
			let tabId = $(".fs-" + activetab).attr("id");
			return tabId;
		}
	
	}

    /**
     * @description Method to initialize the resizable view.
     * @method _setResizable
     * @param {String} selector The selector of the element which should be resizable.
     * */
    function _setResizable( selector ) {
    	if ( _debug ) {
            console.log( 'EXECUTE: _setResizable' );
            console.log( 'selector: ', selector );
        }
    	
    	$( selector ).resizable({
    		handles: 'w',
    		minWidth: 500,
    		maxWidth: 900,
    		resize: function( event, ui ) {
    			_setSidebarWidth( $( '#fullscreenViewSidebar' ).outerWidth() );
    			
    			if ( $( '.fullscreen__view-image-thumbs-wrapper' ).is( ':visible' ) ) {
    				setTimeout( function() {
    					$( '.fullscreen__view-image-thumbs-wrapper' ).outerWidth( $( '#fullscreenView' ).outerWidth() - $( '#fullscreenViewSidebar' ).outerWidth() );    					
    				}, 325 );
    			}
    		}
    	});
    }
    
    /**
     * @description Method to save the sidebar width to session storage.
     * @method _setSidebarWidth
     * @param {Number} width The current width of the sidebar.
     * */
    function _setSidebarWidth( width ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setSidebarWidth' );
    		console.log( '--> width: ', width );
    	}
    	
    	sessionStorage.setItem( 'fsSidebarWidth', width );
    }

    /**
     * @description Method to get the sidebar scroll position.
     * @method _getSidebarWidth
     * */
    function _getSidebarWidth() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _getSidebarWidth' );
    	}
    	
    	var sbWidth = sessionStorage.getItem( 'fsSidebarWidth' );
    	
    	// check if session storage value exists
    	if ( sbWidth == undefined || sbWidth === null ) {
    		sessionStorage.setItem( 'fsSidebarWidth', $( '#fullscreenViewSidebar' ).outerWidth() );
    		sbWidth = sessionStorage.getItem( 'fsSidebarWidth' );    		
    	}

    	// set sidebar width
    	if ( window.matchMedia( '(min-width: 769px)' ).matches ) {
    		$( '#fullscreenViewSidebar' ).css( 'width', sbWidth + 'px' );
    	}
    }
    
    /**
     * @description Method to dispose the resizable view.
     * @method _unsetResizable
     * @param {String} selector The selector of the element which should be unset.
     * */
    function _unsetResizable( selector ) {
    	if ( _debug ) {
            console.log( 'EXECUTE: _unsetResizable' );
            console.log( 'selector: ', selector );
        }

    	$( selector ).resizable( 'destroy' );
    }

    /**
     * @description Method to switch the view to fullscreen.
     * @method _hideHeader
     * @param {Boolean} trigger A boolean which enables/disables the fadeout.
     * @param {Number} delay The delay when header is hiding. 
     * */
    function _hideHeader( trigger, delay ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _hideHeader' );
    	}
    	
    	var delay;
    	
    	if ( delay != undefined ) {
    		delay = delay;
    	}
    	else {
    		delay = 5000;
    	}

      // Check if keyboard is used to navigate the page
      var usingKeyboard = false;
      if(document.body.classList.contains('using-keyboard')) {
        usingKeyboard = true;
      }
    	
    	if ( trigger && !usingKeyboard) {
    		if ( _fadeout ) {
    			clearTimeout( _fadeout );
    			$( '#fullscreenHeader' ).show();
    		}
    		
    		_fadeout = setTimeout( function() {
    			$( '#fullscreenHeader' ).fadeOut( '1000' );
    		}, delay );    		
    	}
    	else {
    		clearTimeout( _fadeout );
			$( '#fullscreenHeader' ).show();
    	}
    }
   
    /**
     * @description Method to set key events to navigate through images, and exit fullscreen mode.
     * @method _handleKeypress
     * @param {Object} event An event object to trigger key events. 
     * */
    function _handleKeypress( event ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _handleKeypress' );
    		console.log( '--> event: ', event );
    	}
    	
        if (event.originalEvent) {
            event = event.originalEvent;
        }

        // don't handle if the actual target is an input field
        if (event.target.tagName.toLowerCase().match(/input|textarea/)) {
            return true;
        }

        var keyCode = event.keyCode;
        var now = Date.now();

        // this is a double key press if the last entered keycode is the same as the current one and the last key press is less than maxDoubleClickDelay ago
        var doubleKeypress = (_lastKeyCode == keyCode && now - _lastKeyPress <= _maxDoubleClickDelay);
        _lastKeyCode = keyCode;
        _lastKeyPress = now;

        if (_debug) {
            console.log('key pressed ', keyCode);
            if (doubleKeypress) {
                console.log('double key press');
            }
        }

        switch (keyCode) {
            case 37:
                if (doubleKeypress && $('.image-controls__action.start a').length) {
                    $('.image-controls__action.start a').get(0).click();
                }
                else if ($('.image-controls__action.back a').length) {
                    $('.image-controls__action.back a').get(0).click();
                }
                break;
            case 39:
                // jump to last image, if right arrow key was pressed twice
                if (doubleKeypress && $('.image-controls__action.end a').length) {
                    $('.image-controls__action.end a').get(0).click();
                }
                // advance one image at a time, if right arrow key is pressed once
                else if ($('.image-controls__action.forward a').length) {
                    $('.image-controls__action.forward a').get(0).click();
                }
                break;
            case 27:
                // exit fullscreen on escape
                if ($('[data-js="exit-fullscreen"]').length && document.readyState == 'complete') {
                    $('[data-js="exit-fullscreen"]').get(0).click();
                }
        };
    }   
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = (function(viewer) {
	'use strict';

	// define variables
	var _debug = false;
	var _defaults = {

	};

	viewer.fulltextActions = {
		/**
		 * Method which initializes the fulltext popovers for entity terms
		 * 
		 * @method init
		 * viewerJS.fulltextActions.init();
		 */
		init: function(config) {
			if (_debug) {
				console.log('##############################');
				console.log('viewer.fulltextActions.init');
				console.log('##############################');
			}

			$.extend(true, _defaults, config);

			_initFulltextPopovers();
		}
	};

	function _initFulltextPopovers() {

		// DISABLE ALL BUTTONS WITH NO URI
		$('[data-entity-type]:not([data-entity-authority-data-uri])').attr("disabled", true);

		// ITERATE THROUGH THE ENTITIES AND ENABLE BUTTON FUNCTIONALITY
		$('[data-entity-authority-data-uri]').each(function(normdataConfig) {

			// MSG KEYS
			var actionsPopoverHeadingMsg = _defaults.msg.fulltextPopoverActionsTermMsg;
			var authorityDataMsg = _defaults.msg.fulltextPopoverAuthorityDataMsg;
			var triggerSearchMsg = _defaults.msg.fulltextPopoverTriggerSearchMsg;

			var thisEntityElement = $(this);
			if (_debug) {
				console.log(thisEntityElement);
			}
			var searchLink = $(this).data("entity-authority-data-search");
			if (_debug) {
				console.log(searchLink);
			}
			var authorityDataUri = $(this).data("entity-authority-data-uri");
			if (_debug) {
				console.log(authorityDataUri);
			}

			// THE POPOVER HTML ELEMENT
			var popOverActionsElement = `<div class="hidden entity-popover-element">
	  			<div class="popover-heading">${actionsPopoverHeadingMsg}</div>
	  			
	  			<div class="popover-body"> 
	  				<div class="d-flex flex-column">
	  					<button class="view-fulltext__popover-button" type="button" data-remotecontent="${authorityDataUri}">
	  						<i class="fa fa-list-ul" aria-hidden="true"></i><span>${authorityDataMsg}</span>
	  					</button>
	  					<a class="view-fulltext__popover-button" href="${searchLink}"><i class="fa fa-search" aria-hidden="true"></i><span>${triggerSearchMsg}</span></a>
	  					</div>
	  			</div>
	  		</div>`

			// INSERT HIDDEN POPOVER CONTENT AFTER ENTITY TERM
			$(this).after(popOverActionsElement);

			// CREATE EMPTY/PLACEHOLDER HTML ELEMENT FOR EACH ENTITY TERM TO ATTACH THE POPOVER TO THIS ELEMENT
			$(this).after('<span data-placeholder="forPopover"></span>');

			// VAR/SELECTORS FOR THE CONTENT, TITLE AND THE PLACEHOLDER ELEMENT
			var thisEntityBody = $(thisEntityElement).next().next().find('.popover-body').html();
			var thisEntityTitle = $(thisEntityElement).next().next().find('.popover-heading').html();
			var thisEntityAfterElement = $(thisEntityElement).next('[data-placeholder="forPopover"]');

			// EVENT ON EVERY ENTITY TERM: POPOVER WITH INSERTED TITLE AND CONTENT
			$(this).popover({
				html: true,
				sanitize: false,
				boundary: 'window',
				placement: 'top',
				trigger: 'click',
				container: thisEntityAfterElement,
				content: function() {
					var content = thisEntityBody;
					return content;

				},
				title: function() {
					var title = thisEntityTitle;
					return title;
				},
			});

			// AFTER CREATING POPOVER EXECUTE AUTHORITY DATA SCRIPT (viewerJS.normdata.init)
			$(this).on('shown.bs.popover', function() {
				$('[data-entity-type]').not(this).popover('hide');

				// AUTHORITY DATA INIT
				viewerJS.normdata.init(_defaults.normdataConfig);

				// CLOSE POPOVERS WHEN CLICKED OUTSIDE OF THE POPOVERS
				$('html').on('click', function(e) {
					if (typeof $(e.target).data('original-title') == 'undefined' && !$(e.target).parents().is('.popover')) {
						$('[data-original-title]').popover('hide');
					}
				});
			})
		});
	}

	return viewer;

})(viewerJS || {}, jQuery);

var viewerJS = ( function ( viewer ) {
    'use strict';

    var _debug = false;
    var _defaults = {
            groupAttribute: "data-group",
            selectAllSelector: "[data-group-select='select-all']",
            selectOneSelector: "[data-group-select='select-one']",
            reseter: undefined
                
    };

    viewer.groupSelect = {

        checkObservables: new Map(),
        init: function( config ) {
            this.config = $.extend( true, {}, _defaults, config );
            if(_debug) {
                console.log("Init group select with config ", this.config);
            }
            
            $(this.config.selectAllSelector).each((index, groupSelectCheckbox) => {
                if(_debug)console.log("found select all checkbox", groupSelectCheckbox);
                let $groupSelectCheckbox = $(groupSelectCheckbox);
                let groupName = $(groupSelectCheckbox).attr(this.config.groupAttribute);
                if(_debug)console.log("Set up selection group " + groupName);
                if(groupName) {
                    this.initGroup(groupName, $groupSelectCheckbox);
                }
            });
            
            if(this.config.reseter) {
                $(this.config.reseter).on("click", e => {
                    if(_debug)console.log("group select reset by ", e.target);
                    $(this.config.selectAllSelector).prop("checked", false);
                    $(this.config.selectOneSelector).prop("checked", false);
                })
            }
        },
        
        initGroup: function(groupName) {
            let groupSelectObservable = new rxjs.Subject();
            rxjs.fromEvent(document, "click")
            .pipe(rxjs.operators.filter(e => {
                return e.target.matches(this.getSelectAllSelector(groupName));
            }))
            .subscribe(e => {
                let checked = $(e.target).is(":checked");
                $(this.getSelectOneSelector(groupName)).prop('checked', checked);
                e.allChecked = checked;
                e.anyChecked = checked;
                groupSelectObservable.next(e);
            })
            rxjs.fromEvent(document, "click")
            .pipe(rxjs.operators.filter(e => {
                return e.target.matches(this.getSelectOneSelector(groupName));
            }))
            .subscribe(e => {
                let checked = $(e.target).is(":checked");
                let numChecked = $(this.getSelectOneSelector(groupName) + ":checked").length;
                let numTotal = $(this.getSelectOneSelector(groupName)).length;
                if(_debug)console.log(numChecked + " out of " + numTotal + " checkboxed checked");
                e.allChecked = numChecked == numTotal;
                e.anyChecked = numChecked > 0;
                $(this.getSelectAllSelector(groupName)).prop('checked', e.allChecked)
                groupSelectObservable.next(e);
            })
            this.checkObservables.set(groupName, groupSelectObservable);

        },
        
        getGroupSelector: function(groupName) {
            let groupSelector = "[" + this.config.groupAttribute + "='" + groupName + "']";
            return groupSelector;
        },
        getSelectAllSelector: function(groupName) {
            let selector = this.getGroupSelector(groupName) + this.config.selectAllSelector;
            return selector;
        },
        getSelectOneSelector: function(groupName) {
            let selector = this.getGroupSelector(groupName) + this.config.selectOneSelector;
            return selector;
        },
        
        onChange: function(groupName) {
            return this.checkObservables.get(groupName);
        }
    }

    return viewer;

} )( viewerJS || {}, jQuery );
var viewerJS = ( function( viewer ) {
    'use strict';
    
    // default variables
    var _debug = false;
    
    viewer.iiif = {
            
            /**
             * parses the given element to return the appropriate String value for the given language.
             * If the given element is a String itself, that String is returned, if it is a single object, the property @value 
             * is returned, if it is an array of Strings, the first String is returned, if it is an array of objects,
             * the @value property of the first object with an @language property equals to the given language is returned
             *  
             * @param element   The js property value to parse, either a String, an object with properties @value and @language or an array of either of those
             * @param language  The preferred language String as a two digit code
             * @returns         The most appropriate String value found
             */
            getValue: function(element, locale, fallbackLanguage) {
                
                if(!fallbackLanguage) {
                    fallbackLanguage = 'en';
                }
                if(element) {
                    if(typeof element === 'string') {
                        return element;
                    } else if (Array.isArray(element)) {
                       var fallback;
                        for (var index in element) {
                           var item = element[index];
                           if(typeof item === 'string') {
                               return item;
                           } else {
                               var value = item['@value'];
                               var language = item['@language'];
                               if(locale == language) {
                                   return value;
                               } else if(!fallback || language == fallbackLanguage) {
                                   fallback = value;
                               }
                           }
                       }
                        return fallback;
                    } else if (element['@value']) {
                        return element['@value'];                
                    } else {
                    	 if(element[locale]) {
                    	 	return element[locale].join(", ");
                    	 } else if(fallbackLanguage && element[fallbackLanguage]) {
                    	 	return element[fallbackLanguage].join(", ");
                    	 } else if(element.none) {
                    	 	return element.none.join(", ");
                    	 } else if(element._default) {
                    	 	return element._default.join(", ");
                    	 } else {
                    	 	let keys = Object.keys(element);
                    	 	if(keys && keys.length > 0) {
                    	 		return element[keys[0]]
                    	 	} else {
                    	 		return undefined;
                    	 	}
                    	 }
                    }
                }
            },
            
            /**
             * Method to retrieve metadata value of the metadata object with the given label and
             * within the given collection object.
             * 
             * @param collection {Object} The iiif-presentation collection object cotaining the
             * metadata.
             * @param label {String} The label property value of the metadata to return.
             * @returns {String} The count of works in the collection.
             */
            getMetadataValue: function( collection, label) {
                if ( _debug ) {
                    console.log( '---------- _getMetadataValue() ----------' );
                    console.log( '_getMetadataValue: collection = ', collection );
                    console.log( '_getMetadataValue: label = ', label );
                }
                
                var value = '';
                
                collection.metadata.forEach( function( metadata ) {
                    if ( _getValue(metadata.label, _defaults.displayLanguage) == label ) {
                        value = _getValue(metadata.value, _defaults.displayLanguage);
                    }
                } );
                
                return value;
            },
            
            /**
             * Returns the number of subcollections of a given iiif collection json element
             * The number is based in the service defined by '<rest-url>/api/collections/extent/context.json'
             * If no matching service is available, 0 is returned
             * 
             * @param collection
             * @returns the number of subcollections of a given iiif collection json element
             */
            getChildCollections: function(collection) {
                if(collection.service && Array.isArray(collection.service)) {
                    let extents = collection.service.filter( service => service['@context'].endsWith('/collection/extent/context.json') );
                    if(extents && extents.length > 0) {
                        return extents[0].children;
                    }
                } else if(collection.service && collection.service['@context'].endsWith('/collection/extent/context.json')) {
                     return collection.service.children;
                } else {
                    return 0;
                }
            },
            
            /**
             * Returns the number of contained works of a given iiif collection json element
             * The number is based in the service defined by '<rest-url>/api/collections/extent/context.json'
             * If no matching service is available, 0 is returned
             *
             * @param collection
             * @returns the number of contained works of a given iiif collection json element
             */
            getContainedWorks: function(collection) {
                if(collection.service && Array.isArray(collection.service)) {
                    let extents = collection.service.filter( service => service['@context'].endsWith('/collection/extent/context.json') );
                    if(extents && extents.length > 0) {
                        return extents[0].containedWorks;
                    }
                } else if(collection.service && collection.service['@context'].endsWith('/collection/extent/context.json')) {
                    return collection.service.containedWorks;
                } else {
                    return 0;
                }
            },
            
            /**
             * @param collection
             * @returns the list of tags in the tag service with the given anme
             */
            getTags: function(collection, name) {
                console.log("services", collection.service);
                if(collection.service && Array.isArray(collection.service)) {
                    let tagService = collection.service.filter( service => service['@context'].endsWith('/taglists/context.json')).filter(service => service === undefined || service.name == name);
                    if(tagService && tagService.length > 0) {
                        return tagService[0].tags;
                    }
                } else if(collection.service && collection.service['@context'].endsWith('/taglists/context.json') && (service === undefined || service.name == name)) {
                    return collection.service.tags;
                } else {
                    return undefined;
                }
            },
            
            /**
             * Returns the collection's related element with the given label
             * 
             * @param collection
             * @param label
             * @returns the collection's related element with the given label
             */
            getRelated: function(collection, label) {
                if(collection.related) {
                    if(Array.isArray(collection.related)) {                
                        for(var index in collection.related) {
                            var related = collection.related[index];
                            if(related.label == label) {
                                return related;
                            }
                        }
                    } else {
                        return collection.related;
                    }
                }
            },
            
            /**
             * Return true if the given element if of type "sc:Collection" or "Collection"
             * and has no viewingHint "multi-part" (indication that it is an anchor record)
             */
            isCollection: function(element) {
                var type = element['@type'];
                var viewingHint = element.viewingHint;
                if( (type == 'sc:Collection' || type == 'Collection') && viewingHint != 'multi-part') {
                    return true;
                } else {
                    return false;
                }
            },
            
            /**
             * From the url of an annotationList, retrieve an array of all annotation resources.
             * If no annotations are found at the resource or the url could not be resolved, an empty list is returned
             * 
             */
            getAnnotations(annotationListUrl) {
                return fetch(annotationListUrl)
                .then( response => response.json() )
                // catch error in response.json()
                .then( json => json, error => undefined )
                .then( annoPage => _getItems(annoPage))
            },
            
            
            /**
             * @return the body of an annotation
             */
            getBody(anno) {
                if(anno.body) {
                    return anno.body;
                } else if(anno.resource) {
                    return anno.resource;
                } else {
                    return {};
                }
            },
            
            /**
            * @return the first found element in the "rendering" attribute with format='text/html'. Returns 'undefined' 
            * if no such element was found
            */
            getViewerPage(presentationElement) {
            	if(!presentationElement.rendering) {
            		return undefined;
            	} else if(Array.isArray(presentationElement.rendering)) {
            		return presentationElement.rendering
    					.filter(rendering => rendering.format == "text/html")
    					.shift();
    			} else if(presentationElement.rendering.format == "text/html"){
    				return presentationElement.rendering;
    			} else {
    				return undefined;
    			}
            },
            
            /**
             * @return the object in the service property which @context ends in <name>.context.json, if any
             */
            getService(manifest, name) {
                let service = manifest.service;
                if(service && Array.isArray(service)) {
                    return service.find(s => {
                        let context = service['@context'];
                        return context && context.endsWith(name + ".context.json");
                    })
                } else {
                    return service;
                }
            },
            
            isCollection(element) {
		    	return (element.type == "Collection" || element["@type"] == "sc:Collection") && element.viewingHint != "multi-part";
		    },
		    
		    isSingleManifest(element) {
		    	return (element.type == "Manifest" || element["@type"] == "sc:Manifest") ;
		    },
		    
		    isManifest(element) {
		    	return element.type == "Manifest" || 
		    	element["@type"] == "sc:Manifest" || 
		    	(element.type == "Collection" && element.viewingHint == "multi-part") ||
		    	(element["@type"] == "sc:Collection" && element.viewingHint == "multi-part");
		    },
		    
		    getId(element) {
			    if(element == undefined) {
			    	return undefined;
			    } else if(viewerJS.isString(element)) {
			    	return element;
			    } else if(element.id) {
		    		return element.id;
		    	} else {
		    		return element["@id"];	
		    	}
		    },
    }

    
    /**
     * @return all annotations within an annotation list page
     */
    function _getItems(annoPage) {
        if(!annoPage) {
            return [];
        } else if(annoPage.items) {            
            return annoPage.items
        } else if(annoPage.resources) {
            return annoPage.resources;
        } else {
            return [];
        }
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );
var viewerJS = ( function ( viewer ) {
    'use strict';

    var _debug = false;
    var _defaults = {};

    viewer.jsfAjax = {
    	/**
    	 * @description Method to initialize the jsf ajax listener.
    	 * @method init 
    	 * */
        begin: new rxjs.Subject(),
        complete: new rxjs.Subject(),
        success: new rxjs.Subject(),
        error: new rxjs.Subject(),
        handleResponse: function(success, error) {
        	this.complete
		    .pipe(rxjs.operators.first())
		    .subscribe(response => {
		        switch(response.responseCode) {
		            case 200:
		            	if(success) {
				        	success(response);
						}		            	
						break;
					default:
						if(error) {
						    error(response);
						}						
		        }
		    });
        },
    	init: function( config ) {
    		if (_debug) {
    		    console.log( 'Initializing: viewerJS.jsfAjax.init' );
    		    console.log( '--> config = ', config );
    		}
    		
    		$.extend( true, _defaults, config );
    		// listen to jsf ajax event
            if ( typeof jsf !== 'undefined' ) {
                jsf.ajax.addOnEvent( ( data ) => {
                    if ( _debug ) {
                        console.log( 'JSF AJAX - data: ', data );
                    }
                    
                    var ajaxloader = document.getElementById( "AJAXLoader" );
                    switch ( data.status ) {
                        case 'begin': 
                        	if ( ajaxloader ) {
                        		ajaxloader.style.display = 'block';                        		
                        	}
                        	this.begin.next(data);
                        	break;
                        case 'complete':
                        	if ( ajaxloader ) {                        		
                        		ajaxloader.style.display = 'none';
                        	}
                        	this.complete.next(data);
                        	break;
                        case 'success':
                        	// init Bootstrap features
                            viewerJS.helper.initBsFeatures();
                            // init tinyMCE
                            let isTiny = data.responseText.includes("tinyMCE");
                            if(isTiny) {
//                            if ( $( '.tinyMCE' ).length > 0 ) {
                                viewerJS.tinyMce.close();
                                viewerJS.tinyMce.init( viewerJS.tinyConfig );
                            }
                            this.success.next(data);
                            break;
                        case 'error':
                            this.error.next(data);
                            break;
                            
                    }
                });
            }
    	}
    }

    return viewer;

} )( viewerJS || {}, jQuery );
    
var viewerJS = (function(viewer) {
	'use strict';

	// default variables
	const _debug = false;

	const ignoredProperties = ["jsonSignature"];

	viewer.jsonValidator = {

		validate: function(obj, signature) {
			
			if(!signature && obj.hasOwnProperty("jsonSignature")) {
				signature = obj.jsonSignature;
			}
			
			// Check if the given object and signature are both objects
			if (typeof obj !== 'object' || typeof signature !== 'object' || obj === null || signature === null) {
				throw new Error('Both parameters must be objects.');
			}

			// Iterate through the signature properties
			for (let key in signature) {
				// Check if the property exists in the object
				if (signature.hasOwnProperty(key)) {
					// Check if the property type matches the signature
					if (obj[key] !== undefined && obj[key] !== null && typeof obj[key] !== signature[key]) {
						return false;
					}
				}
			}

			// Check for any extra properties in the object not defined in the signature
			for (let key in obj) {
				if(!ignoredProperties.includes(key)) {
					if (obj.hasOwnProperty(key) && !signature.hasOwnProperty(key)) {
						return false;
					}
				}
			}

			// If all checks pass, the object conforms to the signature
			return true;
		}

	}

	return viewer;

})(viewerJS || {}, jQuery);
var viewerJS = ( function( viewer ) {
    'use strict';
    
    const _debug = false;

    /**
     * Create a new Leaflet object using new viewerJS.Leaflet(config)
     * @params config   object which should contain the following properties:
     * <ul>
     * <li> msg.propertiesLink - message to display on popover when hovering a location marker. If this doesn't exist, no popover is rendered</li>
     * <li> widgetSelector - dom selector for the map element. If this is given and no annotations are loaded, the element found under this selector is hidden on the first call to #load(url)</li>
     * <li> mapId - The id of the container element for the leaflet map. must be given to initialize the map. </li>
     * </ul>
     */
    viewer.Leaflet = function(config) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'viewer.leaflet.init' );
            console.log( '##############################' );
            console.log( 'viewer.leaflet.init: config = ', config );
        }
        
        this.config = config;
        this.map = null;
        this.markers = [];
            
    };
    
    /**
     * Load GeoJson data from the given url. The url must return a json object with a list property items or resources containing objects which
     * in turn contain the GeoJson in their body or resource property.
     * 
     * @param url   The url to load the GeoJson data from. Typically an IIIF AnnotationList or a WebAnnotation AnnotationPge
     */
    viewer.Leaflet.prototype.load = function(url) {
        fetch(url)
        .then( response => response.json() )
        // catch error in response.json()
        .then( json => json, error => undefined )
        .then( annoPage => _getItems(annoPage))
        .then( locations => {
            locations = locations.filter( loc => _getBody(loc).type === "Feature");
            if(_debug) console.log("Loaded GeoJson locations ", locations);
            if(locations.length > 0) {
                if(!this.map) {           
                    if(_debug) console.log("initialize map");
                    this.map = _initMap(this.config);
                    if(_debug) console.log("set view to ",  _getBody(locations[0]).view);
                    _setView(this.map, _getBody(locations[0]).view);
                }
                this.markers = this.markers.concat(_addMarkers(this.map, locations, this.config.msg ? this.config.msg.propertiesLink : undefined));
            } 
            if(this.config.widgetSelector) {                
                if(!this.map) {
                    if(_debug) console.log("hide map");
                    $(this.config.widgetSelector).hide();
                } else if($(this.config.widgetSelector).is(":hidden")) {
                    if(_debug) console.log("show map");
                    $(this.config.widgetSelector).show();
                    this.map.invalidateSize();
                }
            }
        })
        .catch(error => {
            console.log("error getting json response ", error);
        })
    }
    
    function _getBody(anno) {
        if(anno.body) {
            return anno.body;
        } else if(anno.resource) {
            return anno.resource;
        } else {
            return {};
        }
    }
    
    function _getItems(annoPage) {
        if(!annoPage) {
            return [];
        } else if(annoPage.items) {            
            return annoPage.items
        } else if(annoPage.resources) {
            return annoPage.resources;
        } else {
            return [];
        }
    }
    
    function _setView(map, view) {
        map.setView(new L.LatLng(view.center[0], view.center[1]), view.zoom);
    }
    
    function _initMap(config) {
        let map = new L.Map(config.mapId);
        var osm = new L.TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          minZoom: 0,
          maxZoom: 20,
//          attribution: 'Map data &copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
        });
     
        // define view
        map.setView(new L.LatLng(49.451993, 11.073397), 5);
        map.addLayer(osm);
        return map;
    }
    
    function _addMarkers(map, annotations, popupText) {
        let markers = new Map();
        annotations.forEach( anno => {
            let geoJson = _getBody(anno);
            var marker = L.geoJSON(geoJson).addTo(map);
            if(popupText) {                
                marker.bindPopup(popupText);
                marker.on("mouseover", function() {
                    this.openPopup();
                })
                marker.on("mouseout", function() {
                    this.closePopup();
                })
            }
            markers.set(anno, marker);

        })
        return markers;
    }
    
    

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = (function (viewer) {
    'use strict';

    var _debug = false;

    viewer.listFilter = function (config) {
        if (_debug) {
            console.log('##############################');
            console.log('viewer.listFilter.init');
            console.log('##############################');
            console.log('viewer.listFilter.init: config - ', config);
        }

        this.config = config;
        this.enable();
        
        // toggle filter input
        
        this.config.inputToggle.on("click", event => {
        	event.stopImmediatePropagation();

        	var $input = this.config.input;
        	
        	if ( !$input.hasClass( 'in' ) ) {
        		this.resetFilters();        		
        	}
        	
        	$input.toggleClass( 'in' ).focus();        	
        	
        	if ( $input.val() !== '' ) {
        		$input.val( '' ).trigger( 'input' );
        	}
		})
		
		this.config.header.on("click", event => {
        	event.stopImmediatePropagation();
        	
        	var $input = this.config.input;
        	
        	this.resetFilters();
        	
        	$input.toggleClass( 'in' ).focus();
        	
        	if ( $input.val() !== '' ) {
        		$input.val( '' ).trigger( 'input' );
        	}
        } );

        this.config.input.on("keyup", event => {
			if(event.keyCode == 27) {
				this.resetFilters();
			}
		});
        
        // reset filter on body click
        $( 'body' ).on( 'click', event => {
        	if ( $( '.widget-search-facets__filter-input' ).hasClass( 'in' ) ) {
        		if ( event.target.id == 'searchListFacetsWrapper' || $( event.target ).closest( '#searchListFacetsWrapper' ).length ) {
                    return;
                }
                else {
                	this.resetFilters();
                }
        	}
        } );
        
    }

    /**
     * @description Method to reset all other filter when clicking another one.
     * @method _resetFilters
     * */
    viewer.listFilter.prototype.resetFilters = function() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _resetFilters' );
    	}
		if ( this.config.input.hasClass( 'in' ) ) {
			this.config.input.removeClass( 'in' ).val( '' ).trigger( 'input' );
			this.config.elements.show();
		}
    }

    // set event for input
    viewer.listFilter.prototype.initListener = function () {
        this.observer = rxjs.fromEvent( this.config.input, 'input' )
            .pipe(rxjs.operators.debounceTime( 200 ))
            .subscribe( event => this.filter( event ) );
    }

    // remove events
    viewer.listFilter.prototype.removeListener = function () {
        if ( this.observer ) {
            this.observable.unsubscribe();
        }
    }

    // filter results
    viewer.listFilter.prototype.filter = function ( event ) {
        let value = $( this.config.input ).val().trim().toLowerCase();
        
        if ( value ) {
            if ( _debug ) {
                console.log( "filter for input", value, " in ", $( this.config.elements ) );
            }
            
            $( this.config.elements ).each( ( index, element ) => {
                let $element = $( element );
                let elementText = $element.find("a").text().trim().toLowerCase();
                
                if ( elementText.includes( value ) ) {
                    $element.show();
                } else {
                    $element.hide();
                }
            } );
        } 
        else {
            $( this.config.elements ).show();
        }
    }

    // unfilter elements
    viewer.listFilter.unfilter = function () {
        $( this.config.input ).val( '' );
        $( this.config.elements ).show();
    }

    // enable filter
    viewer.listFilter.prototype.enable = function () {
        $( this.config.wrapper ).show();
        this.initListener();
    }

    // disable filter
    viewer.listFilter.prototype.disable = function () {
        $( this.config.input ).val( '' );
        $( this.config.wrapper ).hide();
        this.removeListener();
    }

    return viewer;

} )( viewerJS || {}, jQuery );
    
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var idPattern = /.*\/mirador\/id\/(\d+)\/?/i;
    var keyPattern = /.*\/mirador\/key\/(\w+)\/?/i;
    
    // variables
    var _debug = false;
    var _sessionBookmarkList = '';
    var _defaults = {
    	root: '',
    	restEndpoint: undefined,
    	manifestEndpoint: undefined,
    	userLoggedIn: false,
    	bookmarkListId: null,
    };
    
    var dataObject = {
        location: "Goobi viewer" 
    }
    var windowObject = {
        thumbnailNavigationPosition: 'far-bottom',    
        canvasIndex: 0,
    }
    
    var messageKeys = ["viewMirador", "viewMiradorComparison"];

    viewer.mirador = {
        /**
         * Method to initialize the mirador viewer.
         * 
         * @method init
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.mirador.init' );
                console.log( '##############################' );
                console.log( 'viewer.mirador.init: config - ', config );
            }
            
            this.config = $.extend( true, {}, _defaults, config );
            if(!this.config.manifestEndpoint) {
            	this.config.manifestEndpoint = this.config.restEndpoint;
            }
            if(this.config.startPage == undefined) {				
	            const startPage = _getPageFromQueryParameter();
	            if(startPage) {
					this.config.startPage = startPage;
				}
			}
            
            
            var manifests = _getManifestsFromUrlQuery(this.config);
            
            var translator = new viewerJS.Translator(this.config.restEndpoint, "#{navigationHelper.localeString}");
            
            let miradorConfigPromise = null;
            if (manifests.length > 0) {
            	// URL identifiers
				console.log("loading manifests ", manifests);
                miradorConfigPromise = _getMiradorConfigForManifestUrls(manifests, this.config);
            } else if ( _getBookmarkListId() != null ) {
            	// User bookmarks
            	console.log("Load bookmarklist ", _getBookmarkListId())
                miradorConfigPromise = _getUserMiradorObjects( this.config.restEndpoint, _getBookmarkListId() )
                .then( response => response.json())
                .then( json => json.members.filter(manifest => manifest["@type"] == "sc:Manifest" || manifest.type == "Manifest") )
                //.then( members => members.map(manifest => manifest["@id"] ? manifest["@id"] : manifest.id).filter(id => id != undefined) )
                .then( members => _getMiradorConfigForManifestUrls(members, this.config) );
            } else if ( _getBookmarkListKey() != null ) {
                //public/shared bookmarks
                console.log("Load bookmarklist with key ", _getBookmarkListKey())
                miradorConfigPromise = _getSharedMiradorObjects( this.config.restEndpoint, _getBookmarkListKey() )
                .then( response => response.json())
                .then( json => json.members.filter(manifest => manifest["@type"] == "sc:Manifest" || manifest.type == "Manifest") )
//                .then( members => members.map(manifest => manifest["@id"] ? manifest["@id"] : manifest.id).filter(id => id != undefined) )
                .then( ids => _getMiradorConfigForManifestUrls(ids, this.config) );
            } else if(_getBookmarkListId() !== null) {
            	// Session mark list
            	console.log("load session bookmark list")
                miradorConfigPromise = _getMiradorSessionObjects( this.config.restEndpoint )
                .then( response => response.json())
                .then( json => json.members.filter(manifest => manifest["@type"] == "sc:Manifest" || manifest.type == "Manifest") )
                //.then( members => members.map(manifest => manifest["@id"] ? manifest["@id"] : manifest.id).filter(id => id != undefined) )
                .then( ids => _getMiradorConfigForManifestUrls(ids, this.config) );
            } else {
				console.log("TODO: Load empty Mirador");
				miradorConfigPromise = Promise.resolve({
					id: "miradorViewer"
				});
			}
            
            if(miradorConfigPromise) {  
                miradorConfigPromise       
                .then( elements => {            
						      
                        this.miradorConfig = elements;
                        this.mirador = Mirador.viewer(this.miradorConfig);
                })
                .then(() => translator.init(messageKeys))
                .then( () => {
                    // Override window title if more than one record
                    if (this.miradorConfig.manifests.length > 1) {
                        document.title = translator.translate('viewMiradorComparison');
                    }
                }).catch(function(error) {
                    console.error('ERROR - _getMiradorObjects: ', error);
                });
            } else {
                console.error("ERROR - no manifests to load");
            }
        }
    };
    
    
    function _getBookmarkListId() {
        let location = window.location.href;
        if(location.match(idPattern)) {
            let id = location.match(idPattern)[1];
            return id;
        }
        return null;
    }
    
    function _getBookmarkListKey() {
        let location = window.location.href;
        if(location.match(keyPattern)) {
            let key = location.match(keyPattern)[1];
            return key;
        }
        return null;
    }
    
    /* ######## GET (READ) ######## */
    /**
	 * Method to get the mirador objects.
	 * 
	 * @method _getMiradorObjects
	 * @param {String} root The application root path.
	 * @returns {Object} An JSON-Object which contains all session elements.
	 */
	function _getUserMiradorObjects( restUrl, id ) {
		if ( _debug ) { 
			console.log( '---------- _getSessionElementCount() ----------' );
			console.log( '_getSessionElementCount: restUrl - ', restUrl );
			console.log( '_getSessionElementCount: id - ', id );
		}

		let url = restUrl + "bookmarks/" + id + "/collection.json";
		return fetch(url);
	}
	
	   function _getSharedMiradorObjects( restUrl, key ) {
	        if ( _debug ) { 
	            console.log( '---------- _getSharedMiradorObjects() ----------' );
	            console.log( '_getSessionElementCount: restUrl - ', restUrl );
	            console.log( '_getSessionElementCount: id - ', key );
	        }

	        let url = restUrl + "bookmarks/shared/" + key + "/collection.json";
	        return fetch(url);
	    }
	/**
	 * Method to get the mirador session objects.
	 * 
	 * @method _getMiradorSessionObjects
	 * @param {String} root The application root path.
	 * @returns {Object} An JSON-Object which contains all session elements.
	 */
	function _getMiradorSessionObjects( restUrl ) {
		if ( _debug ) { 
			console.log( '---------- _getMiradorSessionObjects() ----------' );
			console.log( '_getMiradorSessionObjects: root - ', root );
		}
		
		let url = restUrl + "bookmarks/0/collection.json";
        return fetch(url);
	}

	
	function _getManifestsFromUrlQuery(config) {
        var manifests = _getQueryVariables("manifest");
        var pis = _getQueryVariables("pi");
        var piManifests = pis.map(pi => config.manifestEndpoint + "records/" + pi + "/manifest/");
        manifests = manifests.concat(piManifests);
        return manifests;
	}
	
	function _getQueryVariables(variable) {
		const params = new URLSearchParams(window.location.search);
		return params.getAll(variable).flatMap(s => s.split(/[,$]/)).filter(s => s && s.length > 0);
	}
	
	function _getPageFromQueryParameter()  {
				let query = window.location.search;
				let params = new URLSearchParams(query);
				let page = params.get("page");
				return page;
			}	
	   
    function _getMiradorConfigForManifestUrls(manifests, config) {
        var columns = Math.ceil(Math.sqrt(manifests.length));
        var rows = Math.ceil(manifests.length/columns);
        var miradorConfig = { 
                id: "miradorViewer",
                manifests: manifests.map(man => {
                    var dataObj = Object.assign({}, dataObject);
                    dataObj.manifestUri = viewerJS.iiif.getId(man);
                    return dataObj;
                }),
                windows: manifests.map(man => {
                    var winObj = Object.assign({}, windowObject);
                    if(config.startPage) {
						winObj.canvasIndex = config.startPage-1;
					} else if(man.sequences && man.sequences.length > 0 && man.sequences[0].startCanvas) {
                    	let startId = man.sequences[0].startCanvas["@id"];
                    	let match = startId.match(/pages\/(\d+)\/canvas/);
                    	if(match && match.length > 1) {
                    		let pageNo = parseInt(match[1]);
                    		winObj.canvasIndex = pageNo-1;
                    	}
                    }
                    winObj.loadedManifest = viewerJS.iiif.getId(man);
                    return winObj;
                }),
                window: {
                	defaultView: 'single'
                },
                annotations: {  
             		//'sc:painting' and 'supplementing' excluded to hide fulltext annotations
             		//'oa:describing' must be included to display viewer (crowdsourcing) annotations
            	    filteredMotivations: ['oa:commenting', 'oa:tagging','oa:describing', 'commenting', 'tagging', 'describing'],
                }
        }
        return Promise.resolve(miradorConfig);
    }

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function ( viewer ) {
    'use strict';

    var _debug = false;

    viewer.mobileToggles = {
    	/**
    	 * @description Method to initialize the mobile toggle features.
    	 * @method init 
    	 * */
    	init: function( config ) {
    		if (_debug) {
    			console.log( 'Initializing: viewerJS.mobileToggles.init' );
    		}
    		
    		// off canvas
            $( '[data-toggle="offcanvas"]' ).on( 'click', function() {
                var icon = $( this ).children( '.fa' );
                
                $( '.row-offcanvas' ).toggleClass( 'active' );
                $( this ).toggleClass( 'in' );
                
                if ( icon.hasClass( 'fa-ellipsis-v' ) ) {
                    icon.removeClass( 'fa-ellipsis-v' ).addClass( 'fa-ellipsis-h' );
                }
                else {
                    icon.removeClass( 'fa-ellipsis-h' ).addClass( 'fa-ellipsis-v' );
                }
            } );
            
            // toggle mobile navigation
            $( '[data-toggle="mobilenav"]' ).on( 'click', function() {
                $( '.btn-toggle.search' ).removeClass( 'in' );
                $( '.header-actions__search' ).hide();
                $( '.btn-toggle.language' ).removeClass( 'in' );
                $( '#mobileNav' ).slideToggle( 'fast' );
            } );
            $( '[data-toggle="mobile-image-controls"]' ).on( 'click', function() {
                $( '.image-controls' ).slideToggle( 'fast' );
            } );
            
            // toggle language
            $( '[data-toggle="language"]' ).on( 'click', function() {
                $( '.btn-toggle.search' ).removeClass( 'in' );
                $( '.header-actions__search' ).hide();
                $( this ).toggleClass( 'in' );
                $( '#changeLocal' ).fadeToggle( 'fast' );
            } );
            
            // toggle search
            $( '[data-toggle="search"]' ).on( 'click', function() {
                $( '.btn-toggle.language' ).removeClass( 'in' );
                $( '#changeLocal' ).hide();
                $( this ).toggleClass( 'in' );
                $( '.header-actions__search' ).fadeToggle( 'fast' );
            } );
    	}
    }

    return viewer;

} )( viewerJS || {}, jQuery );
    
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
        navigationSelector: '#navigation',
        subMenuSelector: '[data-toggle="submenu"]',
        megaMenuSelector: '[data-toggle="megamenu"]',
        closeMegaMenuSelector: '[data-toggle="close"]',
    };
    
    viewer.navigation = {
    
    
        /**
         * Method to initialize the viewer main navigation.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.navigationSelector The selector for the navigation
         * element.
         * @param {String} config.subMenuSelector The selector for the submenu element.
         * @param {String} config.megaMenuSelector The selector for the mega menu element.
         * @param {String} config.closeMegaMenuSelector The selector for the close mega
         * menu element.
         */
        init : function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.navigation.init' );
                console.log( '##############################' );
                console.log( 'viewer.navigation.init: config - ', config );
            }
            
            config = $.extend( true, _defaults, config, {});
            // TRIGGER STANDARD MENU
            $( config.subMenuSelector ).on( 'click', function() {
                var currTrigger = $( this ); 
                if( $(currTrigger).next( '.navigation__submenu' ).hasClass( 'in' ) ) {
                    //child menu is open
                    $(currTrigger).next( '.navigation__submenu' ).removeClass( 'in' );
                    $(currTrigger).parent().removeClass( 'active' );
                }else if ( $( currTrigger ).parents( '.navigation__submenu' ).hasClass( 'in' ) ) {
                    _resetSubMenus();
                    currTrigger.parent().addClass( 'active' );
                    currTrigger.next( '.navigation__submenu' ).addClass( 'in' );
                    _calcSubMenuPosition( currTrigger.next( '.navigation__submenu' ) );
                } else {
                    _resetMenus();
                    // console.log("open submenu", currTrigger.parent());
                    currTrigger.parent().addClass( 'active' );
                    currTrigger.next( '.navigation__submenu' ).addClass( 'in' );
                }
            } );
            
            // TRIGGER MEGA MENU
            $( config.megaMenuSelector ).on( 'click', function() {
                _resetMenus();
                
                if ( $( this ).next( '.navigation__megamenu-wrapper' ).hasClass( 'in' ) ) {
                    $( this ).parent().removeClass( 'active' );
                    $( this ).next( '.navigation__megamenu-wrapper' ).removeClass( 'in' );
                }
                else {
                    $( '.navigation__megamenu-trigger' ).removeClass( 'active' );
                    $( '.navigation__megamenu-wrapper' ).removeClass( 'in' );
                    $( this ).parent().addClass( 'active' );
                    $( this ).next( '.navigation__megamenu-wrapper' ).addClass( 'in' );
                }
            } );
            
            $( config.closeMegaMenuSelector ).on( 'click', function() {
                _resetMenus();
            } );
            
            if ( $( '.navigation__megamenu-wrapper' ).length > 0 ) {
                _resetMenus();
            }
            
            // reset all menus by clicking on body
            $( 'body' ).on( 'click', function( event ) {
                if ( event.target.id == 'navigation' || $( event.target ).closest( config.navigationSelector ).length ) {
                    return;
                }
                else {
                    _resetMenus();
                }
            } );
        },
     };
    
    /**
     * Method to reset all shown menus.
     * 
     * @method _resetMenus
     */
    function _resetMenus() {
        if ( _debug ) {
            console.log( '---------- _resetMenus() ----------' );
        }
        
        $( '.navigation__submenu-trigger' ).removeClass( 'active' );
        $( '.navigation__submenu' ).removeClass( 'in' );
        $( '.navigation__megamenu-trigger' ).removeClass( 'active' );
        $( '.navigation__megamenu-wrapper' ).removeClass( 'in' );
    }
    
    /**
     * Method to reset all shown submenus.
     * 
     * @method _resetSubMenus
     */
    function _resetSubMenus() {
        $( '.level-2, .level-3, .level-4, .level-5' ).parent().removeClass( 'active' );
        $( '.level-2, .level-3, .level-4, .level-5' ).removeClass( 'in' ).removeClass( 'left' );
        
    }
    
    /**
     * Method to calculate the position of the shown submenu.
     * 
     * @method _calcSubMenuPosition
     * @param {Object} menu An jQuery object of the current submenu.
     */
    function _calcSubMenuPosition( menu ) {
        if ( _debug ) {
            console.log( '---------- _clacSubMenuPosition() ----------' );
            console.log( '_clacSubMenuPosition: menu - ', menu );
        }
        
        var currentOffsetLeft = menu.offset().left;
        var menuWidth = menu.outerWidth();
        var windowWidth = $( window ).outerWidth();
        var offsetWidth = currentOffsetLeft + menuWidth;
        
        if ( _debug ) {
            console.log( '_clacSubMenuPosition: currentOffsetLeft - ', currentOffsetLeft );
            console.log( '_clacSubMenuPosition: menuWidth - ', menuWidth );
            console.log( '_clacSubMenuPosition: windowWidth - ', windowWidth );
            console.log( '_clacSubMenuPosition: offsetWidth - ', offsetWidth );
        }
        
        if ( offsetWidth >= windowWidth ) {
            menu.addClass( 'left' ).css( 'width', menuWidth );
        }
        else {
            return false;
        }
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _json = null;
    var _apiCall = '';
    var _html = '';
    var _pageCount = 0;
    var _scaleCount = 0;
    var _scaleHeight = 0;
    var _sliderHandlePosition = {};
    var _movedSliderHandlePosition = 0;
    var _recurrenceCount = 0;
    var _scaleValue = 0;
    var _sliderScaleHeight = 0;
    var _start = 0;
    var _end = 0;
    var _currentNerPageRangeSelected = '';
    var _currentNerPageRange = '';
    var _currentNerType = '';
    var _promise = null;
    var _defaults = {
        currentPage: '',
        baseUrl: '',
        apiUrl: '/api/v1/records/',
        workId: '',
        overviewTrigger: '',
        overviewContent: '',
        sectionTrigger: '',
        sectionContent: '',
        facettingTrigger: '',
        setTagRange: '',
        slider: '',
        sliderScale: '',
        sectionTags: '',
        currentTags: '',
        sliderHandle: '',
        sliderSectionStripe: '',
        recurrenceNumber: 0,
        recurrenceSectionNumber: 0,
        sidebarRight: false,
        loader: '',
        msg: {
            noJSON: 'Es konnten keine Daten abgerufen werden.',
            emptyTag: 'Keine Tags vorhanden',
            page: 'Seite',
            tags: 'Tags',
        }
    };
    
    viewer.nerFacetting = {
        /**
         * Method to initialize the NER-Widget or NER-View.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.currentPage The name of the current page.
         * @param {String} config.baseUrl The root URL.
         * @param {String} config.apiUrl The base URL for the API-Calls.
         * @param {String} config.workId The ID of the current work.
         * @param {String} config.overviewTrigger The ID/Class of the overview trigger.
         * @param {String} config.overviewContent The ID/Class of the content section from
         * overview.
         * @param {String} config.sectionTrigger The ID/Class of the section trigger.
         * @param {String} config.sectionContent The ID/Class of the content section from
         * section.
         * @param {String} config.facettingTrigger The ID/Class of the facetting trigger.
         * @param {String} config.setTagRange The ID/Class of the select menu for the
         * range.
         * @param {String} config.slider The ID/Class of the tag range slider.
         * @param {String} config.sliderScale The ID/Class of the slider scale.
         * @param {String} config.sectionTags The ID/Class of the tag section.
         * @param {String} config.currentTags The ID/Class of the tag container.
         * @param {String} config.sliderHandle The ID/Class of the slider handle.
         * @param {String} config.sliderSectionStripe The ID/Class of the range stripe on
         * the slider.
         * @param {Number} config.recurrenceNumber The number of displayed tags in a row.
         * @param {Number} config.recurrenceSectionNumber The number of displayed tags in
         * a section.
         * @param {Boolean} config.sidebarRight If true, the current tag row will show up
         * to the left of the sidebar widget.
         * @param {String} config.loader The ID/Class of the AJAX-Loader.
         * @param {Object} config.msg An object of strings for multi language use.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.nerFacetting.init' );
                console.log( '##############################' );
                console.log( 'viewer.nerFacetting.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            if ( viewer.localStoragePossible ) {
                // show loader
                $( _defaults.loader ).show();
                
                // clean local storage
                _cleanUpLocalStorage();
                
                // reset select menu
                $( _defaults.setTagRange ).find( 'option' ).attr( 'selected', false );
                
                if ( _defaults.currentPage === 'nerfacetting' ) {
                    $( _defaults.setTagRangeOverview ).find( 'option[value="1"]' ).prop( 'selected', true );
                }
                else {
                    $( _defaults.setTagRangeOverview ).find( 'option[value="10"]' ).prop( 'selected', true );
                }
                
                // reset facetting icons
                _resetFacettingIcons();
                
                // get data for current work
                if ( _defaults.currentPage === 'nerfacetting' ) {
                    _apiCall = _getAllTagsOfARange( 1, '-' );
                }
                else {
                    _apiCall = _getAllTagsOfARange( 10, '-' );
                }
                
                _promise = viewer.helper.getRemoteData( _apiCall );
                
                _promise.then( function( json ) {
                    _json = json;
                    
                    // check if data is not empty
                    if ( _json !== null || _json !== 'undefinded' ) {
                        // check if overview is already loaded
                        if ( $( _defaults.overviewContent ).html() === '' ) {
                            _renderOverview( _json );
                        }
                    }
                    else {
                        _html = viewer.helper.renderAlert( 'alert-danger', _defaults.msg.noJSON + '<br /><br />URL: ' + _apiCall, true );
                        $( _defaults.overviewContent ).html( _html );
                    }
                } ).then( null, function( error ) {
                    $( '.facetting-content' ).empty().append( viewer.helper
                            .renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' ' + error.statusText, false ) );
                    console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                } );
                
                /**
                 * Event if overview tab is clicked.
                 */
                $( _defaults.overviewTrigger ).on( 'click', function() {
                    // show loader
                    $( _defaults.loader ).show();
                    
                    // resets
                    $( _defaults.setTagRange ).find( 'option' ).attr( 'selected', false );
                    
                    if ( _defaults.currentPage === 'nerfacetting' ) {
                        $( _defaults.setTagRangeOverview ).find( 'option[value="1"]' ).prop( 'selected', true );
                        sessionStorage.setItem( 'currentNerPageRange', '1' );
                    }
                    else {
                        $( _defaults.setTagRangeOverview ).find( 'option[value="10"]' ).prop( 'selected', true );
                        sessionStorage.setItem( 'currentNerPageRange', '10' );
                    }
                    _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
                    
                    sessionStorage.setItem( 'currentNerType', '-' );
                    _currentNerType = sessionStorage.getItem( 'currentNerType' );
                    
                    _resetFacettingIcons();
                    
                    // check if tab is active
                    if ( $( this ).parent().hasClass( 'active' ) ) {
                        console.info( 'Overview is already active.' );
                    }
                    else {
                        if ( _defaults.currentPage === 'nerfacetting' ) {
                            _apiCall = _getAllTagsOfARange( 1, '-' );
                        }
                        else {
                            _apiCall = _getAllTagsOfARange( 10, '-' );
                        }
                        
                        _promise = viewer.helper.getRemoteData( _apiCall );
                        
                        _promise.then( function( json ) {
                            _json = json;
                            _renderOverview( _json );
                        } ).then( null, function( error ) {
                            $( '.facetting-content' ).empty().append( viewer.helper.renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' '
                                    + error.statusText, false ) );
                            console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                        } );
                        
                    }
                } );
                
                /**
                 * Event if section tab is clicked.
                 */
                $( _defaults.sectionTrigger ).on( 'click', function() {
                    // show loader
                    $( _defaults.loader ).show();
                    
                    // reset select menu
                    $( _defaults.setTagRange ).find( 'option' ).attr( 'selected', false );
                    
                    if ( _defaults.currentPage === 'nerfacetting' ) {
                        $( _defaults.setTagRangeSection ).find( 'option[value="5"]' ).prop( 'selected', true );
                    }
                    else {
                        $( _defaults.setTagRangeSection ).find( 'option[value="10"]' ).prop( 'selected', true );
                    }
                    
                    // reset facetting
                    _resetFacettingIcons()

                    // set local storage value
                    if ( _defaults.currentPage === 'nerfacetting' ) {
                        sessionStorage.setItem( 'currentNerPageRange', 5 );
                    }
                    else {
                        sessionStorage.setItem( 'currentNerPageRange', 10 );
                    }
                    _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
                    sessionStorage.setItem( 'currentNerType', '-' );
                    _currentNerType = sessionStorage.getItem( 'currentNerType' );
                    
                    // check if tab is active
                    if ( $( this ).parent().hasClass( 'active' ) ) {
                        console.info( 'Section is already active.' );
                    }
                    else {
                        _renderSection();
                        
                        // reset section stripe
                        $( _defaults.sliderSectionStripe ).css( 'top', '0px' );
                    }
                } );
                
                /**
                 * Event if select menu changes.
                 */
                $( _defaults.setTagRange ).on( 'change', function() {
                    var currVal = $( this ).val();
                    _currentNerType = sessionStorage.getItem( 'currentNerType' );
                    
                    // show loader
                    $( _defaults.loader ).show();
                    
                    // save current value in local storage
                    sessionStorage.setItem( 'currentNerPageRange', currVal );
                    _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
                    
                    // render overview
                    if ( $( this ).hasClass( 'overview' ) ) {
                        if ( _currentNerType === null || _currentNerType === '' ) {
                            _currentNerType = '-';
                        }
                        _apiCall = _getAllTagsOfARange( currVal, _currentNerType );
                        
                        _promise = viewer.helper.getRemoteData( _apiCall );
                        
                        _promise.then( function( json ) {
                            _json = json;
                            
                            // check if data is not empty
                            if ( _json !== null || _json !== 'undefinded' ) {
                                _renderOverview( _json );
                            }
                            else {
                                _html = viewer.helper.renderAlert( 'alert-danger', _defaults.msg.noJSON + '<br /><br />URL: ' + _apiCall, true );
                                $( _defaults.overviewContent ).html( _html );
                            }
                        } ).then( null, function( error ) {
                            $( '.facetting-content' ).empty().append( viewer.helper.renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' '
                                    + error.statusText, false ) );
                            console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                        } );
                    }
                    // render section
                    else {
                        // setup values
                        sessionStorage.setItem( 'currentNerPageRange', currVal );
                        _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
                        
                        _renderSection();
                        
                        // reset section stripe
                        if ( _currentNerPageRange > _pageCount ) {
                            $( _defaults.sliderSectionStripe ).css( {
                                'top': '0px',
                                'height': '600px'
                            } );
                        }
                        else {
                            $( _defaults.sliderSectionStripe ).css( {
                                'top': '0px',
                                'height': '100px'
                            } );
                        }
                    }
                    
                } );
                
                /**
                 * Event if facetting icons are clicked.
                 */
                $( _defaults.facettingTrigger ).on( 'click', function() {
                    var currType = $( this ).attr( 'data-type' );
                    
                    // show loader
                    $( _defaults.loader ).show();
                    
                    // set values
                    sessionStorage.setItem( 'currentNerType', currType );
                    _currentNerType = sessionStorage.getItem( 'currentNerType' );
                    
                    if ( _defaults.currentPage === 'nerfacetting' ) {
                        if ( _currentNerPageRange == null || _currentNerPageRange === '' ) {
                            _currentNerPageRange = sessionStorage.setItem( 'currentNerPageRange', 1 );
                        }
                    }
                    else {
                        if ( _currentNerPageRange == null || _currentNerPageRange === '' ) {
                            _currentNerPageRange = sessionStorage.setItem( 'currentNerPageRange', 10 );
                        }
                    }
                    _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
                    
                    // activate icons
                    $( '.facetting-trigger' ).removeClass( 'active' );
                    $( this ).addClass( 'active' );
                    $( '.reset-filter' ).show();
                    
                    // filter overview
                    if ( $( this ).parent().parent().parent().attr( 'id' ) === 'overview' ) {
                        // setup data
                        _apiCall = _getAllTagsOfARange( _currentNerPageRange, _currentNerType );
                        
                        _promise = viewer.helper.getRemoteData( _apiCall );
                        
                        _promise.then( function( json ) {
                            _json = json;
                            
                            _renderOverview( _json );
                            
                            // hide select all
                            if ( $( this ).parent().hasClass( 'reset-filter' ) ) {
                                $( this ).parent().hide();
                            }
                            // set icons to active if "all" is selected
                            if ( _currentNerType === '-' ) {
                                $( '.facetting-trigger' ).addClass( 'active' );
                            }
                        } ).then( null, function( error ) {
                            $( '.facetting-content' ).empty().append( viewer.helper.renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' '
                                    + error.statusText, false ) );
                            console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                        } );
                    }
                    // filter section
                    else {
                        _renderSection();
                        
                        // hide select all
                        if ( $( this ).parent().hasClass( 'reset-filter' ) ) {
                            $( this ).parent().hide();
                        }
                        // set icons to active if "all" is selected
                        if ( _currentNerType === '-' ) {
                            $( '.facetting-trigger' ).addClass( 'active' );
                        }
                        // reset section stripe
                        $( _defaults.sliderSectionStripe ).css( 'top', '0px' );
                    }
                    
                } );
            }
            else {
                $( '.facetting-content' ).empty().append( viewer.helper
                        .renderAlert( 'alert-danger', '<strong>Deactivated: </strong>Not possible to write in local Storage!', false ) );
            }
        }
    };
    
    /**
     * Method to render the NER overview.
     * 
     * @method _renderOverview
     * @param {Object} data A JSON-Object.
     * @returns {Sting} A HTML-String which renders the overview.
     */
    function _renderOverview( data ) {
        if ( _debug ) {
            console.log( '---------- _renderOverview() ----------' );
            console.log( '_renderOverview: data = ', data );
        }
        
        _html = '';
        _html += '<ul class="overview-scale">';
        
        // render page number
        $.each( data.pages, function( p, page ) {
            _html += '<li>';
            _html += '<div class="page-number">';
            if ( data.rangeSize == 1 ) {
                if ( _defaults.currentPage === 'nerfacetting' ) {
                    _html += '<a href="' + _defaults.baseUrl + '/image/' + _defaults.workId + '/' + page.pageOrder + '/">';
                }
                else {
                    _html += '<a href="' + _defaults.baseUrl + '/' + _defaults.currentPage + '/' + _defaults.workId + '/' + page.pageOrder + '/">';
                }
                _html += page.pageOrder;
                _html += '</a>';
            }
            else {
                if ( _defaults.currentPage === 'nerfacetting' ) {
                    if ( page.firstPage !== undefined || page.lastPage !== undefined ) {
                        _html += '<a href="' + _defaults.baseUrl + '/image/' + _defaults.workId + '/' + page.firstPage + '/">';
                        _html += page.firstPage + '-' + page.lastPage;
                        _html += '</a>';
                    }
                    else {
                        _html += '<a href="' + _defaults.baseUrl + '/image/' + _defaults.workId + '/' + page.pageOrder + '/">';
                        _html += page.pageOrder;
                        _html += '</a>';
                    }
                }
                else {
                    if ( page.firstPage !== undefined || page.lastPage !== undefined ) {
                        _html += '<a href="' + _defaults.baseUrl + '/' + _defaults.currentPage + '/' + _defaults.workId + '/' + page.firstPage + '/">';
                        _html += page.firstPage + '-' + page.lastPage;
                        _html += '</a>';
                    }
                    else {
                        _html += '<a href="' + _defaults.baseUrl + '/' + _defaults.currentPage + '/' + _defaults.workId + '/' + page.pageOrder + '/">';
                        _html += page.pageOrder;
                        _html += '</a>';
                    }
                }
            }
            _html += '</div>';
            _html += '<div class="tag-container">';
            
            // render tags
            if ( page.tags.length === 0 || page.tags.length === 'undefined' ) {
                _html += '<span class="page-tag empty">' + _defaults.msg.emptyTag + '</span>';
            }
            else {
                $.each( page.tags, function( t, tag ) {
                    _html += '<span class="page-tag ' + tag.type + '">' + tag.value + '</span>';
                } );
            }
            _html += '</div>';
            _html += '</li>';
        } );
        _html += '</ul>';
        
        $( _defaults.overviewContent ).hide().html( _html ).find( '.tag-container' ).each( function() {
            $( this ).children( '.page-tag' ).slice( _defaults.recurrenceNumber ).remove();
        } );
        $( _defaults.overviewContent ).show();
        
        // hide loader
        $( _defaults.loader ).hide();
        
        $( '.tag-container' ).on( {
            'mouseover': function() {
                var $this = $( this );
                
                _showCurrentTags( $this );
            },
            'mouseout': function() {
                _hideCurrentTags();
            }
        } );
    }
    
    /**
     * Method which shows the current tag row in a tooltip.
     * 
     * @method _showCurrentTags
     * @param {Object} $obj An jQuery object of the current tag row.
     */
    function _showCurrentTags( $obj ) {
        var content = $obj.html();
        var pos = $obj.position();
        
        if ( _defaults.sidebarRight ) {
            if ( _defaults.currentPage === 'nerfacetting' ) {
                $( _defaults.currentTags ).html( content ).css( {
                    'display': 'block',
                    'top': pos.top + 25 + 'px',
                } );
            }
            else {
                $( _defaults.currentTags ).addClass( 'right' ).html( content ).css( {
                    'display': 'block',
                    'top': pos.top - 2 + 'px',
                    'left': 'auto',
                    'right': '100%'
                } );
            }
        }
        else {
            if ( _defaults.currentPage === 'nerfacetting' ) {
                $( _defaults.currentTags ).html( content ).css( {
                    'display': 'block',
                    'top': pos.top + 25 + 'px'
                } );
            }
            else {
                $( _defaults.currentTags ).html( content ).css( {
                    'display': 'block',
                    'top': pos.top - 2 + 'px'
                } );
            }
        }
    }
    
    /**
     * Method which hides the current tag row tooltip.
     * 
     * @method _hideCurrentTags
     */
    function _hideCurrentTags() {
        $( _defaults.currentTags ).hide();
    }
    
    /**
     * Method to render the NER section.
     * 
     * @method _renderSection
     * @param {Object} data A JSON-Object.
     */
    function _renderSection() {
        if ( _debug ) {
            console.log( '---------- _renderSection() ----------' );
            console.log( '_renderSection: _currentNerPageRange = ', _currentNerPageRange );
            console.log( '_renderSection: _currentNerType = ', _currentNerType );
        }
        
        // set values
        _apiCall = _getAllTags();
        
        _promise = viewer.helper.getRemoteData( _apiCall );
        
        _promise.then( function( workCall ) {
            _pageCount = _getPageCount( workCall );
            
            if ( _currentNerPageRange === null || _currentNerPageRange === '' ) {
                _currentNerPageRange = sessionStorage.getItem( 'currentNerPageRange' );
            }
            if ( _currentNerType === null || _currentNerType === '' ) {
                _currentNerType = sessionStorage.getItem( 'currentNerType' )
            }
            
            // render page count to scale
            if ( _defaults.currentPage === 'nerfacetting' ) {
                $( '#sliderScale .scale-page.end' ).html( _pageCount );
            }
            else {
                if ( _pageCount > 1000 ) {
                    $( '#sliderScale .scale-page.end' ).html( '999+' );
                }
                else {
                    $( '#sliderScale .scale-page.end' ).html( _pageCount );
                }
            }
            
            // init slider
            $( _defaults.slider ).slider( {
                orientation: "vertical",
                range: false,
                min: 1,
                max: _pageCount,
                value: _pageCount,
                slide: function( event, ui ) {
                    _sliderHandlePosition = $( _defaults.sliderHandle ).position();
                    _scaleValue = ( _pageCount + 1 ) - ui.value;
                    
                    // show bubble
                    $( '.page-bubble' ).show();
                    _renderPageBubble( _scaleValue );
                },
                start: function() {
                    _sliderHandlePosition = $( _defaults.sliderHandle ).position();
                    _movedSliderHandlePosition = _sliderHandlePosition.top;
                },
                stop: function( event, ui ) {
                    _currentNerType = sessionStorage.getItem( 'currentNerType' );
                    _sliderScaleHeight = $( _defaults.sliderScale ).height();
                    
                    // set position of section stripe
                    if ( _currentNerPageRange > _pageCount ) {
                        $( _defaults.sliderSectionStripe ).css( {
                            'top': '0px',
                            'height': '600px'
                        } );
                    }
                    else {
                        if ( _sliderHandlePosition.top < 100 ) {
                            $( _defaults.sliderSectionStripe ).animate( {
                                'top': '0px',
                                'height': '100px'
                            } );
                        }
                        else if ( _sliderHandlePosition.top > 100 ) {
                            if ( _sliderHandlePosition.top > 500 ) {
                                $( _defaults.sliderSectionStripe ).animate( {
                                    'top': ( _sliderScaleHeight - 100 ) + 'px',
                                    'height': '100px'
                                } );
                            }
                            else {
                                if ( _movedSliderHandlePosition < _sliderHandlePosition.top ) {
                                    $( _defaults.sliderSectionStripe ).animate( {
                                        'top': _sliderHandlePosition.top - 25 + 'px',
                                        'height': '100px'
                                    } );
                                }
                                else {
                                    $( _defaults.sliderSectionStripe ).animate( {
                                        'top': _sliderHandlePosition.top - 50 + 'px',
                                        'height': '100px'
                                    } );
                                }
                            }
                        }
                    }
                    
                    // render tags
                    switch ( _currentNerPageRange ) {
                        case '5':
                            _start = _scaleValue - 2;
                            _end = _scaleValue + 3;
                            
                            while ( _start < 1 ) {
                                _start++;
                                _end++;
                            }
                            while ( _end > _pageCount ) {
                                _start--;
                                _end--;
                            }
                            
                            _apiCall = _getAllTagsOfPageSection( _start, _end, _currentNerType );
                            break;
                        case '10':
                            _start = _scaleValue - 5;
                            _end = _scaleValue + 5;
                            
                            while ( _start < 1 ) {
                                _start++;
                                _end++;
                            }
                            while ( _end > _pageCount ) {
                                _start--;
                                _end--;
                            }
                            
                            _apiCall = _getAllTagsOfPageSection( _start, _end, _currentNerType );
                            break;
                        case '50':
                            _start = _scaleValue - 25;
                            _end = _scaleValue + 25;
                            
                            while ( _start < 1 ) {
                                _start++;
                                _end++;
                            }
                            while ( _end > _pageCount ) {
                                _start--;
                                _end--;
                            }
                            
                            _apiCall = _getAllTagsOfPageSection( _start, _end, _currentNerType );
                            break;
                        case '100':
                            _start = _scaleValue - 50;
                            _end = _scaleValue + 50;
                            
                            while ( _start < 1 ) {
                                _start++;
                                _end++;
                            }
                            while ( _end > _pageCount ) {
                                _start--;
                                _end--;
                            }
                            
                            _apiCall = _getAllTagsOfPageSection( _start, _end, _currentNerType );
                            break;
                    }
                    
                    _promise = viewer.helper.getRemoteData( _apiCall );
                    
                    _promise.then( function( json ) {
                        _json = json;
                        
                        _html = _renderSectionTags( _json );
                        
                        if ( _html === '' ) {
                            $( _defaults.sectionTags ).hide().html( viewer.helper.renderAlert( 'alert-warning', _defaults.msg.emptyTag, false ) ).show();
                        }
                        else {
                            $( _defaults.sectionTags ).hide().html( _html ).each( function() {
                                $( this ).children( '.page-tag' ).slice( _defaults.recurrenceSectionNumber ).remove();
                            } );
                            $( _defaults.sectionTags ).show();
                        }
                        
                        // hide bubble
                        $( '.page-bubble' ).fadeOut();
                        
                    } ).then( null, function( error ) {
                        $( '.facetting-content' ).empty().append( viewer.helper
                                .renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' ' + error.statusText, false ) );
                        console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                    } );
                }
            } );
            
            // render section tags
            _apiCall = _getAllTagsOfPageSection( 0, _currentNerPageRange, _currentNerType );
            
            _promise = viewer.helper.getRemoteData( _apiCall );
            
            _promise.then( function( json ) {
                _json = json;
                
                _html = _renderSectionTags( _json );
                
                if ( _html === '' ) {
                    $( _defaults.sectionTags ).hide().html( viewer.helper.renderAlert( 'alert-warning', _defaults.msg.emptyTag, false ) ).show();
                }
                else {
                    $( _defaults.sectionTags ).hide().html( _html ).each( function() {
                        $( this ).children( '.page-tag' ).slice( _defaults.recurrenceSectionNumber ).remove();
                    } );
                    $( _defaults.sectionTags ).show();
                }
                
                // hide loader
                $( _defaults.loader ).hide();
                
            } )
                    .then( null, function( error ) {
                        $( '.facetting-content' ).empty().append( viewer.helper
                                .renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' ' + error.statusText, false ) );
                        console.error( 'ERROR: viewer.nerFacetting.init - ', error );
                    } );
            
        } ).then( null, function( error ) {
            $( '.facetting-content' ).empty().append( viewer.helper.renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' ' + error.statusText, false ) );
            console.error( 'ERROR: viewer.nerFacetting.init - ', error );
        } );
    }
    
    /**
     * Method which renders the tags in the section area.
     * 
     * @method _renderSectionTags
     * @param {Object} data A JSON-Object.
     * @returns {Sting} A HTML-String which renders the tag section.
     */
    function _renderSectionTags( data ) {
        if ( _debug ) {
            console.log( '---------- _renderSectionTags() ----------' );
            console.log( '_renderSectionTags: data - ', data );
        }
        
        _html = '';
        // render tags
        $.each( data.pages, function( p, page ) {
            if ( page.tags.length === 0 || page.tags.length === 'undefined' ) {
                _html += '';
            }
            else {
                $.each( page.tags, function( t, tag ) {
                    if ( _defaults.currentPage === 'nerfacetting' ) {
                        if ( tag.counter < 10 ) {
                            _html += '<span class="page-tag ' + tag.type + '" style="font-size: 1.' + tag.counter + 'rem;">' + tag.value + '</span>';
                        }
                        else {
                            _html += '<span class="page-tag ' + tag.type + '" style="font-size: 2rem;">' + tag.value + '</span>';
                        }
                    }
                    else {
                        if ( tag.counter < 10 ) {
                            _html += '<span class="page-tag ' + tag.type + '" style="font-size: 1' + tag.counter + 'px;">' + tag.value + '</span>';
                        }
                        else {
                            _html += '<span class="page-tag ' + tag.type + '" style="font-size: 19px;">' + tag.value + '</span>';
                        }
                    }
                } );
            }
        } );
        
        return _html;
    }
    
    /**
     * Method which renders a span showing the current page section.
     * 
     * @method _renderPageBubble
     * @param {Number} page The current pagenumber.
     */
    function _renderPageBubble( page ) {
        if ( _debug ) {
            console.log( '---------- _renderPageBubble() ----------' );
            console.log( '_renderPageBubble: page - ', page );
        }
        
        var pageBubble = '';
        
        switch ( _currentNerPageRange ) {
            case '5':
                _start = page - 2;
                _end = page + 3;
                
                while ( _start < 1 ) {
                    _start++;
                    _end++;
                }
                while ( _end > _pageCount ) {
                    _start--;
                    _end--;
                }
                
                pageBubble += '<span class="page-bubble">' + _start + '-' + _end + '</span>';
                break;
            case '10':
                _start = page - 5;
                _end = page + 5;
                
                while ( _start < 1 ) {
                    _start++;
                    _end++;
                }
                while ( _end > _pageCount ) {
                    _start--;
                    _end--;
                }
                
                pageBubble += '<span class="page-bubble">' + _start + '-' + _end + '</span>';
                break;
            case '50':
                _start = page - 25;
                _end = page + 25;
                
                while ( _start < 1 ) {
                    _start++;
                    _end++;
                }
                while ( _end > _pageCount ) {
                    _start--;
                    _end--;
                }
                
                pageBubble += '<span class="page-bubble">' + _start + '-' + _end + '</span>';
                break;
            case '100':
                _start = page - 50;
                _end = page + 50;
                
                while ( _start < 1 ) {
                    _start++;
                    _end++;
                }
                while ( _end > _pageCount ) {
                    _start--;
                    _end--;
                }
                
                pageBubble += '<span class="page-bubble">' + _start + '-' + _end + '</span>';
                break;
        }
        
        $( '#sliderVertical .ui-slider-handle' ).html( pageBubble );
    }
    
    /**
     * Method which returns the page count of the current work.
     * 
     * @method _getPageCount
     * @param {Object} work The current wor object.
     * @returns {Number} The page count of the current work.
     */
    function _getPageCount( work ) {
        if ( _debug ) {
            console.log( '---------- _getPageCount() ----------' );
            console.log( '_getPageCount: work - ', work );
        }
        
        return work.pages.length;
    }
    
    /**
     * Method which resets all facetting icons to default
     * 
     * @method _resetFacettingIcons
     */
    function _resetFacettingIcons() {
        if ( _debug ) {
            console.log( '---------- _resetFacettingIcons() ----------' );
        }
        
        $( '.facetting-trigger' ).addClass( 'active' );
        $( '.reset-filter' ).hide();
    }
    
    /**
     * Method which removes all set local storage values.
     * 
     * @method _cleanUpLocalStorage
     */
    function _cleanUpLocalStorage() {
        if ( _debug ) {
            console.log( '---------- _cleanUpLocalStorage() ----------' );
        }
        
        sessionStorage.removeItem( 'currentNerPageRange' );
        sessionStorage.removeItem( 'currentNerType' );
    }
    
    /**
     * API-Calls
     */
    // get all tags from all pages: /rest/ner/tags/{pi}/
    function _getAllTags() {
        if(_debug)console.log("get all tags from ", url);
        let url = _defaults.baseUrl + _defaults.apiUrl + _defaults.workId + "/ner/tags/";
        return url;
    }
    
    // get all tags of a range: /viewer/rest/ner/tags/ranges/{range}/{type}/{pi}/
    function _getAllTagsOfARange( range, type ) {
        let url = _getAllTags() + '?step=' + range;
        if(type && type != '-') {
            url += ('&type=' + type);
        }
        return url;
    }
    
    // get all tags sorted of type: /rest/ner/tags/{type}/{pi}/
    function _getAllTagsOfAType( type ) {
        let url = _getAllTags();
        if(type && type != '-') {
            url += ('&type=' + type);
        }
        return url;
    }

    
    // get all tags sorted of page section: /rest/ner/tags/{start}/{end}/{pi}/
    function _getAllTagsOfPageSection( start, end, type ) {
        let url = _getAllTags();
        url += ("?start=" + start);
        url += ("&end=" + end);
        if(type && type != '-') {
            url += ('&type=' + type);
        }
        return url;
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // define variables
    var _debug = false;
    var _defaults = {
        path: null,
        lang: {}
    };
    var _contextPath = null;
    var _lang = null;
    
    viewer.nerFulltext = {
        /**
         * Method which initializes the NER Popover methods.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.path The rootpath of the application.
         * @example
         * 
         * <pre>
         * var nerConfig = {
         *     path: '#{request.contextPath}'
         * };
         * 
         * viewerJS.nerFulltext.init( nerConfig );
         * </pre>
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.nerFulltext.init' );
                console.log( '##############################' );
                console.log( 'viewer.nerFulltext.init: config - ' );
                console.log( config );
            }
            
            $.extend( true, _defaults, config );
            
            _initNerPopover( _defaults.path );
        }
    };
    
    /**
     * Method which fetches data from the API and returns an JSON object.
     * 
     * @method _getRemoteData
     * @param {String} target The API call URL.
     * @returns {Object} The JSON object with the API data.
     * 
     */
    function _getRemoteData( target ) {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _getRemoteData: target - ' );
            console.log( target );
        }
        
        // show preloader for current element
        $( '.ner-detail-loader', target ).css( {
            display: 'inline-block'
        } );
        
        // AJAX call
        var data = $.ajax( {
            url: decodeURI( $( target ).attr( 'data-remotecontent' ) ),
            type: 'POST',
            dataType: 'JSON',
            async: false,
            complete: function() {
                $( '.ner-detail-loader' ).hide();
            }
        } ).responseText;
        
        return data;
    }
    
    /**
     * Method which initializes the events for the NER-Popovers.
     * 
     * @method _initNerPopover
     * @param {String} path The root path of the application.
     * 
     */
    function _initNerPopover( path ) {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _initNerPopover: path - ' + path );
        }
        
        var data, position, title, triggerCoords, textBox, textBoxPosition, textBoxCoords;
        
        $( '.ner-trigger' ).on( 'click', function() {
            $( 'body' ).find( '.ner-popover-pointer' ).hide();
            $( 'body' ).find( '.ner-popover' ).remove();
            data = _getRemoteData( $( this ) );
            position = $( this ).position();
            triggerCoords = {
                top: position.top,
                left: position.left,
                width: $( this ).outerWidth()
            };
            textBox = $( '#view_fulltext_wrapp' );
            textBoxPosition = textBox.position();
            textBoxCoords = {
                top: textBoxPosition.top,
                left: 0,
                right: textBoxPosition.left + textBox.outerWidth()
            };
            title = $( this ).attr( 'title' );
            
            textBox.append( _renderNerPopover( data, _calculateNerPopoverPosition( triggerCoords, textBoxCoords ), title, path ) );
            
            if ( $( '.ner-popover' ) ) {
                $( this ).find( '.ner-popover-pointer' ).show();
                _removeNerPopover();
                
                $( '.ner-detail-trigger' ).on( 'click', function() {
                    data = _getRemoteData( $( this ) );
                    title = $( this ).attr( 'title' );
                    
                    $( this ).parent().next( '.ner-popover-detail' ).html( _renderNerPopoverDetail( data, title ) );
                } );
            }
        } );
    }
    
    /**
     * Method which renders a popover to the DOM.
     * 
     * @method _renderNerPopover
     * @param {Object} data The JSON object from the API.
     * @param {Object} position A jQuery object including the position of the clicked
     * trigger.
     * @param {String} title The value of the title attribute from the clicked trigger.
     * @param {String} path The root path of the application.
     * @returns {String} The HTML string which renders the popover.
     * 
     */
    function _renderNerPopover( data, position, title, path ) {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _renderNerPopover: data - ' );
            console.log( data );
            console.log( 'viewer.nerFulltext _renderNerPopover: position - ' );
            console.log( position );
            console.log( 'viewer.nerFulltext _renderNerPopover: title - ' + title );
            console.log( 'viewer.nerFulltext _renderNerPopover: path - ' + path );
        }
        
        var positionTop = position.top;
        var positionLeft = position.left;
        var popover = '';
        
        popover += '<div class="ner-popover" style="top:' + positionTop + 'px; left:' + positionLeft + 'px">';
        popover += '<div class="ner-popover-close" title="Fenster schlie&szlig;en">&times;</div>';
        popover += '<div class="ner-popover-header"><h3>' + title + '</h3></div>';
        popover += '<div class="ner-popover-body">';
        popover += '<dl class="dl-horizontal">';
        $.each( $.parseJSON( data ), function( i, object ) {
            $.each( object, function( property, value ) {
                popover += '<dt title="' + property + '">' + property + ':</dt>';
                var objValue = '';
                $.each( value, function( p, v ) {
                    var icon = '';
                    
                    switch ( property ) {
                        case 'Beruf':
                            icon = 'fa-briefcase';
                            break;
                        case 'Verwandte Begriffe':
                            icon = 'fa-briefcase';
                            break;
                        case 'Sohn':
                            icon = 'fa-user';
                            break;
                        case 'Vater':
                            icon = 'fa-user';
                            break;
                        case 'Geburtsort':
                            icon = 'fa-map-marker';
                            break;
                        case 'Sterbeort':
                            icon = 'fa-map-marker';
                            break;
                    }
                    
                    if ( v.url ) {
                        objValue += '<span ';
                        objValue += 'class="ner-detail-trigger" ';
                        objValue += 'title="' + v.text + '" ';
                        objValue += 'tabindex="-1"';
                        objValue += 'data-remotecontent="' + path + '/api?action=normdata&url=' + v.url + '">';
                        objValue += '<i class="fa ' + icon + '" aria-hidden="true"></i>&nbsp;';
                        objValue += v.text;
                        objValue += '<span class="ner-detail-loader"></span>';
                        objValue += '</span>';
                    }
                    else {
                        if ( property === 'URI' ) {
                            objValue += '<a href="' + v.text + '" target="_blank">' + v.text + '</a>';
                        }
                        else {
                            objValue += v.text;
                        }
                    }
                    
                    objValue += '<br />';
                } );
                popover += '<dd>' + objValue + '</dd>';
                popover += '<div class="ner-popover-detail"></div>';
            } );
        } );
        popover += '</dl>';
        popover += '</div>';
        popover += '</div>';
        
        return popover;
    }
    
    /**
     * Method which renders detail information into the popover.
     * 
     * @method _renderNerPopoverDetail
     * @param {Object} data The JSON object from the API.
     * @param {String} title The value of the title attribute from the clicked trigger.
     * @returns {String} The HTML string which renders the details.
     * 
     */
    function _renderNerPopoverDetail( data, title ) {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _renderNerPopoverDetail: data - ' );
            console.log( data );
            console.log( 'viewer.nerFulltext _renderNerPopoverDetail: title - ' + title );
        }
        
        var popoverDetail = '';
        
        popoverDetail += '<div class="ner-popover-detail">';
        popoverDetail += '<div class="ner-popover-detail-header"><h3>' + title + '</h3></div>';
        popoverDetail += '<div class="ner-popover-detail-body">';
        popoverDetail += '<dl class="dl-horizontal">';
        $.each( $.parseJSON( data ), function( i, object ) {
            $.each( object, function( property, value ) {
                popoverDetail += '<dt title="' + property + '">' + property + ':</dt>';
                var objValue = '';
                $.each( value, function( p, v ) {
                    if ( property === 'URI' ) {
                        objValue += '<a href="' + v.text + '" target="_blank">' + v.text + '</a>';
                    }
                    else {
                        objValue += v.text;
                    }
                    
                    objValue += '<br />';
                } );
                popoverDetail += '<dd>' + objValue + '</dd>';
                popoverDetail += '<div class="ner-popover-detail"></div>';
            } );
        } );
        popoverDetail += '</dl>';
        popoverDetail += '</div>';
        popoverDetail += '</div>';
        
        return popoverDetail;
    }
    
    /**
     * Method which calculates the position of the popover in the DOM.
     * 
     * @method _calculateNerPopoverPosition
     * @param {Object} triggerCoords A jQuery object including the position of the clicked
     * trigger.
     * @param {Object} textBoxCoords A jQuery object including the position of the parent
     * DIV.
     * @returns {Object} An object which includes the position of the popover.
     * 
     */
    function _calculateNerPopoverPosition( triggerCoords, textBoxCoords ) {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _calculateNerPopoverPosition: triggerCoords - ' );
            console.log( triggerCoords );
            console.log( 'viewer.nerFulltext _calculateNerPopoverPosition: textBoxCoords - ' );
            console.log( textBoxCoords );
        }
        
        var poLeftBorder = triggerCoords.left - ( 150 - ( triggerCoords.width / 2 ) ), poRightBorder = poLeftBorder + 300, tbLeftBorder = textBoxCoords.left, tbRightBorder = textBoxCoords.right, poTop, poLeft = poLeftBorder;
        
        poTop = triggerCoords.top + 27;
        
        if ( poLeftBorder <= tbLeftBorder ) {
            poLeft = tbLeftBorder;
        }
        
        if ( poRightBorder >= tbRightBorder ) {
            poLeft = textBoxCoords.right - 300;
        }
        
        return {
            top: poTop,
            left: poLeft
        };
    }
    
    /**
     * Method to remove a popover from the DOM.
     * 
     * @method _removeNerPopover
     * 
     */
    function _removeNerPopover() {
        if ( _debug ) {
            console.log( 'viewer.nerFulltext _removeNerPopover' );
        }
        
        $( '.ner-popover-close' ).on( 'click', function() {
            $( 'body' ).find( '.ner-popover-pointer' ).hide();
            $( this ).parent().remove();
        } );
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _data = null;
    var _dataURL = '';
    var _data = '';
    var _linkPos = null;
    var _popover = '';
    var _id = '';
    var _$this = null;
    var _normdataIcon = null;
    var _preloader = null;
    var _defaults = {
        id: 0,
        path: null,
        lang: {},
        elemWrapper: null,
        linkSelector: ".normdataLink"
    };
    
    viewer.normdata = {
        /**
         * Method to initialize the timematrix slider and the events which builds the
         * matrix and popovers.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.id The starting ID of the popover.
         * @param {String} config.path The rootpath of the application.
         * @param {Object} config.lang An object of localized strings.
         * @param {Object} config.elemWrapper An jQuery object of the wrapper DIV.
         * @example
         * 
         * <pre>
         * var normdataConfig = {
         *     path: '#{request.contextPath}',
         *     lang: {
         *         popoverTitle: '#{msg.normdataPopoverTitle}',
         *         popoverClose: '#{msg.normdataPopoverClose}'
         *     },
         *     elemWrapper: $( '#metadataElementWrapper' )
         * };
         * 
         * viewerJS.normdata.init( normdataConfig );
         * </pre>
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.normdata.init' );
                console.log( '##############################' );
                console.log( 'viewer.normdata.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // hide close icons
            $( '.closeAllPopovers' ).hide();
            
            if ( _debug ) {
            console.log('(default) selector:' + _defaults.linkSelector )
            }
            
            
            // first level click
            $( _defaults.linkSelector ).on( 'click', function(event) {
            	_$this = $( this );
                
                _$this.off( 'focus' );
                
                _renderPopoverAction( _$this, _defaults.id );
                event.preventDefault();
                
                        $('.normdata-popover-close').focus();
                
            } );
        },
    };
    
    /**
     * Method which executes the click event action of the popover.
     * 
     * @method _renderPopoverAction
     * @param {Object} $Obj The jQuery object of the current clicked link.
     * @param {String} id The current id of the popover.
     */
    function _renderPopoverAction( $Obj, id ) {
        if ( _debug ) {
            console.log( '---------- _renderPopoverAction() ----------' );
            console.log( '_renderPopoverAction: $Obj = ', $Obj );
            console.log( '_renderPopoverAction: id = ', id );
        }

        
        _normdataIcon = $Obj.find( '.fa-list-ul' );
        _preloader = $Obj.find( '.normdata-preloader' );
        
        // set variables
        _dataURL = $Obj.attr( 'data-remotecontent' );
        _data = _getRemoteData( _dataURL, _preloader, _normdataIcon );
        _linkPos = $Obj.offset();
        _popover = _buildPopover( _data, id );
                
        if ( _debug ) {
            console.log( '_renderPopoverAction: _dataURL = ', _dataURL );
            console.log( '_renderPopoverAction: _data = ', _data );
            console.log( '_renderPopoverAction: _linkPos = ', _linkPos );
        }
        
        // append popover to body
        $( 'body' ).append( _popover );

        // add class to content for sytling reasons
        if ( $( '.normdata-popover-content img' ).hasClass( 'normdata-popover-content__icon' ) ) {
        	$( '.normdata-popover-content__icon' ).each( function() {
        		$(this).parent().addClass( 'img' );
        	} );        	
        }        
        
        // set popover position
        _calculatePopoverPosition( id, _linkPos, $Obj );
        
        // show popover
        $( document ).find( '#normdataPopover-' + id ).hide().fadeIn( 'fast', function() {
            // disable source button
            $Obj.attr( 'disabled', 'disabled' ).addClass( 'disabled' );
            
            // hide tooltip
            $Obj.tooltip( 'hide' );
            
            // set event for nth level popovers
            $( '.normdataDetailLink' ).off( 'click' ).on( 'click', function() {
                _$this = $( this );
                _renderPopoverAction( _$this, _defaults.id );
            } );
        } ).draggable({
            handle: ".normdata-popover-title",
        });
        
        // init close method
        _closeNormdataPopover( $Obj );
        
        // increment id
        _defaults.id++;
        
        // init close all method
        _closeAllNormdataPopovers( $Obj );
    }
    
    /**
     * Returns an HTML-String which renders the fetched data into a popover.
     * 
     * @method _buildPopover
     * @param {Object} data The JSON-Object which includes the data.
     * @param {String} id The incremented id of the popover.
     * @returns {String} The HTML-String with the fetched data.
     */
    function _buildPopover( data, id ) {
        if ( _debug ) {
            console.log( '---------- _buildPopover() ----------' );
            console.log( '_buildPopover: data = ', data );
            console.log( '_buildPopover: id = ', id );
        }
        
        var html = '';
        
        html += '<div id="normdataPopover-' + id + '" class="normdata-popover">';
        html += '<div class="normdata-popover-title">';
        html += '<h3>' + _defaults.lang.popoverTitle + '</h3>';
        html += '<button type="button" class="normdata-popover-close" aria-label="' + _defaults.lang.popoverClose + '"><i class="fa fa-times"aria-hidden="true"></i></button>';
        html += '</div>';
        html += '<div class="normdata-popover-content">';
        html += '<dl class="dl-horizontal">';
        $.each( data, function( i, object ) {
            $.each( object, function( property, value ) {
                html += '<dt title="' + property + '">' + property + '</dt>';
                html += '<dd>';
                $.each( value, function( p, v ) {
                    if ( v.image ) {
                    	html += '<img class="normdata-popover-content__icon" src="' + _defaults.path + '/' + v.image + '" /> ';
                    }
                    if ( v.text ) {
                        if ( v.text.startsWith('http://') || v.text.startsWith('https://') ) {
                            html += '<a href="' + v.text + '" target="_blank">';
                            html += v.text;
                            html += '</a>';
                        }
                        else {
                            html += v.text;
                        }
                    }
                    if ( v.url ) {
                        html += '<button type="button" class="normdataDetailLink" data-remotecontent="';
                        html += _defaults.path;
                        html += '/api/v1/authority/resolver?id=';
                        html += _unicodeEscapeUri(v.url);
                        html += '?template=_DEFAULT&lang='+currentLang+'"'; // TODO use navigationHelper.localeString
                        html += '" title="' + _defaults.lang.showNormdata + '">';
                        html += '<i class="fa fa-list-ul" aria-hidden="true"></i>';
                        html += '<div class="normdata-preloader"></div>';
                        html += '</button>';
                    }
                    html += '<br />';
                } );
                html += '</dd>'
            } );
        } );
        html += "</dl>";
        html += "</div>";
        html += "</div>";
        
        return html;
    }
    
    /**
     * Replaces /\?% with corresponding Unicode sequences.
     * 
     * @param uri URI to escape
     */
    function _unicodeEscapeUri(uri) {
    	return uri.replace(/\//g, 'U002F').replace('/\\/g','U005C').replace('/?/g','U003F').replace('/%/g','U0025');
    }
    
    /**
     * Sets the position to the first level popovers.
     * 
     * @method _calculateFirstLevelPopoverPosition
     * @param {String} id The incremented id of the popover.
     * @param {Object} pos An Object with the current position oft the clicked link.
     * @param {Object} $Obj An jQuery-Object of the clicked link.
     * 
     */
    function _calculatePopoverPosition( id, pos, $Obj ) {
        if ( _debug ) {
            console.log( '---------- _calculatePopoverPosition() ----------' );
            console.log( '_calculatePopoverPosition: id = ', id );
            console.log( '_calculatePopoverPosition: pos = ', pos );
            console.log( '_calculatePopoverPosition: $Obj = ', $Obj );
        }
        
        var _bodyWidth = $( 'body' ).outerWidth();
        var _popoverWidth = $( '#normdataPopover-' + id ).outerWidth();
        var _popoverRight = pos.left + _popoverWidth;
        
        if ( _debug ) {
            console.log( '_calculatePopoverPosition: _bodyWidth = ', _bodyWidth );
            console.log( '_calculatePopoverPosition: _popoverWidth = ', _popoverWidth );
            console.log( '_calculatePopoverPosition: _popoverLeft = ', pos.left );
            console.log( '_calculatePopoverPosition: _popoverRight = ', _popoverRight );
        }
        
        if ( _popoverRight > _bodyWidth ) {
            var _diff = _popoverRight - _bodyWidth;
            
            if ( _debug ) {
                console.log( '_calculatePopoverPosition: _diff = ', _diff );
            }
            
            $( document ).find( '#normdataPopover-' + id ).css( {
                top: pos.top + $Obj.outerHeight() + 5,
                left: pos.left - _diff
            } );
        }
        else {
            $( document ).find( '#normdataPopover-' + id ).css( {
                top: pos.top + $Obj.outerHeight() + 5,
                left: pos.left
            } );
        }
    }
    
    /**
     * Removes current popover from the DOM on click.
     * 
     * @method _closeNormdataPopover
     * 
     */
    function _closeNormdataPopover( $Obj ) {
        if ( _debug ) {
            console.log( '---------- _closeNormdataPopover() ----------' );
            console.log( '_closeNormdataPopover: $Obj = ', $Obj );
        }
        
        $( document ).find( '.normdata-popover-close' ).on( 'click', function() {
            $( this ).parent().parent().remove();
            $Obj.removeAttr( 'disabled' ).removeClass( 'disabled' );
            
            if ( $( '.normdata-popover' ).length < 1 ) {
                $( '.closeAllPopovers' ).hide();
            }
        } );
    }
    
    /**
     * Removes all popovers from the DOM on click.
     * 
     * @method _closeAllNormdataPopovers
     * 
     */
    function _closeAllNormdataPopovers( $Obj ) {
        if ( _debug ) {
            console.log( '---------- _closeAllNormdataPopovers() ----------' );
            console.log( '_closeAllNormdataPopovers: $Obj = ', $Obj );
        }
        
        var _close = $Obj.parent().find( 'i.closeAllPopovers' );
        
        if ( $( '.normdata-popover' ).length > 0 ) {
            _close.show();
            _close.on( 'click', function(event) {
                // close all popovers
                $( '.normdata-popover' ).each( function() {
                    $( this ).remove();
                } );
                
                // hide all close icons
                $( '.closeAllPopovers' ).each( function() {
                    $( this ).hide();
                } );
                
                // set trigger to enable
                $( _defaults.linkSelector ).removeAttr( 'disabled' ).removeClass( 'disabled' );
                
                event.preventDefault();
            } );
        }
        else {
            _close.hide();
        }
    }
    
    /**
     * Returns an JSON object from a API call.
     * 
     * @method _getRemoteData
     * @returns {Object} The JSON object with the API data.
     */
    function _getRemoteData( url, loader, icon ) {
        if ( _debug ) {
            console.log( '---------- _getRemoteData() ----------' );
            console.log( '_getRemoteData: url = ', url );
            console.log( '_getRemoteData: loader = ', loader );
            console.log( '_getRemoteData: icon = ', icon );
        }
         
        loader.show();
        icon.hide();
        
        var data = $.ajax( {
            url: decodeURI( url ),
            type: "GET",
            dataType: "JSON",
            async: false,
            success: function() {
                loader.hide();
                icon.show();
            }
        } ).responseText;
        
        
        return jQuery.parseJSON( data );
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false; 
	
    viewer.notifications = {
		success : (titleAlert, message) => viewer.notifications.notify(titleAlert, message, "success"),
		error : (titleAlert, message) => viewer.notifications.notify(titleAlert, message, "error"),
		warn : (titleAlert, message) => viewer.notifications.notify(titleAlert, message, "warning"),
		confirm : (message, confirmText, denyText, titleAlert) => {
			return viewer.translator.addTranslations(["cancel", "ok", "delete"])
			.then( () => {
				confirmText = confirmText ? confirmText : viewerJS.translator.translate("delete");
				denyText = denyText ? denyText : viewerJS.translator.translate("cancel");
				if(typeof(Swal) !== 'undefined') {
					return Swal.fire({
						scrollbarPadding: false,
						title: titleAlert,
						text: message,
						icon: 'error',
						showCancelButton: true,
						confirmButtonText: confirmText,
	  					cancelButtonText: denyText,
					    buttonsStyling: false,
						reverseButtons: true,
						showClass: {
							popup: '-sweetAlertShowAnimation'
						},
						hideClass: {
							popup: '-sweetAlertHideAnimation'
						},
	  					customClass: {
						    confirmButton: 'btn btn--danger',
						    cancelButton: 'btn btn--default'
						  }
					})
					.then(result => {
						return result.isConfirmed ? Promise.resolve() : Promise.reject();
					});
				} else {
					return window.confirm(message) ? Promise.resolve() : Promise.reject();
				}		
				
			});
		},
		notify : (titleAlert, message, type) => {
			if(typeof Swal !== 'undefined') {
				return Swal.fire({
					scrollbarPadding: false,
					title: titleAlert,
					text: message,
					icon: type,
				    buttonsStyling: false,
					showClass: {
						popup: '-sweetAlertShowAnimation'
					},
					hideClass: {
						popup: '-sweetAlertHideAnimation'
					},
					customClass: {
					    confirmButton: 'btn btn--full',
					    cancelButton: 'btn btn--default'
					  }
				});
			} else if(typeof sweetAlert !== 'undefined') {
				return swal(message, "", type);
			} else if(jQuery().overhang) {
				$("body").overhang({
				  type: type,
				  message: message
				});
			} else {
				alert(message);
			}			
		}
    }

	// DEFINE SWEETALERT TOAST (SMALL BOX NOTIFICATION) BEHAVIOUR
	const swalToast = (typeof Swal !== 'undefined') ?  Swal.mixin({
	  toast: true,
	  position: 'top-end',
	  showConfirmButton: false,
	  timer: 4000,
	  timerProgressBar: true,
	  didOpen: (toast) => {
	    toast.addEventListener('mouseenter', Swal.stopTimer)
	    toast.addEventListener('mouseleave', Swal.resumeTimer)
	  }
	}) : {};

    viewer.swaltoasts = {
		success : (titleAlert, message) => viewer.swaltoasts.toast(titleAlert, message, "success"),
		error : (titleAlert, message) => viewer.swaltoasts.toast(titleAlert, message, "error"),
		warn : (titleAlert, message) => viewer.swaltoasts.toast(titleAlert, message, "warn"),
		
		toast : (titleAlert, message, type) => {
			if(typeof Swal !== 'undefined') {
				swalToast.fire({
				  scrollbarPadding: false,
				  icon: type,
				  title: titleAlert,
				});
			} else if(typeof sweetAlert !== 'undefined') {
				swal(message, "", type);
			} else if(jQuery().overhang) {
				$("body").overhang({
				  type: type,
				  message: message
				});

			} else {
				alert(message);
			}			
		},
		/**
		return viewer.swaltoasts if the status of event is "success". Otherwise return a psuedo viewer.swaltoasts which does nothing
		Use to filter messages from ajax requests so that only the success state produces a message:
		<code> event => viewer.swaltoasts.onSuccess(event).success("message")</code>
		**/
		onSuccess: function(event) {
            if(event.status == "success") {
				return this;       
			} else {
				return {
					success : (titleAlert, message) => {},
					error : (titleAlert, message) => {},
					warn : (titleAlert, message) => {},
				}
			}
		}
		
    }
    
    	
	function showJsfMessagesAsSweetAlert(e) {
		if(e == undefined || (e.responseText && e.responseText.includes("<ul id=\"messages\">"))) {	//only apply if messages div has been updated
			let $messages = $(".messages #messages");
			//handle error messages
			$messages.children(".alert.alert-danger").each((index, child) => {
				//show error message
				let text = $(child).text();
				if(text && text.trim().length > 0) {
					viewerJS.swaltoasts.error(text);
					//scroll to first validation message
					let $elementsWithValidationError = $(".-validation-message.-danger");
					if($elementsWithValidationError.length > 0) {
						$elementsWithValidationError.get(0).scrollIntoView({block: "center"});
					}
				}
			});
			//show success message
			$messages.children(".alert.alert-success").each((index, child) => {
				let text = $(child).text();
				if(text && text.trim().length > 0) {
					viewerJS.swaltoasts.success(text);
				}
			});
		}
	}

	//post notification on ajax/success
	viewer.jsfAjax.success.subscribe(e => {
		showJsfMessagesAsSweetAlert(e);
	});
	$(document).ready(() => showJsfMessagesAsSweetAlert());

	//confirmation dialogs for jsf control elements
	function initJsfConfirmationDialogs() {
		let dialogs = $('[data-require-confirmation="true"]');
						 
		$('[data-require-confirmation="true"]')
		.each((index,element) => {
			//console.log("init confirmation dialog for", element, element.hasConfirmationEvent);
			//store the original (jsf) event in the element. If initJsfConfirmationDialogs gets retriggered due to ajax without the element 
			//being changed, the original jsf-call is kept as the original event
			if(!element.hasConfirmationEvent) {
				element.hasConfirmationEvent = true;
				element.originalEvent = element.onclick;
				element.onclick = e => {
					//show confirmation dialog. If it is confirmed, fire a new click event with the 'confirmed' property
					viewer.notifications.confirm(undefined, undefined, undefined, e.currentTarget.dataset.confirmationText)
					.then(() => {
						//if this event has been dispatched from the code below, the action has been confirmed and may be carried out
						if(element.dataset.confirmationTarget) {
							document.querySelector(element.dataset.confirmationTarget).click();
						} else if(element.originalEvent) {
							//if an original  (jsf) event exists, carry it out
							element.originalEvent(e);
						} else {
							//otherwise the element must be of type submit, so request a form submit from the element
							let form = $(element).closest("form").get(0);
							form.requestSubmit(element);
						}
					})
					.catch(() => {});
					//return false to this event to stop submit action
					return false;
				}
			}
		});
	}
	viewer.jsfAjax.success.subscribe(e => {
		initJsfConfirmationDialogs(); 
	});
	$(document).ready(() => initJsfConfirmationDialogs());
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';

    viewer.oembed = function(url) {
        
        return fetch(url, {
            method: "GET",
            headers: {
                'Content-Type': 'application/json'
            }
        })
        .then(response => {
            if(!response.ok) {
                throw reponse.errorMessage;
            }
            return response.json();
        })
        .then(json => {
            if(json.type == "rich") {                
                return $(json.html)
            } else if(json.type == "photo") {
                return $("<img src='" + json.url + "'/>");
            }
        })
        
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';

    viewer.overlay = {
            init : function() {
                $("[data-overlay='content']").each( (index, overlay) => {
                    let $overlay = $(overlay);
                    let $node = $overlay.children();
                    let $trigger = $("#" + $overlay.attr("data-overlay-trigger"));
                    let type = $overlay.attr("data-overlay-type");
                    if(!type) {
                        type = "default";
                    }
                    let strClosable = $overlay.attr("data-overlay-closable");
                    let closable = true;
                    if(strClosable && strClosable.toLowerCase() == "false") {
                        closable = false;
                    }
                    let strFullscreen = $overlay.attr("data-overlay-fullscreen");
                    let fullscreen = false;
                    if(strFullscreen && strFullscreen.toLowerCase() == "true") {
                        fullscreen = true;
                    }
                    $trigger.on("click", (event) => {
                        switch(type) {
                            case "modal":
                                viewer.overlay.openModal($overlay, closable);
                                break;
                            default:
                                viewer.overlay.open($node, closable, fullscreen);
                        }
                        $node.show();
                    });
                })
            }
    }
    
    viewer.overlay.openModal = function(node, closable, onClose) {
        
        return new Promise( (resolve, reject) => {
        
	        let $overlay = $(".overlay");
	        if($overlay.length > 0) {
	            if($overlay.hasClass("active")) {
	                defer.reject("overlay is already active");
	                return;
	            }
	            
	            let $node = $(node);
	            let $contentHeader = $node.find("[data-overlay-content='header']");
	            let $contentBody = $node.find("[data-overlay-content='body']");
	            let $contentFooter = $node.find("[data-overlay-content='footer']");
	            
	            let $areaHeader = $overlay.find("[data-overlay-area='header']");
	            let $areaBody = $overlay.find("[data-overlay-area='body']");
	            let $areaFooter = $overlay.find("[data-overlay-area='footer']");
	            
	            if($areaHeader.length > 0 && $contentHeader.length > 0) {
	                $areaHeader.append($contentHeader);
	            }
	            if($areaBody.length > 0 && $contentBody.length > 0) {
	                $areaBody.append($contentBody);
	            }
	            if($areaFooter.length > 0 && $contentFooter.length > 0) {
	                $areaFooter.append($contentFooter);
	            }
	            
	            $overlay.addClass("modal-container");
	            let $modal = $("#overlayModal");
	            $modal.modal({
	                backdrop: true,
	                keyboad: closable,
	                focus: true,
	                show: true
	            })
	            $modal.on("hide.bs.modal", event =>  {
	                return closable;
	            })
	            $modal.on("shown.bs.modal", event => {
	            	resolve(node);
	            });
	            $modal.on("hidden.bs.modal", event => {
	                $modal.modal("dispose");
	                $overlay.removeClass("modal-container");
	                if(onClose) {
	                	onClose(node);
	                }
	                $("body").off("click", ".close-modal");
	            });
	            let $dismissButtons = $overlay.find("[data-overlay-action='dismiss']")
	            if(closable === true) {      
	                $dismissButtons.show();
	                $( 'body' ).one( 'click.close-modal', "[data-overlay-action='dismiss']", event => {
	                    $modal.modal("hide");
	                });
	            } else {
	                $dismissButtons.hide();
	            }
	        } else {
	            reject("No overlay element found");
	        }
        
        });
        
    }
    
    viewer.overlay.open = function(node, closable, fullscreen, onClose) {
   
   		return new Promise( (resolve, reject) => {
	        let $overlay = $(".overlay");
   		console.log("open overlay", node, $overlay);
	        if($overlay.length > 0) {
	            if($overlay.hasClass("active")) {
	                reject("overlay is already active");
	                return;
	            }
	            
	            let $node = $(node);
	            $overlay.append($node);
	            $overlay.addClass("active");
	            $( 'html' ).addClass( 'no-overflow' );
	            
	           let overlay = {
	        		node: $node,
	        		wrapper: $overlay,
		        	close: function() {
		        		($node).detach();
		                $overlay.removeClass("active");
		                $overlay.removeClass("fullscreen");
		                $( 'html' ).removeClass( 'no-overflow' );
		                if(onClose) {
		                	onClose(node);
		                }
		                $("body").off("click.close-modal");
		        	}
		        
		        }
	                    
	            
	            let $dismissButtons = $overlay.find("[data-overlay-action='dismiss']")
	            if(closable === true) {      
	                $dismissButtons.show();
	                $( 'body' ).one( 'click.close-modal', "[data-overlay-action='dismiss']", event => {
	                    overlay.close();
	                });
	                //close on click outside content
	                $( 'body' ).one( 'click.close-modal', ".overlay", event => {
	                    if($(event.target).hasClass("overlay")) {
	                        overlay.close();
	                    }
	                });
	            } else {
	                $dismissButtons.hide();
	            }
	            
	            if(fullscreen) {
	                $overlay.addClass("fullscreen");
	            }
	            resolve(overlay);
	        } else {
	            reject("No overlay element found");
	        }
	        
        });
    }
    
    $(document).ready( () => {        
        viewer.overlay.init();
    })
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _elem = null;
    var _text = null;
    
    viewer.pageScroll = {
        /**
         * Initializes the animated pagescroll.
         * 
         * @method init
         * @param {String} obj The selector of the jQuery object.
         * @param {String} anchor The name of the anchor to scroll to.
         */
        init: function( obj, anchor ) {
            _elem = $( obj );
            _text = anchor;
            
            // eventlistener
            $( window ).on( 'scroll', function() {
                if ( window.pageYOffset > 200 ) {
                    _elem.fadeIn();
                }
                else {
                    _elem.hide();
                }
            } );
            
            _elem.on( 'click', function() {
                _scrollPage( _text );
            } );
            
            /**
             * If the url contains a fragment which doesn't start with 'xywh=', assume the fragment refers to a dom id
             */
            let hash = window.location.hash;
            if(hash && !hash.includes("=")) {
                /**
                 * Start scrolling just after $(document).ready() is complete (timeout with 0 millis)
                 */
                $(document).ready(() => {
                    let $anchor = $(hash);
                    if($anchor.length > 0) {
                        setTimeout(() => {
                            let $topHeader = $(".page-header__top");
                            let $navHeader = $(".page-navigation");
                            $("html, body").scrollTop($anchor.offset().top)
                        }, 0)
                    }
                })
            }
        },
    
        scrollToFragment: function(fragment) {
            if(!fragment) {
                let url = window.location.href;
                if(url.includes('#')) {
                    let matches = url.match(/#([\w-]+)/);
                    if(matches) {
                        fragment = matches[0];
                    }
                }
            }
            if(fragment) {
                $(fragment).focus();
            }
        }
    
    };
    
    /**
     * Method which scrolls the page animated.
     * 
     * @method _scrollPage
     * @param {String} anchor The name of the anchor to scroll to.
     */
    function _scrollPage( anchor ) {
        $( 'html,body' ).animate( {
            scrollTop: $( anchor ).offset().top
        }, 1000 );
        
        return false;
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = (function(viewer) {
	'use strict';

	var _rightKey = 39;
	var _leftKey = 37;
	var _forwardKey;
    var _backwardKey;
	var _debug = false;
	var _defaults = {
		maxDoubleClickDelay : 250, // ms
		firstItem: 1,
		lastItem: 10000,
		currentItem: 0,
		targetUrlPrefix: "",
		targetUrlSuffix: ""
	}

	viewer.paginator = {

		/**
		 * Initializes keyboard bindings for paginator
		 * 
		 * @method init
		 * @param {String} obj The selector of the jQuery object.
		 * @param {String} anchor The name of the anchor to scroll to.
		 */
		init : function(config) {
			this.lastKeypress = 0;
			this.lastkeycode = 0;
			this.config = jQuery.extend(true, {}, _defaults); //copy defaults
			jQuery.extend(true, this.config, config); //merge config
			
			if (_debug) {
				console.log("Init paginator with config ", viewer.paginator.config);
			}

			if(this.config.rightToLeft === 'true') {
			    _forwardKey = _leftKey;
			    _backwardKey = _rightKey;
			} else {
			    _forwardKey = _rightKey;
                _backwardKey = _leftKey;
			}
			$(document.body).on("keyup", viewer.paginator.keypressHandler);
			
			$( document ).ready(function() {
			
			// Make the input field the same size as the text/numbers element
			var $numericPaginatorLabelWidth = $('[data-paginator="label"]').outerWidth();
			var $numericPaginatorLabelWidthPX = $numericPaginatorLabelWidth + 'px';
			var $numericPaginatorInputWrapper = $("[data-paginator='input']");
			
			if (_debug) {
				console.log($numericPaginatorLabelWidthPX);
			}	
			
			$($numericPaginatorInputWrapper).css('width', $numericPaginatorLabelWidthPX);
			
			});

		},
		keypressHandler : function(event) {
			if (event.originalEvent) {
				event = event.originalEvent;
			}

			if (_debug) {
				console.log("event from ", event.target.tagName.toLowerCase());
			}
			
			// don't handle if the actual target is an input field
			if (event.target.tagName.toLowerCase().match(/input|textarea/)) {
				return true;
			}
			
			if(viewer.paginator.timer) {
			    clearTimeout(viewer.paginator.timer);
			}

			var keyCode = event.keyCode;
			var now = Date.now();

			// this is a double key press if the last entered keycode is the same as the current one and the last key press is less than maxDoubleClickDelay ago
			var doubleKeypress = (viewer.paginator.lastKeycode == keyCode && now - viewer.paginator.lastKeyPress <= viewer.paginator.config.maxDoubleClickDelay);
			viewer.paginator.lastKeycode = keyCode;
			viewer.paginator.lastKeyPress = now;

			viewer.paginator.timer = setTimeout(function() {
			    
			    if (_debug) {
			        console.log("key pressed ", keyCode);
			        if (doubleKeypress) {
			            console.log("double key press");
			        }
			    }
			    switch (keyCode) {
			        case _backwardKey:
			            if (doubleKeypress && viewer.paginator.config.first) {
			                viewer.paginator.config.first();
			            } 
			            else if (viewer.paginator.config.previous) {
			                viewer.paginator.config.previous();
			            }
			            break;
			        case _forwardKey:
			            if (doubleKeypress && viewer.paginator.config.last) {
			                viewer.paginator.config.last();
			            } 
			            else if (viewer.paginator.config.next) {
			                viewer.paginator.config.next();
			            }
			            break;
			    }
			    
			}, viewer.paginator.config.maxDoubleClickDelay);
			
		},
		close : function() {
			$(document.body).off("keyup", viewer.paginator.keypressHandler);
		},
		showPageNumberInput: function(e) {
			let $paginator = $(e.target).parents(".inputfield-paginator");
		    $paginator.find("[data-paginator='label']").hide();
		    $paginator.find("[data-paginator='input']").css('display', 'flex');
		    $paginator.find("[data-paginator='input-field']").trigger('focus');

			// Fill the actual page number on click
			var $actualPageNumber = $('#paginatorActualPageNumber').html();
			$paginator.find("[data-paginator='input-field']").val($actualPageNumber);
			
			// Automatically select the actual input value (user friendly behaviour)
			$paginator.find("[data-paginator='input-field']").select();

		},
		showPageNumberLabel: function(e) {
			let $paginator = $(e.target).parents(".inputfield-paginator");
		    $paginator.find("[data-paginator='input']").hide();
		    $paginator.find("[data-paginator='label']").show();
		},
		changePageNumber: function(e) {
			if (_debug) {
				console.log("changePageNumber",e);
			}
			let $paginator = $(e.target).parents(".inputfield-paginator");
			let $inputField = $paginator.find("[data-paginator='input-field']");
		    var targetPageNumber = parseInt($inputField.val());
			var $lastPageNumber = $('#paginatorLastPageNumber').html();

			if (targetPageNumber > $lastPageNumber) targetPageNumber = $lastPageNumber;

		    if (_debug) {
		    	console.log("targetPageNumber",targetPageNumber);
		    }
		    if(targetPageNumber != this.config.currentItem && targetPageNumber >= this.config.firstItem && targetPageNumber <= this.config.lastItem) {
		        let targetUrl = this.config.targetUrlPrefix + targetPageNumber + this.config.targetUrlSuffix;
		        if (_debug) {
			        console.log("navigate to", targetUrl);
		        }
		        window.location.href = targetUrl;
		    }
			else {
				$inputField.val($lastPageNumber);
			}
		}
	};

	return viewer;

})(viewerJS || {}, jQuery);
var viewerJS = ( function( viewer ) {
    'use strict';
    
    const _debug = false;
    
    const _triggerElementSelector = "[data-popover-element]";
    const _popoverSelectorAttribute = "data-popover-element";
    const _popoverTitleAttribute = "data-popover-title";
    const _popoverPlacementAttribute = "data-popover-placement";
    const _popoverTemplate = "<div class='popover' role='tooltip'><div class='arrow'></div><h2 class='popover-title-custom'>#{title}</h2><div class='popover-body'></div></div>";    
    const _popoverTemplateNoTitle = "<div class='popover' role='tooltip'><div class='arrow'></div><div class='popover-body'></div></div>";    
    const _dismissPopoverAttribute = "data-popover-dismiss";
    const _clickOutside = "click-outside";
    const _popoverOnShowAttribute = "data-popover-onshow";
    const _popoverOnCloseAttribute = "data-popover-onclose";
    const _popoverWidth = 250; //rounded max-width of bootstrap-popovers
    
    viewer.popovers = {
            
            init: function() {
                $(_triggerElementSelector).each( (index, element) => {
                    
                    let $element = $(element);
                    let popoverSelector = $element.attr(_popoverSelectorAttribute);
                    let $popover = $(popoverSelector);
                    if($popover.length === 1) {
                        this.initPopover($element, $popover);
                    } else if($popover.length > 1) {
                        console.error("Found more than one popover matching selector '" + popoverSelector + "'. Cannot initialize popover");
                    } else {
                        console.error("Found no popover matching selector '" + popoverSelector + "'. Cannot initialize popover");
                    }
                })
            },
            
            initPopover: function($trigger, $popover) {
                
                //add manual show shandler
                $trigger.on("click", (event) => {
                    $trigger.blur();
                    $trigger.popover("toggle");
                })
                
                //add dismiss handler if configured
                if($trigger.attr(_dismissPopoverAttribute) === _clickOutside) {
                    $trigger.on("shown.bs.popover", (event) => {
                        this.addCloseHandler($trigger);
                    });
                }
                
                let config = _createPopoverConfig($trigger, $popover);
                
                $popover.find("[data-popover='close']").on("click", () => {
                    $trigger.popover("hide");
                })
                
                if(config.onShow) {
                    $trigger.on("shown.bs.popover", config.onShow);
                }
                
                if(config.onClose) {
                    $trigger.on("hidden.bs.popover", config.onClose);
                }
                
                $trigger.popover(config);
            },
            
            fromEvent(anchor, event, popoverSelector, config) {
                if(_debug) {                    
                    console.log("Popovers.fromEvent ", event);
                    console.log("Popovers.fromEvent ", popoverSelector);
                    console.log("Popovers.fromEvent ", config);
                }
                
                if(config == undefined) {
                    config = {};
                }

                config.html = true;
                config.content = $(popoverSelector).get(0);
                config.trigger = "manual";
                if(config.title != undefined && config.title.length == 0) {
                    config.template = _popoverTemplateNoTitle;
                }
                
                
                let popover = $(anchor).popover(config)
                .one("shown.bs.popover", function() {
                    viewer.popovers.addCloseHandler($(anchor))
                    let $wrapper = $(popoverSelector).closest(".popover");
                    let $arrow = $wrapper.find(".arrow");
                    $wrapper.offset({top:0,left:0});

                    $wrapper.offset({
                        top: event.pageY - Math.ceil($wrapper.height()/2) + ( (config.offset && config.offset.top) ? config.offset.top : 0),
                        left: event.pageX + $arrow.outerWidth() + ( (config.offset && config.offset.left) ? config.offset.left : 0)
                    })
                    
                    $(popoverSelector).find("[data-popover='close']").on("click", () => {
                        $(anchor).popover("hide");
                    })
                    
                    $arrow.css("top", "50%");
                    if(config.onShow) {
                        config.onShow();
                    }
                })
                .one("hide.bs.popover", function() {
                    $(popoverSelector).find("[data-popover='close']").off("click");
                    if(config.onClose) {
                        config.onClose();
                    }
                })
                .popover("show");
                                
                return popover;
            },
            
            addCloseHandler : function($trigger) {
                $('body').on("click.popover", event => {
                    if($(event.target).closest(".popover").length == 0) {
                        $trigger.popover("hide");
                        $('body').off("click.popover");
                    }
                    
                });
            }
            
    }
    
    function _createPopoverConfig($trigger, $popover) {
        
        let config = {
                html: true,
                content: $popover.get(0),
                trigger: "manual"
        } 
        
        let placement = $trigger.attr(_popoverPlacementAttribute);
        if(placement) {
            config.placement = placement;
        } else {
            //default placement is right. But without sufficient space, place the popover left
            let windowRight = $(window).width();
            let triggerPos = $trigger.offset().left;
            let remainingSpace = windowRight - triggerPos - _popoverWidth;
            config.placement = remainingSpace < 0 ? "left" : "right";
        }
        
        let onShow = $trigger.attr(_popoverOnShowAttribute);
        if(onShow) {
            config.onShow = viewerJS.helper.getFunctionByName(onShow, window);
        }
        
        let onClose = $trigger.attr(_popoverOnCloseAttribute);
        if(onClose) {
            config.onClose = viewerJS.helper.getFunctionByName(onClose, window);
        }
       
        
        let title = $trigger.attr(_popoverTitleAttribute);
        if(title != undefined) {
            if(title.length) {                        
                config.template = _popoverTemplate.replace("#{title}", title);
            } else {
                config.template = _popoverTemplateNoTitle;
            }
        }
        return config;
    }
    

    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // default variables
    var _debug = false;
    var _defaults = {
        themePath: '',
        imagePath: '',
        imageDataFile: '',
        galleryObject: null,
        maxColumnCount: null,
        maxImagesPerColumn: null,
        fixedHeight: false,
        maxHeight: '',
        caption: true,
        overlayColor: '',
        lang: {},
        lightbox: {
            active: true,
            caption: true
        },
    };
    var _promise = null;
    var _imageData = null;
    var _parentImage = null;
    var _lightboxImage = null;
    var _imageLightbox = null;
    var _smallViewport = null;
    var _dataUrl = null;
    
    viewer.responsiveColumnGallery = {
        /**
         * Method which initializes the column gallery.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.themePath The path to the current activated viewer
         * theme.
         * @param {String} config.imagePath The path to the used images.
         * @param {String} config.imageDataFile The path to the JSON-File, which contains
         * the images data.
         * @param {Object} config.galleryObject The DIV where the gallery should be
         * rendered.
         * @param {Number} config.maxColumnCount Count count of the gallery, 4 column are
         * maximum.
         * @param {Number} config.maxImagesPerColumn Count of the images per column.
         * @param {Boolean} config.fixedHeight If true the images have a fixed height,
         * default is false.
         * @param {String} config.maxHeight Sets the given max height value for the
         * images.
         * @param {Boolean} config.caption If true the gallery images have a caption with
         * the title text, default is true.
         * @param {String} config.overlayColor Takes a HEX-value to set the color of the
         * image overlay.
         * @param {Object} config.lang An object of strings for multilanguage
         * functionality.
         * @param {Object} config.lightbox An Object to configure the image lightbox.
         * @param {Boolean} config.lightbox.active If true the lightbox functionality is
         * enabled, default is true.
         * @param {Boolean} config.lightbox.caption If true the lightbox has a caption
         * text, default is true.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.responsiveColumnGallery.init' );
                console.log( '##############################' );
                console.log( 'viewer.responsiveColumnGallery.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // fetch image data and check the viewport
            _dataUrl = _defaults.themePath + _defaults.imageDataFile;
            
            _promise = viewer.helper.getRemoteData( _dataUrl );
            
            _promise.then( function( imageData ) {
                _imageData = imageData;
                _smallViewport = viewer.responsiveColumnGallery.checkForSmallViewport();
                
                // render columns
                if ( _defaults.maxColumnCount > 4 ) {
                    _defaults.galleryObject.append( viewer.helper.renderAlert( 'alert-danger', 'Die maximale Spaltenanzahl für die Galerie beträgt 4!', true ) );
                    
                    return false;
                }
                else {
                    for ( var i = 0; i < _defaults.maxColumnCount; i++ ) {
                        _defaults.galleryObject.append( viewer.responsiveColumnGallery.renderColumns( _defaults.maxColumnCount ) );
                    }
                }
                
                // render images
                while ( _imageData.length ) {
                    $.each( $( '.rcg-col' ), function() {
                        $( this ).append( viewer.responsiveColumnGallery.renderImages( _imageData.splice( 0, _defaults.maxImagesPerColumn ) ) );
                    } );
                }
                
                // set fixed height if activated and viewport is > 375px
                if ( _defaults.fixedHeight && !_smallViewport ) {
                    $.each( $( '.rcg-image-body' ), function() {
                        viewer.responsiveColumnGallery.fixedHeight( $( this ) );
                    } );
                }
                
                // prepare lightbox
                if ( _defaults.lightbox.active ) {
                    $( '.lightbox-toggle' ).on( 'click', function( event ) {
                        event.preventDefault();
                        
                        _parentImage = $( this ).parent().children( 'img' );
                        _lightboxImage = viewer.responsiveColumnGallery.prepareLightbox( _parentImage );
                        _imageLightbox = viewer.responsiveColumnGallery.renderLightbox( _lightboxImage );
                        
                        $( 'body' ).append( _imageLightbox );
                        
                        $( '.rcg-lightbox-body' ).hide();
                        
                        $( '.rcg-lightbox-overlay' ).fadeIn( 'slow' );
                        
                        // first load image, then center it and show it up
                        $( '.rcg-lightbox-image img' ).on("load", function() {
                            viewer.responsiveColumnGallery.centerLightbox( $( '.rcg-lightbox-body' ) );
                            $( '.rcg-lightbox-body' ).show();
                        } );
                        
                        // close lightbox via button
                        $( '.rcg-lightbox-close' ).on( 'click', function() {
                            $( '.rcg-lightbox-overlay' ).remove();
                        } );
                        
                        // close lightbox via esc
                        $( document ).keypress( function( event ) {
                            if ( event.keyCode === 27 ) {
                                $( '.rcg-lightbox-overlay' ).remove();
                            }
                        } );
                        
                        // close lightbox via click on picture
                        $( '.rcg-lightbox-image img' ).on( 'click', function() {
                            $( '.rcg-lightbox-overlay' ).remove();
                        } );
                    } );
                }
            } ).then( null, function( error ) {
                _defaults.galleryObject.append( viewer.helper.renderAlert( 'alert-danger', '<strong>Status: </strong>' + error.status + ' ' + error.statusText, false ) );
                console.error( 'ERROR: viewer.responsiveColumnGallery.init - ', error );
            } );
            
        },
        /**
         * Method which renders the gallery columns.
         * 
         * @method renderColumns
         * @param {String} count The column count of the gallery.
         * @returns {String} A HTML-String which renders a column.
         */
        renderColumns: function( count ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.renderColumns() ----------' );
                console.log( 'viewer.responsiveColumnGallery.renderColumns: count = ', count );
            }
            var column = '';
            
            column += '<div class="rcg-col col-' + count + '"></div>';
            
            return column;
        },
        /**
         * Method which renders the gallery images.
         * 
         * @method renderImages
         * @param {Object} data An object of image data to render the images.
         * @returns {String} A HTML-String which renders the gallery images.
         */
        renderImages: function( data ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.renderImages() ----------' );
                console.log( 'viewer.responsiveColumnGallery.renderImages: data = ', data );
            }
            var image = '';
            
            $.each( data, function( i, j ) {
                $.each( j, function( m, n ) {
                    image += '<div class="rcg-image-container">';
                    image += '<div class="rcg-image-body">';
                    image += '<a href="' + n.url + '">';
                    image += '<div class="rcg-image-overlay" style="background-color:' + _defaults.overlayColor + '"></div>';
                    image += '</a>';
                    image += '<div class="rcg-image-title">';
                    image += '<h3>' + n.title + '</h3>';
                    image += '</div>';
                    image += '<img src="' + _defaults.themePath + _defaults.imagePath + n.name + '" alt="' + n.alt + '" />';
                    if ( _defaults.lightbox.active ) {
                        image += '<div class="lightbox-toggle" title="' + _defaults.lang.showLightbox + '">';
                        image += '<i class="fa fa-arrows-alt" aria-hidden="true"></i>';
                        image += '</div>';
                    }
                    image += '</div>';
                    if ( _defaults.caption ) {
                        image += '<div class="rcg-image-footer">';
                        image += '<p>' + n.caption + '<a href="' + n.url + '" title="' + n.title + '">';
                        image += _defaults.lang.goToWork + ' <i class="fa fa-picture-o" aria-hidden="true"></i></a></p>';
                        image += '</div>';
                    }
                    image += '</div>';
                } );
            } );
            
            return image;
        },
        /**
         * Method which sets a fixed height to the gallery images.
         * 
         * @method fixedHeight
         * @param {Object} $obj An jQuery object of the element which height should be
         * fixed.
         */
        fixedHeight: function( $obj ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.fixedHeight() ----------' );
                console.log( 'viewer.responsiveColumnGallery.fixedHeight: $obj = ', $obj );
            }
            
            $obj.children( 'img' ).css( {
                'height': _defaults.maxHeight
            } );
        },
        /**
         * Method which checks the viewport width and returns true if it´s smaller then
         * 375px.
         * 
         * @method checkForSmallViewport
         * @returns {Boolean} Returns true if it´s smaller then 375px.
         */
        checkForSmallViewport: function() {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.checkForSmallViewport() ----------' );
            }
            var windowWidth = $( window ).outerWidth();
            
            if ( windowWidth <= 375 ) {
                return true;
            }
            else {
                return false;
            }
        },
        /**
         * Method which prepares the lightbox object with the required data.
         * 
         * @method prepareLightbox
         * @param {Object} $obj An jQuery object which includes the required data
         * attributes.
         * @returns {Object} An Object which includes the required data.
         */
        prepareLightbox: function( $obj ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.prepareLightbox() ----------' );
                console.log( 'viewer.responsiveColumnGallery.prepareLightbox: $obj = ', $obj );
            }
            var lightboxData = {};
            
            lightboxData.src = $obj.attr( 'src' );
            lightboxData.caption = $obj.attr( 'alt' );
            
            return lightboxData;
        },
        /**
         * Method which renders a lightbox for the selected image.
         * 
         * @method renderLightbox
         * @param {Object} data An object which includes the required data.
         * @returns {String} A HTML-String which renders the lightbox.
         */
        renderLightbox: function( data ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.renderLightbox() ----------' );
                console.log( 'viewer.responsiveColumnGallery.renderLightbox: data = ', data );
            }
            var lightbox = '';
            
            lightbox += '<div class="rcg-lightbox-overlay">';
            lightbox += '<div class="rcg-lightbox-body">';
            lightbox += '<div class="rcg-lightbox-close" title="' + _defaults.lang.close + '"><i class="fa fa-times" aria-hidden="true"></i></div>';
            lightbox += '<div class="rcg-lightbox-image">';
            lightbox += '<img src="' + data.src + '" alt="' + data.alt + '" />';
            lightbox += '</div>'; // .rcg-lightbox-image
            if ( _defaults.lightbox.caption ) {
                lightbox += '<div class="rcg-lightbox-caption">';
                lightbox += '<p>' + data.caption + '</p>';
                lightbox += '</div>'; // .rcg-lightbox-caption
            }
            lightbox += '</div>'; // .rcg-lightbox-body
            lightbox += '</div>'; // .rcg-lightbox-overlay
            
            return lightbox;
        },
        /**
         * Method which centers the given object to the viewport.
         * 
         * @method centerLightbox
         * @param {Object} $obj An jQuery object of the element to center.
         */
        centerLightbox: function( $obj ) {
            if ( _debug ) {
                console.log( '---------- viewer.responsiveColumnGallery.centerLightbox() ----------' );
                console.log( 'viewer.responsiveColumnGallery.centerLightbox: $obj = ', $obj );
            }
            
            var boxWidth = $obj.outerWidth();
            var boxHeight = $obj.outerHeight();
            
            $obj.css( {
                'margin-top': '-' + boxHeight / 2 + 'px',
                'margin-left': '-' + boxWidth / 2 + 'px'
            } );
        },
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function ( viewer ) {
    'use strict';

    var _debug = false;
    var _positions = {
    	sidebarToc: {
    		link: 0
    	},
    };

    viewer.scrollPositions = {
    	/**
    	 * @description Method to initialize the save scroll position module.
    	 * @method init 
    	 * */
    	init: function( config ) {
    		if (_debug) {
    			console.log( 'Initializing: viewerJS.scrollPositions.init' );
    		}
    		
    		// set scroll status
    		_setScrollStatus();

    		// get scroll status
            _getScrollStatus();
    	}
    }
    
    /**
     * @description Method to set the scroll status.
     * @method _setScrollStatus
     */
    function _setScrollStatus() {
        if ( _debug ) {
            console.log( 'EXECUTE: _setScrollStatus' );
        }

        // set scroll status of sidebar toc
        $( '.widget-toc__element-link a' ).each( function() {
        	if ( $( this ).parents( 'li' ).hasClass( 'active' ) ) {
        		_positions.sidebarToc.link = $( this ).parents( 'li' ).position().top;
        		
        		sessionStorage.setItem( 'scrollPositions', JSON.stringify( _positions ) );        		
        	}
        } );
    }

    /**
     * @description Method to get the scroll status.
     * @method _getScrollStatus
     */
    function _getScrollStatus() {
        if ( _debug ) {
            console.log( 'EXECUTE: _getScrollStatus' );
        }

        var positions;
        
        if ( sessionStorage.getItem( 'scrollPositions' ) == null ) {
            sessionStorage.setItem( 'scrollPositions', JSON.stringify( _positions ) );
            positions = JSON.parse( sessionStorage.getItem( 'scrollPositions' ) );
            
            // scroll sidebar toc in position
            $( '.widget-toc__elements' ).scrollTop( positions.sidebarToc.link );
        }
        else {
            positions = JSON.parse( sessionStorage.getItem( 'scrollPositions' ) );
            
            // scroll sidebar toc in position            
            $( '.widget-toc__elements' ).scrollTop( positions.sidebarToc.link );
        }
    }

    return viewer;

} )( viewerJS || {}, jQuery );
    
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _advSearchValues = {};
    var _defaults = {
        loaderSelector: '.search-advanced__loader',
        inputSelector: '.value-text',
        resetSelector: '.reset',
    };
    
    viewer.searchAdvanced = {
        /**
         * Method to initialize the search advanced features.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.searchAdvanced.init' );
                console.log( '##############################' );
                console.log( 'viewer.searchAdvanced.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // init bs tooltips
            $( '[data-toggle="tooltip"]' ).tooltip( {
                trigger : 'hover'
            } );

			sessionStorage.setItem('advSearchValues', JSON.stringify(_advSearchValues));

			// set search values
			_setAdvSearchValues();
			_resetValue();

			// ajax eventlistener
			jsf.ajax.addOnEvent(function(data) {
				var ajaxstatus = data.status;

				switch (ajaxstatus) {
				case "begin":
					// show loader
					$(_defaults.loaderSelector).show();
					break;
				case "success":
					// init bs tooltips
					$( '[data-toggle="tooltip"]' ).tooltip( {
			            trigger : 'hover'
			        } );

					// set search values
					_setAdvSearchValues();
					_getAdvSearchValues();
					_resetValue();

					// set disabled state to select wrapper
					$('select').each(function() {
						if ($(this).attr('disabled') === 'disabled') {
							$(this).parent().addClass('disabled');
						} else {
							$(this).parent().removeClass('disabled');
						}
					});

					// hide loader
					$(_defaults.loaderSelector).hide();
					break;
				}
			});
		},
    };
    
    function _setAdvSearchValues() {
        if ( _debug ) {
            console.log( '---------- _setAdvSearchValues() ----------' );
        }

        $( _defaults.inputSelector ).off().on( 'keyup, change', function() {
        	var currId = $( this ).attr( 'id' );
        	var currVal = $( this ).val();
        	var currValues = JSON.parse( sessionStorage.getItem( 'advSearchValues' ) );
        	
        	// check if values are in local storage
        	if ( !currValues.hasOwnProperty( currVal ) ) {
        		currValues[ currId ] = currVal;
        	}
        	else {
        		return false;
        	}
        	
        	// write values to local storage
        	sessionStorage.setItem( 'advSearchValues', JSON.stringify( currValues ) );
        } );
    }
    
    function _getAdvSearchValues() {
        if ( _debug ) {
            console.log( '---------- _getAdvSearchValues() ----------' );
        }
        
        var values = JSON.parse( sessionStorage.getItem( 'advSearchValues' ) );
        
        $.each( values, function( id, value ) {
            $( '#' + id ).val( value );
        } );
    }
    
    function _resetValue() {
        if ( _debug ) {
            console.log( '---------- _resetValue() ----------' );
        }
        
        $( _defaults.resetSelector ).off().on( 'click', function() {
            var inputId = $( this ).parents( '.input-group' ).find( 'input' ).attr( 'id' );
            var currValues = JSON.parse( sessionStorage.getItem( 'advSearchValues' ) );
            
            // delete value from local storage object
            if ( currValues.hasOwnProperty( inputId ) ) {
                delete currValues[ inputId ];
            }
            
            // write new values to local storage
            sessionStorage.setItem( 'advSearchValues', JSON.stringify( currValues ) );
            
            $( this ).parents( '.input-group' ).find( 'input' ).val( '' );
        } );
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _promise = null;
    var _childHits = null;
    var _searchListStyle = '';
    var _searchListShowThumbs = false;
    var _defaults = {
        contextPath: '',
        maxChildHitsToRenderOnStart: 5,
        resetSearchSelector: '#resetCurrentSearch',
        searchInputSelector: '#currentSearchInput',
        searchTriggerSelector: '#slCurrentSearchTrigger',
        saveSearchModalSelector: '#saveSearchModal',
        saveSearchInputSelector: '#saveSearchInput',
        excelExportSelector: '.excel-export-trigger',
        excelExportLoaderSelector: '.excel-export-loader',
        risExportSelector: '.ris-export-trigger',
        risExportLoaderSelector: '.ris-export-loader',
        hitContentLoaderSelector: '.search-list__loader',
        hitContentSelector: '.search-list__hit-content',
        listStyle: '',
        msg: {
            getMoreChildren: 'Mehr Treffer laden',
        }
    };
    
    viewer.searchList = {
        /**
         * Method to initialize the search list features.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.searchList.init' );
                console.log( '##############################' );
                console.log( 'viewer.searchList.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // init bs tooltips
			viewerJS.helper.initBsFeatures;
            
            // focus save search modal input on show
            $( _defaults.saveSearchModalSelector ).on( 'shown.bs.modal', function() {
                $( _defaults.saveSearchInputSelector ).focus();
            } );
            
            // set focus class if searchfield is focused
            $( '#currentSearchInput' ).on( {
            	focus: function() {
            		$( this ).prev().addClass( 'focus' );
            	},
            	blur: function() {
            		$( this ).prev().removeClass( 'focus' );
            	},
            } );
            
            // reset current search and redirect to standard search
            $( _defaults.resetSearchSelector ).on( 'click', function() {
                $( _defaults.searchInputSelector ).val( '' );
                location.href = _defaults.contextPath + '/search/';
            } );
            
            // show/hide loader for excel export
            $( _defaults.excelExportSelector ).on( 'click', function() {
                var trigger = $( this ); 
                var excelLoader = $( _defaults.excelExportLoaderSelector );
                
                trigger.hide();
                excelLoader.show();
                
                var url = _defaults.contextPath + '/api/v1/tasks/';
                let downloadFinished = false;
                rxjs.interval(1000)
                .pipe(rxjs.operators.flatMap(() => fetch(url)),
                        rxjs.operators.flatMap(response => response.json()),
                        rxjs.operators.takeWhile(json => {
                            let waiting = json.some(job => job.status != "COMPLETE" && job.status != "ERROR");
                            return waiting;
                        }),
                        rxjs.operators.last()
                )
                .subscribe((jobs) => {
                    //console.log("all jobs finished ", jobs.map(j => j.status));
                    excelLoader.hide();
                    trigger.show();
                })
               
            } );

            // show/hide loader for RIS export
            $( _defaults.risExportSelector ).on( 'click', function() {
                var trigger = $( this ); 
                var risLoader = $( _defaults.risExportLoaderSelector );
                
                trigger.hide();
                risLoader.show();
                
                var url = _defaults.contextPath + '/api/v1/tasks/';
                let downloadFinished = false;
                rxjs.interval(1000)
                .pipe(rxjs.operators.flatMap(() => fetch(url)),
                        rxjs.operators.flatMap(response => response.json()),
                        rxjs.operators.takeWhile(json => {
                            let waiting = json.some(job => job.status != "COMPLETE" && job.status != "ERROR");
                            return waiting;
                        }),
                        rxjs.operators.last()
                )
                .subscribe((jobs) => {
                    //console.log("all jobs finished ", jobs.map(j => j.status));
                    risLoader.hide();
                    trigger.show();
                })
               
            } );
                       
            //** DEFINE DIFFERENT LIST STYLES FUNCTIONS */      
                       
            function setListViewDetails() {
            	$( '.search-list__views button' ).removeClass( 'active' );
            	$('[data-view="search-list-default"]').addClass( 'active' );
            	$( '[data-toggle="hit-content"]' ).show();
				$( '.search-list__hit-thumbnail' ).css({'height': 'auto'});
            	$( '.search-list__hits' ).css( "opacity", 0 ).removeClass( 'grid' ).removeClass( 'list-view' );
            	
            	// set list style in local storage
            	// sessionStorage.setItem( 'searchListStyle', 'default' );
            	
            	// remove header background
            	$( '.search-list__hit-thumbnail' ).css( 'background-image', 'none' );
            	
            	$( '.search-list__hits' ).fadeTo(300,1);  
			}
			
            function setListViewGrid() {
                $( '.search-list__views button' ).removeClass( 'active' );
                $('[data-view="search-list-grid"]').addClass( 'active' );
                $( '[data-toggle="hit-content"]' ).hide();
				$( '.search-list__hit-thumbnail' ).css({'height': 'auto'});
                $( '.search-list__hits' ).css( "opacity", 0 ).removeClass( 'list-view' ).addClass( 'grid' );
                
                // set list style in local storage
                // sessionStorage.setItem( 'searchListStyle', 'grid' );
                
                // hide thumbnail and set src to header background
                $( '.search-list__hit-thumbnail img' ).each( function() {
                    $( this ).on( 'load', function( event ) {
                        var imgUrl = $( event.currentTarget ).attr( 'src' );
                        if(imgUrl) {
                            $( event.currentTarget ).parents( '.search-list__hit-thumbnail' ).css( 'background-image', 'url("' + imgUrl + '")' );
                        }
                    }); 
                    
                    if ( this.complete ) {
                    	var imgUrl = $( this ).attr( 'src' );
                        if(imgUrl) {                                
                            $( this ).parents( '.search-list__hit-thumbnail' ).css( 'background-image', 'url("' + imgUrl + '")' );
                        }
                    }
                } );
                
                $( '.search-list__hits' ).fadeTo(300,1);
			}
			
			function setListViewList() {
                $( '.search-list__views button' ).removeClass( 'active' );
                $('[data-view="search-list-list"]').addClass( 'active' );
                $( '[data-toggle="hit-content"]' ).hide();
				$( '.search-list__hit-thumbnail' ).css({'height': '0'});
                $( '.search-list__hits' ).css( "opacity", 0 ).removeClass( 'grid' ).addClass( 'list-view' );
                
                // set list style in local storage
                // sessionStorage.setItem( 'searchListStyle', 'list-view' );
                
                $( '.search-list__hits' ).fadeTo(300,1);
			}         
                       

            // get/set list style from local storage
            
            if(!_defaults.listStyle) {
				
	            if ( sessionStorage.getItem( 'searchListStyle' ) == undefined ) {
	                sessionStorage.setItem( 'searchListStyle', 'default' );
	                if(_debug) {
	               		console.log('no default view set, so it is set now');
	                }
	            }
	            _searchListStyle = sessionStorage.getItem( 'searchListStyle' );
			} else if (typeof cmsSearchCustomView !== 'undefined' && (sessionStorage.getItem(cmsSearchViewlistStyleID) !== null)) {
			    _searchListStyle = sessionStorage.getItem(cmsSearchViewlistStyleID);
	                if(_debug) {
						console.log("view for THIS special search page (based on page id): " + sessionStorage.getItem(cmsSearchViewlistStyleID)); 
	                }
			     
			} else { 
				_searchListStyle = _defaults.listStyle;
	            if(_debug) {
					console.log('default value used (can be based on CMS comp), nothing else defined: ' + _defaults.listStyle);
				}
			}


            // load thumbnails before appying search list style
           // console.log("Load search hits with style " + _searchListStyle);
            switch ( _searchListStyle ) { 
                case 'default':
				case 'details':
					setListViewDetails();
                    break;
                case 'grid':
					setListViewGrid();
                    break;
                case 'list-view':
					setListViewList();
                    break;
            }

            // set default style  on button click
            $( '[data-view="search-list-default"]' ).on( 'click', function() {
				setListViewDetails();
				sessionStorage.setItem( 'searchListStyle', 'default' );
				if (cmsSearchCustomView == true) {
				    sessionStorage.setItem(cmsSearchViewlistStyleID, 'default' );
					    if(_debug) {
					    	console.log('set custom view list: default/details');
					    }
				} 
            } );

            // set grid style on button click
            $( '[data-view="search-list-grid"]' ).on( 'click', function() {
				setListViewGrid();
				sessionStorage.setItem( 'searchListStyle', 'grid' );
				if (typeof cmsSearchCustomView !== 'undefined' && cmsSearchCustomView == true) {
				    sessionStorage.setItem(cmsSearchViewlistStyleID, 'grid' );
					    if(_debug) {
					    	console.log('set custom view list: grid');
					    }
				}
            } );
            // set list style  on button click
            $( '[data-view="search-list-list"]' ).on( 'click', function() {
				setListViewList();
				sessionStorage.setItem( 'searchListStyle', 'list-view' );
				if (typeof cmsSearchCustomView !== 'undefined' && cmsSearchCustomView == true) {
					sessionStorage.setItem(cmsSearchViewlistStyleID, 'list-view' );
	           			if(_debug) {
					    	console.log('set custom view list: list');
					    }
				}
            } );

			this.initSubHits();
            
            // init thumbnail toggle            
            let $thumbToggle = $('[data-action="toggle-thumbs"]');
            if($thumbToggle.length > 0) {
                if ( sessionStorage.getItem( 'searchListShowThumbs' ) == undefined ) {
                    sessionStorage.setItem( 'searchListShowThumbs', false );
                }
                _searchListShowThumbs = sessionStorage.getItem( 'searchListShowThumbs' ).toLowerCase() === "true";
                this.showSearchListThumbs(_searchListShowThumbs);
                                
                $thumbToggle.on("click", () => {
                    $thumbToggle.trigger( "blur" );
                    _searchListShowThumbs = !_searchListShowThumbs;
                    this.showSearchListThumbs(_searchListShowThumbs);
                    sessionStorage.setItem( 'searchListShowThumbs', _searchListShowThumbs );
                    $thumbToggle.tooltip('show');
                });
            }
        },
        showSearchListThumbs: function(show) {
			const $thumbToggle = $('[data-action="toggle-thumbs"]');
			const activeTitle = $thumbToggle.attr("data-title-active");
            const inactiveTitle = $thumbToggle.attr("data-title-inactive");
            if(show) {                    
            	$thumbToggle
                .addClass("-active")
                .attr("title", activeTitle)
                .attr('aria-checked', true)
				.off('mouseleave.tooltip')
				.off('mouseenter.tooltip');
                $(".search-list__subhit-thumbnail").show();
                $('[data-toggle="tooltip"]').tooltip('dispose');
                viewerJS.helper.initBsFeatures();

             } else {
                $thumbToggle
                .removeClass("-active")
                .attr("title", inactiveTitle)
                .attr('aria-checked', false)
				.off('mouseleave.tooltip')
				.off('mouseenter.tooltip');
                $(".search-list__subhit-thumbnail").hide();
                $('[data-toggle="tooltip"]').tooltip('dispose');
                viewerJS.helper.initBsFeatures();
             }
		},
        initSubHits: function() {
            document.querySelectorAll('[data-toggle="hit-content"]')
            .forEach(button => {
                if(parseInt(button.dataset.childhits) <= _defaults.maxChildHitsToRenderOnStart ) {
                    this.openChildHits(button);
                }
            });

		},
		openChildHits: function(button) {
            // console.log("open child hits"); 
			var $currBtn = $( button );
                
            let scriptName = button.dataset.loadHitsScript;
            let toggleArea = document.querySelector( "div[data-toggle-id='"+button.dataset.toggleId+"']"  );
            let hitsPopulated = toggleArea.querySelector("[data-hits-populated]").dataset.hitsPopulated;
            if(_debug) {
				console.log("clicked hit-content", button, scriptName, toggleArea, hitsDisplayed, _defaults.childHitsToLoadOnExpand);
			}

			$currBtn.toggleClass( 'in' );
			$(toggleArea).slideToggle();
            if(_debug)console.log("call script ", scriptName, hitsPopulated);
			if(hitsPopulated <  _defaults.childHitsToLoadOnExpand) {
				//show loader now already. Otherwise it will only be shown when the post request starts and the request are carried out sequentially
				this.showAjaxLoader(toggleArea.querySelector(".search-list__loader").id);
				window[scriptName](); //execute commandScript to load child hits
			}
		},
		    
	    showAjaxLoader: function(loaderId) {
	    	let loader = document.getElementById(loaderId);
	    	loader.classList.remove("d-none");
	    },
	    hideAjaxLoader: function(loaderId) {
	    	let loader = document.getElementById(loaderId);
	    	loader.classList.add("d-none");
	    },
	    initChildHitThumbs: function(dataToggleId) {
			let showThumbs = this.isShowChildHitThumbs();
			if(this.isShowChildHitThumbs()) {
				$("[data-toggle-id="+dataToggleId+"]").find(".search-list__subhit-thumbnail").show();
			} else {
				$("[data-toggle-id="+dataToggleId+"]").find(".search-list__subhit-thumbnail").hide();
			}
		},
		isShowChildHitThumbs() {
			return sessionStorage.getItem( 'searchListShowThumbs' ).toLowerCase() === "true" ? true : false;
		}
    };



    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
  
    
    viewer.ShareImageFragment = function(image) {
        this.init(image);
    }
    
    viewer.ShareImageFragment.prototype.startFragmentSelect = function() {
        this.$fragmentSelectButton.tooltip("hide");
        this.$fragmentSelectButton.addClass("active");
        
        if(this.fragmentSelect) {            
            this.fragmentSelect.startSelect().subscribe( area => {
                var areaString = viewImage.getAreaString(area);
                var pageUrl = window.location.origin + window.location.pathname +  window.location.search + "#xywh=" + areaString;
                var imageUrl = viewImage.getRegionUrl(area);
                $("[data-copy-share-image='image-region-page']").attr("data-copy-share-image", pageUrl);
                $("[data-copy-share-image='image-region-image']").attr("data-copy-share-image", imageUrl);
                this.$links.show();
                this.$instructions.hide();
                this.initImageFragmentLinks(areaString);
            });
        }
    },
    
    viewer.ShareImageFragment.prototype.endFragmentSelect = function() {
        this.$fragmentSelectButton.removeClass("active");
        if(this.fragmentSelect) {
            this.fragmentSelect.remove(0);
            this.fragmentSelect.stopSelect();
        }
        this.$links.hide();
        this.hideImageFragmentLinks();
        this.$instructions.show();
    },

    viewer.ShareImageFragment.prototype.init = function(image) {
        
        this.$fragmentSelectButton = $(".share-image-region a");
        this.$links = $(".share-image-area__links");
        this.$instructions = $(".share-image-area__instructions");
        
        this.$links.hide();
        
        //fullscreen controls
        let $panels = $(".fullscreen__view-sidebar-accordeon-panel h3");
        $panels.on("click", (e) => {
            let $panel = $(e.target).closest(".fullscreen__view-sidebar-accordeon-panel h3");
            this.toggleImageShare($panel);
        });
        $(".share-image-area [data-popover='close']").on("click", (e) => {
            this.endFragmentSelect();
            $(e.target).closest(".fullscreen__view-sidebar-accordeon-panel").find("h3").click();
            $(e.target).closest(".fullscreen__view-sidebar-accordeon-panel").find("h3").focus();
        })
        
        // init area select
        try { 
            let styles = viewerJS.helper.getCss("image-fragment", ['borderTopColor', 'borderTopWidth', 'background-color']);
            var fragmentSelectConfig = {
                 removeOldAreas : true,
                 drawStyle : {
                     borderColor: styles["borderTopColor"],
                     borderWidth: parseInt(styles["borderTopWidth"]),
                     fillColor: styles["background-color"],
                 }
            };
            this.fragmentSelect = new ImageView.Tools.AreaSelect(image, fragmentSelectConfig);
        } catch(error) {
            console.error("Error initializing area select: ", error);
        }
        this.toggleImageShare($(".share-image-area h3"));
        this.$fragmentSelectButton.on("shown.bs.popover", () => this.startFragmentSelect());
        this.$fragmentSelectButton.on("hidden.bs.popover", () => this.endFragmentSelect());
    }
    
    viewer.ShareImageFragment.prototype.initImageFragmentLinks = function(fragment) {
        // let $wrapper = $(".widget-usage__image-fragment-wrapper");
        let $wrapper = $('[data-fragment-link="wrapper"]');
        
        if(!fragment) {                 
            fragment = viewerJS.helper.getFragmentHash();
        }
        if(fragment) {
            var pageUrl = window.location.origin + window.location.pathname + "#xywh=" + fragment;
            var imageUrl = viewImage.getRegionUrl(fragment);
//            $wrapper.find(".widget-usage__image-fragment-page").attr("data-copy-share-image", pageUrl);
//            $wrapper.find(".widget-usage__image-fragment-image").attr("data-copy-share-image", imageUrl);
            $wrapper.find('[data-fragment-link="page"]').attr("data-copy-share-image", pageUrl);
            $wrapper.find('[data-fragment-link="iiif"]').attr("data-copy-share-image", imageUrl);
			// ACTIVATE COPY TO CLIPBOARD 
			viewerJS.clipboard.init('[data-copy-share-image]', 'data-copy-share-image'); 
            $wrapper.show();
        }
    }
    
    viewer.ShareImageFragment.prototype.hideImageFragmentLinks = function() {
        let $wrapper = $('[data-fragment-link="wrapper"]');
        $wrapper.hide();
    }
    

    viewer.ShareImageFragment.prototype.toggleImageShare = function($panel) {
        if($panel.closest(".fullscreen__view-sidebar-accordeon-panel").hasClass("share-image-area") && $panel.hasClass("in")) {
            this.startFragmentSelect();
        } else {
//            this.endFragmentSelect();
        }
    }

	



    return viewer;
} )( viewerJS || {}, jQuery );


var viewerJS = ( function( viewer ) {
    'use strict';
    
    // TRIGGER ACCORDION SUBMENU 
    $( document ).ready(function() {
	    $('.sidebar-menu__submenu-button').on( 'click', function() {
	        var currTrigger = $( this ); 
	            $( currTrigger ).next( '.sidebar-menu__submenu' ).slideToggle('fast');
	            $( currTrigger ).toggleClass('-active');
	        });
    });

    	    return viewer;
    	    
} )( viewerJS || {}, jQuery );
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _box = null;
    var _imgpath = null;
    var _imgname = null;
    
    viewer.simpleLightBox = {
        /**
         * Initializes an event (click) which renders a lightbox with an bigger image.
         * 
         * @method init
         * @example
         * 
         * <pre>
         * viewerJS.simpleLightBox.init();
         * </pre>
         * 
         */
        init: function() {
            // eventlisteners
            $( '.lightbox-image' ).on( 'click', function( event ) {
                event.preventDefault();
                
                var $this = $( this );
                
                _imgpath = _getImagePath( $this );
                _imgname = _getImageName( $this );
                _box = _setupLightBox( _imgpath, _imgname );
                
                $( 'body' ).append( _box );
                
                _centerModalBox( $( '.lightbox-modal-box' ) );
                
                $( '.lightbox-overlay' ).fadeIn();
                
                $( '.lightbox-close-btn' ).on( 'click', function() {
                    $( '.lightbox-overlay' ).remove();
                } );
            } );
        }
    };
    
    /**
     * Returns the image path from the 'data-imgpath' attribute.
     * 
     * @method _getImagePath
     * @param {Object} $Obj Must be a jQuery-Object like $('.something')
     * @returns {String} The image path from the 'data-imgpath' attribute.
     * 
     */
    function _getImagePath( $Obj ) {
        _imgpath = $Obj.attr( 'data-imgpath' );
        
        return _imgpath;
    }
    
    /**
     * Returns the image name from the 'data-imgname' attribute.
     * 
     * @method _getImageName
     * @param {Object} $Obj Must be a jQuery-Object like $('.something')
     * @returns {String} The image name from the 'data-imgname' attribute.
     * 
     */
    function _getImageName( $Obj ) {
        _imgname = $Obj.attr( 'data-imgname' );
        
        return _imgname;
    }
    
    /**
     * Returns a HTML-String which renders the lightbox.
     * 
     * @method _setupLightBox
     * @param {String} path The path to the big image.
     * @param {String} name The name of the big image.
     * @returns {String} The HTML-Code to render the lightbox.
     * 
     */
    function _setupLightBox( path, name ) {
        var lightbox = '';
        
        lightbox = '<div class="lightbox-overlay">';
        lightbox += '<div class="lightbox-modal-box">';
        lightbox += '<div class="lightbox-close">';
        lightbox += '<span class="lightbox-close-btn" title="Fenster schlie&szlig;en">&times;</span>';
        lightbox += '</div>';
        lightbox += '<img src="' + path + name + '" alt="' + name + '" /></div></div>';
        
        return lightbox;
    }
    
    /**
     * Puts the lightbox to the center of the screen.
     * 
     * @method _centerModalBox
     * @param {Object} $Obj Must be a jQuery-Object like $('.something')
     */
    function _centerModalBox( $Obj ) {
        var boxWidth = $Obj.outerWidth();
        var boxHeight = $Obj.outerHeight();
        
        $Obj.css( {
            'margin-top': '-' + boxHeight / 2 + 'px',
            'margin-left': '-' + boxWidth / 2 + 'px'
        } );
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    // default variables
    var _debug = false; 
    
    viewer.slider = {
	
		sliders: [],

     	
     	styles: new Map([
		  ["base", {
	     		maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 800,
	     		imageHeight: 1000,
	     		swiperConfig: {
				  direction: 'horizontal',
				  loop: false,
			      slidesPerView: 2,
			      spaceBetween: 20,
				  a11y: {
				    prevSlideMessage: 'Previous slide',
				    nextSlideMessage: 'Next slide',
				  },
			    }
		  }], 
     	["full-width", {
	     		maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 1920,
	     		imageHeight: 1000,
	     		swiperConfig: {
				  direction: 'horizontal',
				  loop: false,
			      slidesPerView: 1,
				  a11y: {
				    prevSlideMessage: 'Previous slide',
				    nextSlideMessage: 'Next slide',
				  },
			    }
			  }],
		["3-slides-pagination", {
				maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 800,
	     		imageHeight: 1000,
	     		swiperConfig: {
				  loop: true,
			      slidesPerView: 1, 
			      spaceBetween: 20,
			      pagination: {
//			          el: '.swiper-pagination',
			          clickable: true
			      },
			      breakpoints: {
			    	    // when window width is >= 450px
			    	    450: {
			    	      slidesPerView: 1,
			    	      spaceBetween: 0
			    	    },
			    	    // when window width is >= 320px
			    	    700: {
			    	      slidesPerView: 2,
			    	      spaceBetween: 10
			    	    },
			    	    // when window width is >= 640px
			    	    1200: {
			    	      slidesPerView: 3,
			    	      spaceBetween: 20
			    	    }
			      },
				  a11y: {
					enabled: true,
				    prevSlideMessage: 'Previous slide',
				    nextSlideMessage: 'Next slide',
				  },
			    }
			}],
		["fade-effect-auto-play", {
				maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 1600,
	     		imageHeight: 1000,
	     		swiperConfig: {
				  loop: true,
				  simulateTouch: false,
			      effect: 'fade',
			      speed: 850,
			      fadeEffect: {
			        crossFade: true
			      },
			      autoplay: {
			    	   delay: 3700,
			      },
			    }
			}],
		["centered-mode", {
				maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 800,
	     		imageHeight: 1000,
	     		swiperConfig: {
	     		  centeredSlides: true,
			      spaceBetween: 30,
			      slidesPerView: 4,
			      loop: true,
			      
			    }
			}],
		["vertical-auto-play", {
				maxSlides: 20,
	     		timeout: 10000, //ms
	     		imageWidth: 800,
	     		imageHeight: 1000,
	     		swiperConfig: {
				  direction: 'vertical',
				  loop: true,
			      slidesPerView: 1,
			      spaceBetween: 10,
			      autoplay: {
			    	   delay: 3200,
			      },
			    }
			}],
     	]),
     	init: function() {
     		if(_debug)console.log("loading slider ", this);
     		riot.mount("slider", {language: currentLang, styles: this});
     		
     		//Remount all sliders after each ajax call which responst contains a slider tag
     		viewer.jsfAjax.success
     		.pipe(
     			rxjs.operators.filter( e => e.responseText && e.responseText.includes("<slider ")),
     			rxjs.operators.debounceTime(500)
     			)
     		.subscribe((e) => {
     			// console.log("update slider");
     			riot.mount("slider", {language: currentLang, styles: this});
     		});
     	},
     	set: function(name, config) {
     		this.styles.set(name, config);
     	},
     	update: function(name, configFragment) {
     		let config = $.extend( true, {}, this.styles.get(name), configFragment );
     		this.set(name, config);
     	},
     	copy: function(name) {
     		let config = $.extend( true, {}, this.styles.get(name));
     		return config;
     	},
     	get: function(name) {
     		let config = this.styles.get(name);
     		if(!config) {
     			console.warn("Style \"" + name + "\" is not included in the list of slider styles. Using \"base\" as fallback");
     			return this.styles.get("base");
     		} else {
     			return config;
     		}
     	},
     	getStyleNameOrDefault: function(name) {
     		if(this.styles.has(name)) {
     			return name;
     		} else {
     			return "base";
     		}
     	}
            
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _imgWidth = null;
    var _imgHeight = null;
    var _defaults = {
        thumbs: '.stacked-thumbnail',
        thumbsBefore: '.stacked-thumbnail-before',
        thumbsAfter: '.stacked-thumbnail-after',
    };
    
    viewer.stackedThumbnails = {
        /**
         * Method to initialize the timematrix slider and the events which builds the
         * matrix and popovers.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {Object} config.thumbs All jQuery objects of the stacked thumbnails.
         * @param {String} config.thumbsBefore The classname of the stacked thumbnail
         * before element.
         * @param {String} config.thumbsAfter The classname of the stacked thumbnail after
         * element.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.stackedThumbnails.init' );
                console.log( '##############################' );
                console.log( 'viewer.stackedThumbnails.init: config - ' );
                console.log( config );
            }
            
            $.extend( true, _defaults, config );
            
            // hide stacked thumbs
        //    $( _defaults.thumbs ).hide();
        //    $( _defaults.thumbs ).siblings().hide();
            
            // iterate through thumbnails and set width and height for image stack
         /*   $( _defaults.thumbs ).each( function() {
                _imgWidth = $( this ).outerWidth();
                _imgHeight = $( this ).outerHeight();
                
                $( this ).css( {
                    'margin-left': '-' + ( _imgWidth / 2 ) + 'px'
                } );
                
                $( this ).siblings().css( {
                    'width': _imgWidth,
                    'height': _imgHeight,
                    'margin-left': '-' + ( _imgWidth / 2 ) + 'px'
                } );
                
                // show stacked thumbs after building them
                $( this ).show();
                $( this ).siblings( _defaults.thumbsBefore ).fadeIn( 'slow', function() {
                    $( this ).siblings( _defaults.thumbsAfter ).fadeIn();
                } );
            } );*/
            

            // fade in thumb paper stack effect on scroll
            $.fn.isInViewport = function () {
                let elementTop = $(this).offset().top;
                let elementBottom = elementTop + $(this).outerHeight();

                let viewportTop = $(window).scrollTop();
                let viewportBottom = viewportTop + $(window).height();

                return elementBottom > viewportTop && elementTop < viewportBottom;
            };
            
            var debounce_timer;

            $(window).scroll(function() {
                    if(debounce_timer) {
                            window.clearTimeout(debounce_timer);
                    }
                    debounce_timer = window.setTimeout(function() {
                        $('.stacked-thumbnail-after, .stacked-thumbnail-before').each( function(i){
                            if ($(this).isInViewport()) {
                                $(this).addClass('-shown');
                            }
                        }); 
                    }, 100);
            });

            // trigger thumb paper stack effect if page has no scroll
            $('.stacked-thumbnail').on('load', function(){
	            $('.stacked-thumbnail-before, .stacked-thumbnail-after').each( function(i){
	                if ($(this).isInViewport()) {
	                    $(this).addClass('-shown');
	                }
	            }); 
            });
                
        },
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';

	var _debug = false;    
     
    viewer.stickyElements = {
    	initialized: false,
		refresh: new rxjs.Subject(),
		initRefresh: function() {
			this.refresh
			.pipe(rxjs.operators.delay(0))
	        .subscribe(() => {
	        	if(_debug)console.log("refresh hcSticky rx");
	        	$(document).ready(() => $(".-sticky, .-refreshHCsticky").hcSticky('refresh', {}));
	        }); 
			 
			/**
			* Refresh hcsticky after ajax requests
			**/
			viewerJS.jsfAjax.success.subscribe(this.refresh);
		},
		init: function(config) {

			if(_debug) {
				console.log( '##############################' );
		        console.log( 'viewer.stickyElements.init' );
		        console.log( '##############################' );
		        console.log( 'viewer.stickyElements.init: config - ' );
		        console.log( config );
		        console.log( '##############################' );
		        console.log( 'viewer.stickyElements.init: initialized - ' );
		        console.log( this.initialized );
			}

			if(!this.initialized) {
				this.initRefresh();
				this.initialized = true;
			}
			
			if(config.initAdmin) {
				// STICKY ELEMENTS TARGETS AND OPTIONS
				// sticky admin main menu sidebar left side
				if ($(".admin__sidebar").length) {
					$(".admin__sidebar-inner").hcSticky({
						stickTo: $('.admin')[0],
						innerTop: 0
					});
				}
	
				// general sticky element for admin backend - sticks to selector .admin__content-wrapper
				if ($(".admin__sidebar").length) {
					$('.-sticky').hcSticky({
						stickTo: $('.admin__content-wrapper')[0],
						innerTop: -50,
						bottom: 0
					});
				}
				
				// sticky content main area for create campaign
				if ($("#crowdAddCampaignView").length) {
					$('#crowdAddCampaignView .admin__content-main').hcSticky({
						stickTo: $('.admin__content-wrapper')[0],
						innerTop: -50
					});
				}
				
				// sticky content main area for create CMS page
				if ($("#cmsCreatePage").length) {
					$('#cmsCreatePage .admin__content-main').hcSticky({
						stickTo: $('.admin__content-wrapper')[0],
						innerTop: -50
					});
				}
				
			}
			
			if(config.initFrontend) {
				// toggle collapseable widgets
	       		viewer.toggledCollapseable.subscribe(e => {
	            	var pos = $(e.target).position().top;
		       		var offset = $(e.target).offset().top;
		       		var currentPos = document.documentElement.scrollTop;
		       		if(currentPos > pos) {
	            		window.scrollTo(0,pos);
					}		       		
     				viewerJS.stickyElements.refresh.next();
				});
				
				// sticky sidebar
			 	$('[data-target="sticky-sidebar"]').hcSticky({
			    	top: 100,
				    responsive: {
				      768: {
				        disable: true
				      }
				    }
			 	});	
			}
		},

	};
	return viewer;
} )( viewerJS || {}, jQuery );


var viewerJS = ( function( viewer ) {
    'use strict';

    // load images with error handling
    viewer.loadThumbnails = function(notFoundImage, accessDeniedImage) {
        this.notFound = notFoundImage;
        this.accessDenied = accessDeniedImage;
        this.thumbnailImageLoaded = new rxjs.Subject();
        
        viewer.jsfAjax.success.subscribe(() => this.loadAll());
		this.loadAll();
    }
    
    viewer.loadThumbnails.prototype.loadAll = function() {
   		$('[data-viewer-thumbnail="thumbnail"]').each((index, element) => this.load(element));
    }
    
    
    viewer.loadThumbnails.prototype.load = function(element) {
    	var source = element.src
        var dataSource = element.dataset.src; 
        if(dataSource && !source) { 
             this.loadImage(element, dataSource);            
        } else if (source) {     
               var onErrorCallback = () => {
                   this.loadImage(element, element.src)
               }
               //reload image if error event occurs
               $(element).one("error", onErrorCallback)
               //if image is already loaded but has not width, assume error and also reload
               if(element.complete && element.naturalWidth === 0) {
                   $(element).off("error", onErrorCallback);
                   this.loadImage(element, element.src)
               }
        }
    }
    
    
    viewer.loadThumbnails.prototype.loadImage = function(element, source) {
		//Hide broken image icon while loading by either setting style.display to "none" or setting empty alt attribute
		//first solution hides whole image, the latter only its content
		let alt = element.alt;
		let display = element.style.display;
		element.style.display = "none";
		//element.alt = "";
        $.ajax({
            url: source,
            cache: true,
            xhrFields: {
                responseType: 'blob'
            },
        })
        .done((blob) => {
        
            var url = window.URL || window.webkitURL;
            element.src = url.createObjectURL(blob);
            element.alt = alt;
            element.style.display = display;
            this.thumbnailImageLoaded.next(element);
        })
        .fail((error) => {
            var status = error.status;
                switch(status) {
                    case 403:
                        element.src = this.accessDenied;
                        break;
                    case 500:
                    case 404:
                        element.src = this.notFound;
                        break;
                    default:
                         element.src = source;
                }
                element.alt = alt;
                element.style.display = display;
                this.thumbnailImageLoaded.next(element);
            });  
    }
    
    return viewer;
    
})( viewerJS || {}, jQuery );
                
                
                
var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
        currLang: 'de',
        selector: 'textarea.tinyMCE',
        width: '100%',
        height: 400,
        theme: 'silver',
        plugins: 'print preview paste searchreplace autolink directionality code visualblocks visualchars fullscreen image link media template codesample table charmap hr pagebreak nonbreaking anchor insertdatetime advlist lists wordcount media textpattern help',
        toolbar: ['formatselect | undo redo | bold italic underline strikethrough superscript forecolor backcolor | link | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | fullscreen code | addFeedbackModalLink'],
        menubar: false,
        statusbar: false,
        pagebreak_separator: '<span class="pagebreak"></span>',
        relative_urls: false,
        language: 'de',
		valid_children: '+a[div]',
        setup : function (ed) {
            // listen to changes on tinymce input fields
            ed.on('init', function (e) {
                viewerJS.stickyElements.refresh.next();
            });
            
            ed.on('change input paste', function (e) {
		       console.log("trigger save")
		       ed.save();
               //tinymce.triggerSave();
               //trigger a change event on the underlying textArea
               console.log("target ", ed.targetElm, ed.getElement())
               $(ed.targetElm).change();
                if (currentPage === 'adminCmsNewPage') {
                    createPageConfig.prevBtn.attr('disabled', true);
                    createPageConfig.prevDescription.show();
                }
            });
            ed.on('blur', function(e) {
		        $(ed.targetElm).blur();
		    });
            
			ed.ui.registry.addButton('myCustomToolbarButton', {
				text: 'My Custom Button',
	              onAction: function () {
	                alert('Button clicked!');
	              }
    		});
        }
    };
    
    viewer.tinyMce = {
        getConfig: function(config) {
            let c = $.extend( true, {}, _defaults, config );
            return c;
        },
        init: function( config ) {
            this.config = $.extend( true, {}, _defaults, config);
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.tinyMce.init' );
                console.log( '##############################' );
                console.log( 'viewer.tinyMce.init: config - ', this.config );
            }
            
             
            // check current language
            switch ( this.config.currLang ) {
                case 'de':
                    this.config.language = 'de';
                    break;
                case 'es':
                    this.config.language = 'es';
                    break;
                case 'pt':
                    this.config.language = 'pt_PT';
                    break;
                case 'ru':
                    this.config.language = 'ru';
                    break;
            }
			// console.log("tinymce init ", this.config);
            tinymce.init( this.config );
        },
        close: function() {
            tinymce.remove();
        },
        overview: function() {
            // check if description or publication editing is enabled and
            // set fullscreen options
            if ( $( '.overview__description-editor' ).length > 0 ) {
                viewerJS.tinyConfig.setup = function( editor ) {
                    editor.on( 'init', function( e ) {
                        $( '.overview__publication-action .btn' ).hide();
                    } );
                    editor.on( 'FullscreenStateChanged', function( e ) {
                        if ( e.state ) {
                            $( '.overview__description-action-fullscreen' ).addClass( 'in' );
                        }
                        else {
                            $( '.overview__description-action-fullscreen' ).removeClass( 'in' );
                        }
                    } );
                };
            }
            else {
                viewerJS.tinyConfig.setup = function( editor ) {
                    editor.on( 'init', function( e ) {
                        $( '.overview__description-action .btn' ).hide();
                    } );
                    editor.on( 'FullscreenStateChanged', function( e ) {
                        if ( e.state ) {
                            $( '.overview__publication-action-fullscreen' ).addClass( 'in' );
                        }
                        else {
                            $( '.overview__publication-action-fullscreen' ).removeClass( 'in' );
                        }
                    } );
                };
            }
        },
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';

    viewer.toggle = {
            
            init: function() {
                let $visibilityToggles = $("input[data-toggle-action]");
                if($visibilityToggles.length > 0) {
                    $visibilityToggles.each( (index, element) => {
                        let action = $(element).attr("data-toggle-action");
                        let target = $(element).attr("data-toggle-target");
                        let checked = $(element).is(":checked");
                        let $target = $(target);
                        if(action && checked && $target.length > 0) {
                            switch(action) {
                                case "hide":
                                    $target.hide();
                                    break;
                                case "show": 
                                    $target.show();
                                    break;
                            }
                            let toggleSelector = "input[data-toggle-target='"+target+"']";
                            $("body").on("change", toggleSelector, (event) => {
                                if($(event.target).is(":checked")) {
                                    $target.animate({
                                        height: "toggle",
                                        opacity: "toggle"
                                    }, 250);
                                }
                            })
                        }
                    } )
                }
            }
    
    }
    
	return viewer;
    
} )( viewerJS || {}, jQuery );
var viewerJS = ( function( viewer ) {
    'use strict';
    

    viewer.Translator = function(restApiUrl, defaultLanguage) {
        this.keys = [];
        this.restApiUrl = restApiUrl;
        this.language = defaultLanguage
    }
    
    /**
     * Fetches a list of translations for all given message keys. 
     * These are then returned for the keys when calling translator.translate()
     * 
     * @param keys  a list of message key strings to translate
     * @param restApiUrl    The base url to the viewer rest api to use
     * @defaultLanguage the language to be used as default
     * 
     */
    viewer.Translator.prototype.init = function(keys) {
        return this.addTranslations(keys);
    }
    
    viewer.Translator.prototype.addTranslations = function(keys) {
        if(keys == undefined) {
            return Promise.reject("No keys given to translate");
        }
        if(viewer.isString(keys)) {
            keys = [keys];
        }
        keys = keys.filter(key => key != undefined && key.length > 0).filter(key => this.keys && !this.keys.includes(key));
        if(keys && keys.length > 0) {  
            let keyList = keys.join(",");
            let url = this.restApiUrl + "localization/translations?keys=" + keyList;
            return fetch(url)
            .then( response => response.json() )
            .then( function(json) {
                if(this.translations) {
                    this.translations = $.extend(true, this.translations, json);
                } else {                
                    this.translations = json;
                }
                this.keys = this.keys ? this.keys.concat(keys) : keys;
            }.bind(this))
            .catch(error => {
                console.error("Error fetching " + url + ": " + error);
                this.translations = {};
            });
        } else {
            return Promise.resolve();
        }
    }

    
    /**
     * Returns a translation for the given message key in the given language. 
     * If language is undefined, the language property of Crowdsourcing is used
     * if no translation was found, the key itself is returned
     * Requires the method Crowdsourcing.initTranslations() to be called first 
     */
    viewer.Translator.prototype.translate = function(key, language) {
        if(!language) {
            language = this.language;
        }
        if(viewer.isString(key)) {            
            if(!this.translations) {
                console.warn("Must call 'initTranslations' before translating");
                return key;
            }
            if(!this.translations[key]) {
                console.warn("message key " + key + " not initialized");
                return key;
            }
            let translation = viewerJS.getMetadataValue(this.translations[key], language);
            if(!translation) {
                translation = viewerJS.getMetadataValue(this.translations[key], this.fallbackLanguage);
            }
            return translation;
        } else {
            let translation = viewerJS.getMetadataValue(key, language);
            if(!translation) {
                translation = viewerJS.getMetadataValue(key, this.language);
            }
            return translation;
        }

    }
        
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
        commentEditLoader: '.user-comments__comment-content-loader'
    };
    
    viewer.userComments = {
        /**
         * Method which initializes all required events to edit comments.
         * 
         * @method init
         * @example
         * 
         * <pre>
         * $( document ).ready( function() {
         *     viewerJS.userComments.init();
         * } );
         * </pre>
         */
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.userComments.init' );
                console.log( '##############################' );
            }
            
            // clear texarea for new comments
            if ( $( '#userCommentAdd' ).val() !== '' ) {
                $( '#userCommentAdd' ).focus().val( '' );
            }
            
            // edit comment
            $('[data-edit="comment"]').on('click', function() {        		
        		$(this).parent().removeClass('in');
        		$(this).parents('.user-comments__comment-content-options').find('.user-comments__comment-content-options-cancel, .user-comments__comment-content-options-save').addClass('in');
        		$(this).parents('.user-comments__comment-content').find('.user-comments__comment-content-options-text').removeClass('in');
        		$(this).parents('.user-comments__comment-content').find('.user-comments__comment-content-options-text-edit').addClass('in');
        		$(this).parents('.user-comments__comment-content').find('.user-comments__comment-content-options-text-edit textarea').focus();
        	});
        	
        	// cancel edit
            $('[data-edit="cancel"]').on('click', function() {
        		$(this).parents('.user-comments__comment-content-options').find('.user-comments__comment-content-options-cancel, .user-comments__comment-content-options-save').removeClass('in');
        		$(this).parents('.user-comments__comment-content-options').find('.user-comments__comment-content-options-edit').addClass('in');
        		$(this).parents('.user-comments__comment-content').find('.user-comments__comment-content-options-text').addClass('in');
        		$(this).parents('.user-comments__comment-content').find('.user-comments__comment-content-options-text-edit').removeClass('in');
        	});
            
            // show/hide loader on AJAX calls
            $('[data-edit="save"]').on('click', function() {
            	window.currContent = $( this ).parents('.user-comments__comment-content');
            	window.currContent.find( _defaults.commentEditLoader ).show();
        	});
            
            if ( $( _defaults.commentEditLoader ).is(":visible") ) {
            	jsf.ajax.addOnEvent( function( data ) {
            		var ajaxstatus = data.status;
            		
            		switch ( ajaxstatus ) {    
            		case "success":
            			window.currContent.find( _defaults.commentEditLoader ).hide();
            			break;
            		}
            	} );            	
            }
            
        }
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _bookshelfDropdown = false;
    var _defaults = {};
    
    viewer.userDropdown = {
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.userDropdown.init' );
                console.log( '##############################' );
            }
            
            // check if bookmarkdropdown exist
            if ( $( '.bookmark-navigation__dropdown:visible' ) ) {
                _bookshelfDropdown = true;
            }
            // user dropdown
            $( '[data-toggle="user-dropdown"]' ).on( 'click', function( event ) {
                event.stopPropagation();
                
                // hide bookmarkdropdow if exist and hide language dropdown panel
                if ( _bookshelfDropdown ) {
                    $( '.bookmark-navigation__dropdown' ).hide();
                    $( '.bookmark-popup' ).remove();
                }
                // hide collection panel if exist
                if ( $( '.navigation__collection-panel' ).length > 0 ) {
                    $( '.navigation__collection-panel' ).hide();
                }

                $(this).next( '.login-navigation__user-dropdown' ).fadeToggle( 'fast' );
            } );
            
            // remove dropdown by clicking on body
            $( 'body' ).on( 'click', function( event ) {
                var target = $( event.target );
                var dropdown = $( '.login-navigation__user-dropdown' );
                var dropdownChild = dropdown.find( '*' );
                
                if ( !target.is( dropdown ) && !target.is( dropdownChild ) ) {
                    dropdown.hide();
                }
            } );
        }
    };
   
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
     
    var _debug = false;
    var _userComments = {};
        
    viewer.userLogin = {
    	/**
    	 * @description Method to initialize the user login module.
    	 * @method init
    	 * */
         init : function() {
           	if ( _debug ) {
           		console.log( 'INIT: viewerJS.userLogin' );
           	}
            	
          	// set comments object to session storage
           	if ( sessionStorage.getItem( 'userComments' ) == undefined || sessionStorage.getItem( 'userComments' ) === null ) {
           		sessionStorage.setItem( 'userComments', JSON.stringify( _userComments ) );           		
           	}
            	
           	// toggle login
           	$( 'body' ).on( 'click', '[data-toggle="login"]', function() {
           		if ( $( this ).attr( 'data-target' ) ) {
           			_setUserCommentsStatus( $( this ).attr( 'data-target' ) );
           			
           			$( '#userLogin' ).addClass( 'active' );
           			$( 'html' ).addClass( 'no-overflow' );
           		}
           		else {
           			_unsetUserCommentsStatus();
           			
           			$( '#userLogin' ).addClass( 'active' );     
           			$( 'html' ).addClass( 'no-overflow' );
           		}
           	} );
            	
           	// hide login by clicking on body
           	$( 'body' ).on( 'click', '#userLogin > .fa-times', function( event ) {
           		_unsetUserCommentsStatus();
           		$( '#userLogin' ).removeClass( 'active' );
           		$( 'html' ).removeClass( 'no-overflow' );
           	} );
           	
           	// jump to user comments target if set
           	_jumpToComments();
            	
           	// toggle retrieve account
           	$( 'body' ).on( 'click', '[data-open="retrieve-account"]', function() {
           		$( '#userLoginSelectLoginWrapper, #loginType, #loginTypeCreateAccount, #userLoginOpenId, #userLoginCreateAccount' ).hide();
        		$( '#loginTypeRetrieveAccount' ).show();
        		$( '[id*="userEMailToRetrieve"]' ).focus();
           	} );
           	$( 'body' ).on( 'click', '[data-close="retrieve-account"]', function() {
           		$( '#loginTypeExternal, #loginTypeRetrieveAccount, #loginTypeCreateAccount' ).hide();
           		$( '#userLoginSelectLoginWrapper, #loginType, #userLoginOpenId, #userLoginCreateAccount' ).show();
           	} );            	
            	
           	// toggle create account
           	$( 'body' ).on( 'click', '[data-open="create-account"]', function() {
           		$( '#userLoginSelectLoginWrapper, #loginType, #loginTypeRetrieveAccount, #userLoginOpenId, #userLoginCreateAccount' ).hide();
           		$( '#loginTypeCreateAccount' ).show();
           		$( '.user-login-modal__create-account-email-input' ).focus();
           		$('.user-login-modal__header-title').hide();
           		$('.user-login-modal__header-title-create-account').show();
           		
           	} );
           	$( 'body' ).on( 'click', '[data-close="create-account"]', function() {
           		$( '#loginTypeExternal, #loginTypeRetrieveAccount, #loginTypeCreateAccount' ).hide();
           		$( '#userLoginSelectLoginWrapper, #loginType, #userLoginOpenId, #userLoginCreateAccount' ).show();
           		$('.user-login-modal__header-title-create-account').hide();
           		$('.user-login-modal__header-title').show();
           	} );
           	
			// accept terms for account creation
           	$('#createAccountAcceptTerms input:nth-of-type(1)').prop('checked', true);

           	if ($('.user-login-modal__terms').length === 1) {
				$('.user-login-modal__create-account-submit').prop('disabled', true);
           	}
           	
			$('#createAccountAcceptTerms input').change(function(){
				if ($('#createAccountAcceptTerms input:nth-of-type(2)').is(':checked')) { 
					$('.user-login-modal__create-account-submit').prop('disabled', false);
				} else if ($('#createAccountAcceptTerms input:nth-of-type(1)').is(':checked'))
					$('.user-login-modal__create-account-submit').prop('disabled', true);
				});
        }
    }
    
    /**
     * @description Method to set the user comments status.
     * @method _setUserCommentsStatus
     * @param {String} target The scroll target to the user comments.
     * */
    function _setUserCommentsStatus( target ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setUserCommentsStatus' );
    		console.log( '--> target: ', target );
    	}
    	
    	var comments = JSON.parse( sessionStorage.getItem( 'userComments' ) );
    	
    	comments.set = true;
		comments.target = target;
		
		sessionStorage.setItem( 'userComments', JSON.stringify( comments ) );
    }
    
    /**
     * @description Method to unset the user comments status.
     * @method _unsetUserCommentsStatus
     * */
    function _unsetUserCommentsStatus() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _unsetUserCommentsStatus' );
    	}
    	
    	var comments = JSON.parse( sessionStorage.getItem( 'userComments' ) );
    	
    	comments.set = false;
    	comments.target = '';
    	
    	sessionStorage.setItem( 'userComments', JSON.stringify( comments ) );
    }
    
    /**
     * @description Method to jump to the user comments target.
     * @method _jumpToComments
     * */
    function _jumpToComments() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _jumpToComments' );
    	}
    	
    	var comments = JSON.parse( sessionStorage.getItem( 'userComments' ) );
    	
    	if ( comments.set && $( '#userCommentAdd' ).length > 0 ) {
    		location.hash = comments.target;
    		$( '#userCommentAdd' ).focus();
    	}
    	else {
    		_unsetUserCommentsStatus();
    	}
    }
        
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    

    viewer.validationStatus = {
        
        init: function() {
            if(_debug)console.log("init validation status")
            if($(".-validation-mark").length) {                
                viewer.jsfAjax.success.subscribe( e => {
                    //mark tinymce editors as validation-input fields to apply colored border if applicable
                    $(".tox.tox-tinymce").addClass("-validation-input");
                    let $validationMessages = $(".-validation-message");
                    if(_debug)console.log("check validation messages ", $validationMessages);
                    $validationMessages.each( (index,message) => {
                        let $message = $(message);
                        let severity = $message.attr("class").replace("-validation-message", "").trim();
                        if(_debug)console.log("set validation severity ", severity);
                        $message.nextAll(".-validation-mark, .-validation-input").addClass(severity);
                    } )
                })
            }
        }
        
    }
    
    return viewer;
    
} )( viewerJS || {}, jQuery );

var viewerJS = ( function( viewer ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
        versions: [],
        json: null,
        imgUrl: '',
        imgPi: '',
        versionLink: '',
        widgetInputs: '',
        widgetList: '',
    };
    
    viewer.versionHistory = {
        /**
         * Method to initialize the version history widget.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {Array} config.versions An array which holds all versions.
         * @param {Object} config.json An JSON-Object which takes all versions.
         * @param {String} config.imgUrl The image URL for the current work.
         * @param {String} config.imgPi The PI for the image of the current work.
         * @param {String} config.versionLink A string placeholder for the final HTML.
         * @param {String} config.widgetInputs A string placeholder for the final HTML.
         * @param {String} config.widgetList A string placeholder for the final HTML.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.versionHistory.init' );
                console.log( '##############################' );
                console.log( 'viewer.versionHistory.init: config = ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // push versions into an array
            $( _defaults.widgetInputs ).each( function() {
                _defaults.versions.push( $( this ).val() );
            } );
            
            if ( _debug ) {
                console.log( 'viewer.versionHistory: versions = ', _defaults.versions );
            }
            
            // append list elements to widget
            for ( var i = 0; i < _defaults.versions.length; i++ ) {
                _defaults.json = JSON.parse( _defaults.versions[ i ] );
                
                if ( _defaults.json.id === _defaults.imgPi ) {
                    // Aktuell geöffnete Version - kein Link
                    _defaults.versionLink = '<li><span>';
                    if ( _defaults.json.label != undefined && _defaults.json.label != '' ) {
                    	_defaults.versionLink += _defaults.json.label;
                    }
                    else {
                    	 _defaults.versionLink += _defaults.json.id;
                    	 if ( _defaults.json.year != undefined && _defaults.json.year != '' ) {
                    		 _defaults.versionLink += ' (' + _defaults.json.year + ')';                    	
                    	 }
                    }
                    _defaults.versionLink += '</span></li>';
                    
                    $( _defaults.widgetList ).append( _defaults.versionLink );
                }
                else {
                    // Vorgänger und Nachfolger jeweils mit Link
                    _defaults.versionLink = '<li><a href="' + _defaults.imgUrl + '/' + _defaults.json.id + '/1/">';
                    if ( _defaults.json.label != undefined && _defaults.json.label != '' ) {
                    	_defaults.versionLink += _defaults.json.label;
                    } else {
                    	_defaults.versionLink += _defaults.json.id;
                    	if ( _defaults.json.year != undefined && _defaults.json.year != '' ) {
                    		_defaults.versionLink += ' (' + _defaults.json.year + ')';
                    	}
                    }
                    _defaults.versionLink += '</a></li>';
                    
                    $( _defaults.widgetList ).append( _defaults.versionLink );
                }
            }
        }
    };
    
    return viewer;
    
} )( viewerJS || {}, jQuery );


 var viewerJS = ( function( viewer ) {
    
    var _debug = false;
    
    if(!rxjs) {
        throw "Missing dependencies for WebSocket";
    }
    
    viewer.WebSocket = function(host, contextPath, socketPath) {
        this.onOpen = new rxjs.Subject();
        this.onMessage = new rxjs.Subject();
        this.onError = new rxjs.Subject();
        this.onClose = new rxjs.Subject();
        
        var protocol = "ws";
        
        if (window.location.protocol == "https:") {
            protocol = "wss";
        }
        
        var socketUrl = protocol + "://" + host + contextPath + socketPath;
        if(_debug) {
            console.log("connecting to viewer session socket at ", socketUrl);
        }
        
        this.socket = new WebSocket(socketUrl);
        this.socket.onopen = (event) => this.onOpen.next(event);
        this.socket.onmessage = (event) => this.onMessage.next(event);
        this.socket.onerror = (event) => this.onError.next(event);
        this.socket.onclose = (event) => this.onClose.next(event);
    };
    
    //pseudo-constant containing path to socket
    viewer.WebSocket.PATH_SESSION_SOCKET = "/session.socket";
    viewer.WebSocket.PATH_CAMPAIGN_SOCKET = "/crowdsourcing/campaign.socket";
    viewer.WebSocket.PATH_CONFIG_EDITOR_SOCKET = "/admin/config/edit.socket";
    viewer.WebSocket.PATH_DOWNLOAD_TASK = "/tasks/download/monitor.socket";

    //prototype methods
    viewer.WebSocket.prototype.sendMessage = function(message) {
        if(_debug)console.log("send ", message, " open: ", this.isOpen());
        this.socket.send(message);
    };
    viewer.WebSocket.prototype.close = function(reason, statusCode) {
        this.socket.close(statusCode, reason);
    };     
    viewer.WebSocket.prototype.isOpen = function() {
        return this.socket && this.socket.readyState === WebSocket.OPEN;
    };     
     
    return viewer;
    
 } )( viewerJS || {}, jQuery );
 
 
//var highlightCurrentSelection = function( $Obj ) {
//	// reset styles for all li elements
//$( '#user_generated_content_nav li' ).removeClass( 'ugc-highlight' );
//
//// highlight clicked li element
//$Obj.addClass( 'ugc-highlight' );
//};
//
//var coordinates = {
//	name: 'ugc',
//    	displayTooltip: true,
//    	coordinates:  #{contentBean.getCurrentUGCCoords(activeDocumentBean.viewManager.currentPage)}
//    };
//   
//    // console.log("crowdsourcing coordinates: ", coordinates);
//if(configViewer.image && coordinates) {
//	if(!configViewer.image.highlightCoords) {
//		configViewer.image.highlightCoords = [];
//	}
//	configViewer.image.highlightCoords.push(coordinates);
//}

var viewerJS = (function(viewer) {
	'use strict';

	var _debug = false;
	var _parentPos = 0;

	viewer.widgetToc = {
		/**
		 * @method init
		 * @description Initializes the widget toc module.
		 */
		init : function() {
			if ( _debug ) {
                console.log( '##############################' );
                console.log( 'viewer.widgetToc.init' );
                console.log( '##############################' );
            }
			
			// hide loader and overlay after successful ajax request
	        if ( typeof jsf !== undefined ) {
	            jsf.ajax.addOnEvent( function( data ) {
	                var status = data.status;
	                var source = data.source;
	                var iddoc = $( source ).parents( '.widget-toc__element' ).attr( 'data-iddoc' );
	                var widgetToc = $(source).parents('#widgetToc');

	                switch ( status ) {
	                	case 'begin':
	                		if (widgetToc.length) {
		                		$( '[data-iddoc*="iddoc"]' ).removeClass( 'active' );
		                		$( '.widget-toc__loader, .widget-toc__overlay' ).show();
		                		
		                		// hide all tooltips on ajax load
		                		$('[data-toggle="tooltip"]').tooltip('dispose');
	                		}
	                		break;
	                	case 'success':
	                		if ( iddoc !== undefined ) {
	                			_parentPos = $( '[data-iddoc="' + iddoc + '"]' ).position().top;
	                			$( '[data-iddoc="' + iddoc + '"]' ).addClass( 'active' );
	                			$( '.widget-toc__elements' ).scrollTop( _parentPos );	                			
	                		}
	                    	
	                        $( '.widget-toc__loader, .widget-toc__overlay' ).hide();
	                        break;
	                }
	            } );
	        }
	        else {
	        	$( '.widget-toc__loader, .widget-toc__overlay' ).hide();	        	
	        }
		}
	};

	return viewer;

})(viewerJS || {}, jQuery);
var viewerJS = ( function( viewer ) {
    'use strict'; 
    
    //ifndef    
    if(viewer.GeoMap) {
    	return;
    }
        
    // default variables
    var _debug = false;
    
    var _defaults = {
            mapId : "geomap",
            layers: [],
            minZoom : 1,
            maxZoom : 19,
            initialView : {
                zoom: 5,
                center: [11.073397, 49.451993] //long, lat
            },
            maxBoundsViscosity: 0.0,
            tilesource: "mapbox",
            mapBoxToken : undefined,
            language: "de",
            fixed: false,
            heatmap: true,
            
    }
    
    viewer.GeoMap = function(config) {
        
        
        if (typeof L == "undefined") {
            throw "leaflet.js is not loaded";
        }
        this.config = $.extend( true, {}, _defaults, config );
        if(_debug) {
            console.log("load GeoMap with config ", this.config);
        }
        
        viewer.GeoMap.maps.set(this.config.mapId, this);

        this.layers = [];
        this.initialized = false;
        
        this.onMapRightclick = new rxjs.Subject();
        this.onMapClick = new rxjs.Subject();
        this.onMapMove = new rxjs.Subject();
        this.onActiveLayerChange = new rxjs.Subject();
        this.onInitialized = new Promise( (resolve, reject) => {
        	this.resolveInitialization = resolve;
        	this.rejectInitialization = reject;
        });

        this.config.layers.forEach(layer => this.addFeatureGroup(layer, layer.features));

		viewer.GeoMap.allMaps.push(this);
    }
    
    viewer.GeoMap.maps = new Map();

    viewer.GeoMap.prototype.init = function(view) {
       
       if(_debug)console.log("init geomap with", view);
       
        if(this.map) {
            this.map.remove();
        }
        //init mapBox config. If no config object is set in viewerJS, only get token from viewerJS
        //if that doesn't exists, don't create mapBox config
        if(!this.config.mapBox && viewerJS.getMapBoxToken()) {
            if(viewerJS.mapBoxConfig) {
                this.config.mapBox = viewerJS.mapBoxConfig;
            } else {
                this.config.mapBox = {
                        token : viewerJS.getMapBoxToken()
                }
            }
        }
        if(this.config.mapBox && !this.config.mapBox.user) {
            this.config.mapBox.user = "mapbox";
        }
        if(this.config.mapBox && !this.config.mapBox.styleId) {
            this.config.mapBox.styleId = "streets-v11";
        }
        
        if(_debug) {
            console.log("init GeoMap with config ", this.config);
        }
        
        this.map = new L.Map(this.config.element ? this.config.element : this.config.mapId, {
            zoomControl: false,
            doubleClickZoom: !this.config.fixed,
            scrollWheelZoom: !this.config.fixed,
            dragging: !this.config.fixed,
            keyboard: !this.config.fixed,
            maxBoundsViscosity: this.config.maxBoundsViscosity,
            // Fix desktop safari browsers: 
            // disabling the tap option shows popups when clicking on geoMap markers in safari
            // it should however be set to true when a mobile version of Safari is used
            tap: viewer.iOS() ? true : false
        });
        this.htmlElement = this.map._container;
        
        this.map.whenReady(e => {
        	this.resolveInitialization(this);
        	this.initialized = true;
        });
        if(this.config.tilesource.toLowerCase() == "mapbox" && this.config.mapBox) {
            let url = 'https://api.mapbox.com/styles/v1/{1}/{2}/tiles/{z}/{x}/{y}?access_token={3}'
                .replace("{1}", this.config.mapBox.user)
                .replace("{2}", this.config.mapBox.styleId)
                .replace("{3}", this.config.mapBox.token);
            var mapbox = new L.TileLayer(url, {
                        tileSize: 512,
                        zoomOffset: -1,
                        minZoom: this.config.minZoom,
                		maxZoom: this.config.maxZoom,
                        attribution: '© <a href="https://apps.mapbox.com/feedback/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    });
            if(_debug) {                
                console.log("Add mapbox layer");
            }
            this.map.addLayer(mapbox);
        } else {            
            var osm = new L.TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                minZoom: this.config.minZoom,
                maxZoom: this.config.maxZoom,
                attribution: 'Map data &copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
            });
            if(_debug) {                         
                console.log("add openStreatMap layer");
            }
            this.map.addLayer(osm);
        }
        
        //this.setView(this.config.initialView);
        
        //init map events
        rxjs.fromEvent(this.map, "moveend").pipe(rxjs.operators.map(e => this.getView())).subscribe(this.onMapMove);
        rxjs.fromEvent(this.map, "contextmenu")
        .pipe(rxjs.operators.map(e => this.layers[0].createGeoJson(e.latlng, this.map.getZoom(), this.map.getCenter())))
        .subscribe(this.onMapRightclick);
        rxjs.fromEvent(this.map, "click")
        .pipe(rxjs.operators.map(e => this.layers[0].createGeoJson(e.latlng, this.map.getZoom(), this.map.getCenter())))
        .subscribe(this.onMapClick);
            
		let allFeatures = this.config.layers.map(layer => layer.features).flat().filter(f => f != undefined);
        if(allFeatures && allFeatures.length > 0) {
        	this.setViewToFeatures(allFeatures, true);
        } else if(view){                                                    
			this.setView(view); 
        }
        
        return this.onInitialized;
        
    }
    
    viewer.GeoMap.prototype.addFeatureGroup = function(featureGroupConfig, features) {
		if(!featureGroupConfig.language) {
			featureGroupConfig.language = this.config.language;
		}
		let featureGroup = new viewer.GeoMap.featureGroup(this, featureGroupConfig);
		this.layers.push(featureGroup);
		if(this.initialized) {
			featureGroup.init(features, false);
		} else {
			this.onInitialized
			.then(() => featureGroup.init(features, false));
		}
		return featureGroup;
	}
    
    viewer.GeoMap.prototype.initGeocoder = function(element, config) {
    	if(this.config.mapBox && this.config.mapBox.token) {
	    	config = $.extend(config ? config: {}, {
	    		accessToken : this.config.mapBox.token,
	    		mapboxgl: mapboxgl
	    	});
	    	if(_debug)console.log("init geocoder with config" , config);
	    	this.geocoder = new MapboxGeocoder(config);
	    	this.geocoder.addTo(element);
	    	this.geocoder.on("result", (event) => {
	    		//console.log("geocoder result",  event.result, event.result.center, event.result.place_type, event.result.place_name);
	    		
	    		if(event.result.bbox) {
	    			let p1 = new L.latLng(event.result.bbox[1], event.result.bbox[0]);
	    			let p2 = new L.latLng(event.result.bbox[3], event.result.bbox[2]);
	    			let bounds = new L.latLngBounds(p1, p2);
	    			this.map.fitBounds(bounds);
	    		} else {
		    		let view = {
		                "zoom": this.config.maxZoom,
		                "center": event.result.center
		            }
		            this.setView(view);
	    		}
	    	});
    	} else {
    		console.warn("Cannot initialize geocoder: No mapbox token");
    	}
    }
    
    /**
     * Center must be an array containing longitude andlatitude as numbers - in that order
     * zoom must be a number
     */
    viewer.GeoMap.prototype.setView = function(view, panning) {
        if(_debug) {
            console.log("set view to ", view);
        }
        this.view = view;
        if(!view) {
            return;
        } else if(typeof view === "string") {
            view = JSON.parse(view);
        }
        view.zoom = (view.zoom == undefined || Number.isNaN(view.zoom)) ? 1 : Math.max(view.zoom, 1);
        if(view.center) {
            let center = L.latLng(view.center[1], view.center[0]);
            if(view.zoom) {
                this.map.setView(center, view.zoom, {animate: panning});
            } else {                
                this.map.panTo(center, {animate: panning});
            }
        } else if(view.zoom) {   
            this.map.setZoom(view.zoom);
        }
    }
    
    viewer.GeoMap.prototype.getView = function() {
        let zoom  = this.map.getZoom();
        let center = this.map.getCenter();
        return {
            "zoom": zoom,
            "center": [center.lng, center.lat]
        }
    }
    
    viewer.GeoMap.prototype.getViewAroundFeatures = function(features, defaultZoom, zoomPadding) {
        if(!defaultZoom) {
            defaultZoom = this.map.getZoom();
        }
        if(!zoomPadding) {
        	zoomPadding = 0.2;
        }
        if(!features || features.length == 0) {
            return undefined;
        } else {
            if(_debug) {
	        	console.log("view around ", features);
            }
        	let bounds = L.latLngBounds();
        	features.map(f => L.geoJson(f).getBounds()).forEach(b => bounds.extend(b));
            let center = bounds.getCenter();
            let diameter = this.getDiameter(bounds);
            return {
                "zoom": diameter > 0 ?  Math.max(1, this.map.getBoundsZoom(bounds.pad(zoomPadding))) : defaultZoom,
                "center": [center.lng, center.lat]
            }
        }
    }
    
    viewer.GeoMap.prototype.setViewToFeatures = function(features, setViewToHighlighted, zoom) {
    	if(features && features.length > 0) {
            if(!zoom) {
                zoom = this.view ? this.zoom : this.config.initialView.zoom;
            }
            let highlightedFeatures = features.filter(f => f?.properties?.highlighted);
            //console.log(" highlightedFeatures", highlightedFeatures);
            if(setViewToHighlighted && highlightedFeatures.length > 0) {
            	let viewAroundFeatures = this.getViewAroundFeatures(highlightedFeatures, zoom, 0.5);
	            this.setView(viewAroundFeatures);
            } else {
	            let viewAroundFeatures = this.getViewAroundFeatures(features, zoom);
	            this.setView(viewAroundFeatures);
            }
        }
    } 

    
    viewer.GeoMap.prototype.getZoom = function() {
        return this.map.getZoom();
    }

    
    viewer.GeoMap.prototype.close = function() {
        this.onMapClick.complete();
        this.layers.forEach(l => l.close());
        this.onMapMove.complete();
        if(this.map) {
            this.map.remove();
        }
    }

	viewer.GeoMap.prototype.setActiveLayers = function(groups) {
		this.layers.forEach(layer => {
			if(groups.includes(layer)) {
				layer.active = true;
				layer.showMarkers();
			} else {
				layer.active = false;
				layer.hideMarkers();
			}
		})
		this.onActiveLayerChange.next(this.getActiveLayers());
	}

	viewer.GeoMap.prototype.getActiveLayers = function() {
		return this.layers.filter(l => l.active !== false);
	}
    
    //static methods to get all loaded maps
    viewer.GeoMap.allMaps = [];
    

    return viewer;
    
} )( viewerJS || {}, jQuery );



var viewerJS = ( function( viewer ) {
    'use strict'; 
        
    // default variables
    var _debug = false;
 
    var _defaults_featureGroup = {
			features: [],
            allowMovingFeatures: false,
            clusterMarkers : false,
            popover: undefined,
            emptyMarkerMessage: undefined,
            popoverOnHover: false,
            markerIcon : {
				html: '<div><span>\${count}</span></div>', 	
			},
			cluster: {
                spiderfyDistanceMultiplier: 1.0,
                showCoverageOnHover: true,
                maxClusterRadius: 80,
       		},
            search: {
            	openSearchOnMarkerClick: true,
            	searchUrlTemplate : '/viewer/search/-/WKT_COORDS:"Intersects(POINT({lng} {lat})) distErrPct=0"/1/-/-/',
            	linkTarget : "_blank"
            },
            heatmap: {
            	enabled: false,
            	heatmapUrl: "/viewer/api/v1/index/spatial/heatmap/{solrField}",
            	featureUrl: "/viewer/api/v1/index/spatial/search/{solrField}",
            	filterQuery: "BOOL_WKT_COORDS:*",
		        labelField: "LABEL",
            },
            style: {
            	stroke: true,
            	color: '#3388ff',
            	highlightColor: '#d9534f',
            	weight: 3,
            	opactity: 1.0,
            	fill: true,
            	fillColor: undefined, //defaults to color
            	fillOpacity: 0.1,
            }
    }
    
        
    viewer.GeoMap.featureGroup = function(geoMap, config) {
 		this.geoMap = geoMap;
        this.config = $.extend( true, {}, _defaults_featureGroup, geoMap.config.layer, config );
        if(_debug) {
            console.log("create featureGroup with config ",  config);
        }

		this.markerIdCounter = 1;
        this.markers = [];
        this.areas = [];
        this.highlighted = []; //list of currently highlighted colors

        this.onFeatureClick = new rxjs.Subject();
        this.onFeatureMove = new rxjs.Subject();

    }
    
    viewer.GeoMap.featureGroup.prototype.init = function(features) {
		this.initFeatures(features);
		if(this.config.heatmap.enabled) {	        	    
			this.initHeatmap();
		}
	}
		
	viewer.GeoMap.featureGroup.prototype.initFeatures = function(features) {

        this.markerIdCounter = 1;
        this.markers = [];
        this.areas = [];
        this.highlighted = []; //list of currently highlighted colors


        if(this.layer) {
        	this.geoMap.map.removeLayer(this.layer);
        }
		this.layer = new L.FeatureGroup();
        
        //init feature layer
        this.locations = L.geoJSON([], {
            
            style: function(feature) {
            	if(feature.properties && feature.properties.highlighted) {
					let style = $.extend(true, {}, this.config.style);
					style.color = this.config.style.highlightColor;
					style.fillColor = this.config.style.highlightColor;
					return style;       		
            	} else {
	            	return this.config.style;
            	}
            }.bind(this),
            
            pointToLayer: function(geoJsonPoint, latlng) {
				let icon = this.getMarkerIcon(geoJsonPoint.properties);
				let iconName = icon.options.name;
				let zOffset = iconName == "maps__marker_person" ? 0 : 2000;
				//console.log("icon for marker", icon, iconName, zOffset);
                let marker = L.marker(latlng, {
                    draggable: this.config.allowMovingFeatures,
                    icon: this.getMarkerIcon(geoJsonPoint.properties),
                    count: this.getCount(geoJsonPoint.properties),
                    zIndexOffset: zOffset
                });
                return marker; 
            }.bind(this),
            
            onEachFeature: function(feature, layer) {
            	if(_debug)console.log("onEachFeature ", feature, layer, this);
            	
            	layer.id = feature.id;
                layer.view = feature.view;
                    
                layer.getId = function() {
                    return this.id;
                }
                
                rxjs.fromEvent(layer, "dragend")
                .pipe(rxjs.operators.map(() => this.openPopup(layer)), rxjs.operators.map(() => this.updatePosition(layer)))
                .subscribe(this.onFeatureMove);
                rxjs.fromEvent(layer, "click").pipe(rxjs.operators.map(e => layer.feature)).subscribe(this.onFeatureClick);


				let title = viewerJS.getMetadataValue(feature.properties.title, this.config.language);
       			let desc = viewerJS.getMetadataValue(feature.properties.description, this.config.language);      
       			if(this.config.popover && feature.properties && (title || desc || this.config.emptyMarkerMessage)) {                    
                    if(this.config.popoverOnHover) {                    
                        rxjs.fromEvent(layer, "mouseover").subscribe(() => layer.openPopup());
                        rxjs.fromEvent(layer, "mouseout").subscribe(() => layer.closePopup());
                    }
                    layer.bindPopup(() => this.createPopup(layer),{
                    	closeButton: !this.config.popoverOnHover,
                    	autoPan: false,
                    	closeOnClick: false,
                    });
                }
            	this.markers.push(layer);    
                if(this.cluster) {
                    this.cluster.addLayer(layer);
                }
            }.bind(this)
        });
        
        //add layer
        this.geoMap.map.addLayer(this.layer);
        if(this.config.clusterMarkers) {        
            try {                
                this.cluster = this.createMarkerCluster();
                this.layer.addLayer(this.cluster);
            } catch(error) {
                console.warn(error);
                this.layer.addLayer(this.locations);
            }
        } else {
            this.layer.addLayer(this.locations);
        }
        
        
        if(features && features.length > 0) {
            features
            .filter(f => f.properties.visible !== false)
            .sort( (f1,f2) => this.compareFeatures(f1,f2) )
            .forEach(feature => {
				feature.layer = this;
            	let type = feature.geometry.type;
            	if(_debug)console.log("add feature for " + type, feature);
            	this.addMarker(feature);
            })
        }
    }
    
viewer.GeoMap.featureGroup.prototype.initHeatmap = function() {

        	let heatmapUrl = this.config.heatmap.heatmapUrl;
        	let featureUrl = this.config.heatmap.featureUrl;
        	
        	this.heatmap = L.solrHeatmap(heatmapUrl, featureUrl, this, {
        	    field: "WKT_COORDS",
        	    type: "clusters",
        	    filterQuery: this.config.heatmap.filterQuery,
        	    labelField: this.config.heatmap.labelField,
        	    queryAdapter: "goobiViewer"    
        	});
        	this.heatmap.addTo(this.geoMap.map);        
    }

    viewer.GeoMap.featureGroup.prototype.isEmpty = function() {
    	return this.markers.length == 0 && this.areas.length == 0;
    }
    
    
    
    viewer.GeoMap.featureGroup.prototype.compareFeatures = function(f1, f2) {
    
    	return this.getSize(f2) - this.getSize(f1);
    
    }
    
    
    viewer.GeoMap.featureGroup.prototype.getSize = function(feature) {
    	if(feature.geometry.type == "Point") {
    		return 0;
    	} else {
    		let polygon = L.polygon(feature.geometry.coordinates);
    		return this.geoMap.getDiameter(polygon.getBounds());
    	}
    }

    
    viewer.GeoMap.featureGroup.prototype.createMarkerCluster = function() {
		let baseConfig = {
			 maxClusterRadius: 80,
            zoomToBoundsOnClick: !this.geoMap.config.fixed,
            iconCreateFunction: function(cluster) {
                return this.getClusterIcon(this.getClusterCount(cluster));
            }.bind(this)
		}
		
		let clusterConfig = $.extend(true, {}, baseConfig, this.config.cluster);
		let paneName = this.config.cluster.clusterPane;
		let paneZIndex = this.config.cluster.zIndex;
		if(paneName) {
			let pane = this.geoMap.map.createPane(paneName);
			if(paneZIndex){
				pane.style.zIndex = paneZIndex;
			}
		}
        let cluster = L.markerClusterGroup(clusterConfig);
        if(clusterConfig.showCoverageOnHover && !this.geoMap.config.fixed) {            
            cluster.on('clustermouseover', function (a) {
                this.removePolygon();
                this.shownLayer = a.layer;
                this.polygon = L.polygon(a.layer.getConvexHull());
                this.layer.addLayer(this.polygon);
            }.bind(this));
            cluster.on('clustermouseout', () => this.removePolygon());
            this.geoMap.map.on('zoomend', () => this.removePolygon());
        }
        return cluster;
    }
    
    viewer.GeoMap.featureGroup.prototype.getClusterCount = function(cluster) { 
	  	let count = cluster.getAllChildMarkers().map(child => this.getCount(child.feature.properties)).reduce((a, b) => a + b, 0)
	  	return count;
	  }
    
    
    viewer.GeoMap.featureGroup.prototype.removePolygon = function() {
        if (this.shownLayer) {
            this.shownLayer.setOpacity(1);
            this.shownLayer = null;
        }
        if (this.polygon) {
            this.geoMap.map.removeLayer(this.polygon);
            this.polygon = null;
        }
    };
    
    viewer.GeoMap.featureGroup.prototype.openPopup = function(marker) {
        try{
            marker.openPopup(); 
        } catch(e) {
            //swallow
        }
    }
    
    viewer.GeoMap.featureGroup.prototype.highlightMarker = function(feature) {
        if(feature) {            
            let marker = this.getMarker(feature.id);
            let icon  = marker.getIcon();
            
            if(this.config.markerIcon.useDefault && this.config.markerIcon.highlightIcon) { 
        		icon = new L.Icon.Default({
        			imagePath : this.geoMap.config.iconPath + "/"
        		});
        		icon.options.iconUrl = this.config.markerIcon.highlightIcon;
				icon.options.iconRetinaUrl = this.config.markerIcon.highlightIcon;
            } else {
	            icon.options.defaultColor = icon.options.markerColor;
	            icon.options.markerColor = icon.options.highlightColor;				
			}
            marker.setIcon(icon);
            this.highlighted.push(marker);
        } else {
            this.highlighted.forEach(marker => {
                let icon  = marker.getIcon();
                if(this.config.markerIcon.useDefault) {
					icon = new L.Icon.Default({
        				imagePath : this.geoMap.config.iconPath + "/"
        			});
				}else{					
	                icon.options.markerColor = icon.options.defaultColor;
	                icon.options.defaultColor = undefined;
				}
                marker.setIcon(icon);
                let index = this.highlighted.indexOf(marker);
                this.highlighted.splice(index, 1);
            })
        }
    }

    
    viewer.GeoMap.featureGroup.prototype.getClusterIcon = function(num) {
		
		if(this.config.markerIcon?.type == 'DivIcon') {
			let options =  $.extend(true, {}, this.config.markerIcon);
			if(!options) {
				throw "marker icon of type 'divIcon' needs an 'options' properties containing the constructor options to pass to the icon";
			} else {
				options.html = options.html.replaceAll("${count}", num);
				options.iconSize = new L.Point(40, 40);
				return new L.DivIcon(options);
			}
		} else {			
	        let iconConfig = {
	            icon: "fa-number",
	            number: num,
	            svg: true,
	            prefix: "fa",
	            iconRotate: 0
	        }; 
	        if(this.config.markerIcon) {
	            iconConfig = $.extend(true, {}, this.config.markerIcon, iconConfig);
	            iconConfig.name = ""; //remove name because it shows up as a label underneath the marker
	        }
	        let icon = L.ExtraMarkers.icon(iconConfig);
	        return icon;
		}
		
    }
    
    viewer.GeoMap.featureGroup.prototype.getMarkerIcon = function(properties) {
    	
    	let count = this.getCount(properties); 
    	let highlighted = properties?.highlighted;
        if(this.config.markerIcon && !jQuery.isEmptyObject(this.config.markerIcon)) {
        	if(this.config.markerIcon.useDefault) { 
        		if(this.config.markerIcon.highlightIcon && highlighted) {
        		let icon = new L.Icon.Default({
        			imagePath : this.geoMap.config.iconPath + "/"
        		});
        		icon.options.iconUrl = this.config.markerIcon.highlightIcon;
				icon.options.iconRetinaUrl = this.config.markerIcon.highlightIcon;
        		//console.log("use hightlight icon ", icon);
        		return icon; 
        		} else {
        			return new L.Icon.Default();
        		}
        	} else if(this.config.markerIcon.type) {
				if(this.config.markerIcon.type == 'DivIcon') {
					let options =  $.extend(true, {}, this.config.markerIcon);
					options.html = options.html.replace("${count}", "1");
					options.iconSize = new L.Point(40, 40);
					let icon = count > 1 ? this.getClusterIcon(count) : new L.DivIcon(options);
					return icon;
				} else {
					let icon = count > 1 ? this.getClusterIcon(count) : L.ExtraMarkers.icon(this.config.markerIcon);
		        	icon.options.name = "";	//remove name property to avoid it being displayed on the map
		            if(this.config.markerIcon.shadow === false) {                
		                icon.options.shadowSize = [0,0];
		            }
		            if(highlighted) {
		            	icon.options.markerColor = this.config.markerIcon.highlightColor;
		            }
		            return icon;
				}
        	} else {
	            let icon = count > 1 ? this.getClusterIcon(count) : L.ExtraMarkers.icon(this.config.markerIcon);
	        	icon.options.name = "";	//remove name property to avoid it being displayed on the map
	            if(this.config.markerIcon.shadow === false) {                
	                icon.options.shadowSize = [0,0];
	            }
	            if(highlighted) {
	            	icon.options.markerColor = this.config.markerIcon.highlightColor;
	            }
	            return icon;
            }
        } else {
            return new L.Icon.Default();
        }
    }

	viewer.GeoMap.featureGroup.prototype.getCount = function(properties) {
		if(properties.entities) {
			return properties.entities.filter(e => e.visible !== false).length;
		} else if(properties.count){
			return properties.count;
		} else {
			return 1;
		}
	}
    
    viewer.GeoMap.featureGroup.prototype.updatePosition = function(marker) {
        marker.feature.geometry = marker.toGeoJSON().geometry;
        marker.feature.view = {zoom: this.geoMap.map.getZoom(), center: [marker.getLatLng().lng, marker.getLatLng().lat]};
        return marker.feature;
    }

    
    viewer.GeoMap.featureGroup.prototype.createPopup = function(marker) {
        let title = viewerJS.getMetadataValue(marker.feature.properties.title, this.config.language);
        let desc = viewerJS.getMetadataValue(marker.feature.properties.description, this.config.language);
        if(this.config.popover && (title || desc) ) {
            let $popover = $(this.config.popover).clone();
            $popover.find("[data-metadata='title']").html(title);
            $popover.find("[data-metadata='description']").html(desc);
            $popover.css("display", "block");
            return $popover.get(0);
        } else if(this.config.popover){
            return this.config.emptyMarkerMessage;
        }
    }

    viewer.GeoMap.prototype.normalizePoint = function(p) {
//   		let wrapped = new L.latLng(Math.max(Math.min(p.lat, 90), -90), p.lng - Math.round(p.lng/360)*360);
   		let wrapped = new L.latLng(Math.max(Math.min(p.lat, 90), -90), Math.max(Math.min(p.lng, 180), -180))
    	//console.log("Point ",p, wrapped);
    	return wrapped;
    }

        
    viewer.GeoMap.prototype.getDiameter = function(bounds) {
    	if(!bounds || !bounds.isValid()) {
    		return 0;
    	} else {
		    let diameter = this.map.distance(bounds.getSouthWest(), bounds.getNorthEast());
		    return diameter;
    	}
    }
    
    viewer.GeoMap.featureGroup.prototype.getArea = function(bounds, feature) {
    	if(!bounds || !bounds.isValid()) {
    		return 0;
    	} else {
		    let area = this.geoMap.map.distance(bounds.getSouthWest(), bounds.getNorthWest()) * this.geoMap.map.distance(bounds.getSouthWest(), bounds.getSouthEast())
    	}
    }
    
    viewer.GeoMap.featureGroup.prototype.updateMarker = function(id) {
        let marker = this.getMarker(id);
        if(marker) {            
            marker.openPopup();
        }
    }
    
    viewer.GeoMap.featureGroup.prototype.resetMarkers = function() {
        this.markerIdCounter = 1;
        this.markers.forEach((marker) => {
            marker.remove();
        })
        this.markers = [];
    }

    viewer.GeoMap.featureGroup.prototype.getMarker = function(id) {
        return this.markers.find(marker => marker.getId() == id);
    }
    
    viewer.GeoMap.featureGroup.prototype.getFeatures = function(id) {
        return this.markers.map(marker => marker.feature);
    }

    viewer.GeoMap.featureGroup.prototype.addMarker = function(geoJson) {
        let id = this.markerIdCounter++;
        geoJson.id = id;
        this.locations.addData(geoJson);
        let marker = this.getMarker(id);
        if(_debug) {            
            console.log("Add marker ", marker);
        }
        return marker;
    }


    viewer.GeoMap.featureGroup.prototype.removeMarker = function(feature) {
        let marker = this.getMarker(feature.id);
        marker.remove();
        let index = this.markers.indexOf(marker);
        this.markers.splice(index, 1);
    }
    
    viewer.GeoMap.featureGroup.prototype.removeAllMarkers = function() {
    	this.markers.forEach(m => m.remove());
    	this.initFeatures();
    }
    


    viewer.GeoMap.featureGroup.prototype.createGeoJson = function(location, zoom, center) {
        let id = this.markerIdCounter++;
        var geojsonFeature = {
                "type": "Feature",
                "id": id,
                "properties": {
                    "title": "",
                    "description":""
                },
                "geometry": {
                    "type": "Point",
                    "coordinates": [location.lng, location.lat]
                },
                "view": {
                    "zoom": zoom,
                    "center": [location.lng, location.lat]
                }
            };
        return geojsonFeature;
    }

    viewer.GeoMap.featureGroup.prototype.getMarkerCount = function() {
        return this.markers.length;
    }
    
        
    viewer.GeoMap.featureGroup.prototype.drawPolygon = function(points, centerView) {
    	let config = $.extend({interactive: false}, this.config.style, true); 
    	let polygon = new L.Polygon(points, config);
    	polygon.addTo(this.geoMap.map);
    	this.areas.push(polygon);
    	if(centerView) {
    		this.geoMap.map.fitBounds(polygon.getBounds());
    	}
    	return polygon;
    }
    
   viewer.GeoMap.featureGroup.prototype.drawRectangle = function(points, centerView) {
    	let config = $.extend({interactive: false}, this.config.style, true); 
    	let rect = new L.Rectangle(points, config);
    	rect.addTo(this.geoMap.map);
    	this.areas.push(rect);
    	if(centerView) {
    		this.geoMap.map.fitBounds(rect.getBounds());
    	}
    	return rect;
    }
    
    viewer.GeoMap.featureGroup.prototype.drawCircle = function(center, radius, centerView) {
    	let config = $.extend({interactive: false}, this.config.style, true); 
    	let circle = new L.Circle(center, radius, config);
    	circle.addTo(this.geoMap.map);
    	this.areas.push(circle);
    	if(centerView) {
    		this.geoMap.map.fitBounds(circle.getBounds());
    	}
    	return circle;
	}
    
    viewer.GeoMap.featureGroup.prototype.isVisible = function() {
		return this.geoMap.map.hasLayer(this.layer);
    }
    
    viewer.GeoMap.featureGroup.prototype.setVisible = function(visible) {
        if(visible && !this.isVisible()) {
	    	this.geoMap.map.addLayer(this.layer);
	    } else if(!visible) {
	    	this.geoMap.map.removeLayer(this.layer);
	    }
    }
    
    viewer.GeoMap.featureGroup.prototype.close = function() {
	    this.onFeatureClick.complete();
        this.onFeatureMove.complete();	
    }
    
    viewer.GeoMap.featureGroup.prototype.showMarkers = function(entityFilter) {
		_getAllEntities(this).filter(entity => entity).forEach(entity => {
			entity.visible = _isVisible(entity, entityFilter);
		});
		this.hideMarkers();
		this.markers.filter(m => this.getCount(m.feature.properties))
		.forEach(m => {
			if(m.setIcon) {				
				m.setIcon(this.getMarkerIcon(m.feature.properties));
			}
			if(this.cluster) {
				this.cluster.addLayer(m);
			} else {
				this.layer.addLayer(m);
			}
		})
	}
	
	viewer.GeoMap.featureGroup.prototype.hideMarkers = function() {
		this.layer.clearLayers();
		if(this.cluster) {		
			this.cluster.clearLayers();
			this.layer.addLayer(this.cluster);
		}
	}

	function _getAllEntities(featureGroup) {
		let entities = featureGroup.markers.flatMap(m => m.feature.properties.entities);
		return entities ? entities : [];
	}
    
    function _isVisible(entity, filter) {
		if(typeof filter === 'function') {
			return filter(entity);
		} else if(filter === undefined) {
			return true;
		} else {
			return filter ? true : false;
		}
	}
    
    return viewer;
    
} )( viewerJS || {}, jQuery );



// Check if L (leaflet) exists, before executing 

if (typeof L !== 'undefined') {
	// console.log('leaflet loaded');
	/**
	  Leaflet-Solr-Heatmap v0.3.0
	  by Jack Reed, @mejackreed
	     Steve McDonald, @spacemansteve
	*/
	
	/**
	* A Base SolrHeatmap QueryAdapter, used for defining a request and response to
	* an API that uses the Solr Facet Heatmap functionality
	*/
	L.SolrHeatmapBaseQueryAdapter = L.Class.extend({
	  initialize: function(options, layer) {
	    this.layer = layer;
	    L.setOptions(this, options);
	  },
	  /*
	  * @param bounds optional param for a spatial query
	  */
	  ajaxOptions: function(bounds) {
	    throw('Not implemented');
	  },
	  responseFormatter: function() {
	    throw('Not implemented');
	  } 
	});
	
	/**
	* A POJO used for defining and accessing Query Adapters
	*/
	L.SolrHeatmapQueryAdapters = {
	  default: L.SolrHeatmapBaseQueryAdapter.extend({
	    ajaxOptions: function(bounds) {
	      return {
	        url: this._solrQuery(),
	        dataType: 'JSONP',
	        data: {
	          q: '*:*',
	          wt: 'json',
	           facet: true,
	           'facet.heatmap': this.options.field,
	           'facet.heatmap.geom': this.layer._mapViewToWkt(bounds),
	           fq: this.options.field + this.layer._mapViewToEnvelope(bounds)
	        },
	        jsonp: 'json.wrf'
	      };
	    },
	    responseFormatter: function(data) {
	      this.layer.count = data.response.numFound;
	      return data.facet_counts.facet_heatmaps;
	    },
	    _solrQuery: function() {
	      return this.layer._heatmapUrl + '/' + this.options.solrRequestHandler + '?' + this.options.field;
	    }
	  }),
	  blacklight: L.SolrHeatmapBaseQueryAdapter.extend({
	    ajaxOptions: function(bounds) {
	      return {
	        url: this.layer._heatmapUrl,
	        dataType: 'JSON',
	        data: {
	          bbox: this._mapViewToBbox(bounds),
	          format: 'json',
	        },
	        jsonp: false
	      };
	    },
	    responseFormatter: function(data) {
	      this.layer.count = data.response.pages.total_count;
	      return data.response.facet_heatmaps;
	    },
	    _mapViewToBbox: function (bounds) {
	      if (this._map === undefined) {
	        return '-180,-90,180,90';
	      }
	      if (bounds === undefined) {
	        bounds = this._map.getBounds();
	      }
	      var wrappedSw = bounds.getSouthWest().wrap();
	      var wrappedNe = bounds.getNorthEast().wrap();
	      return [wrappedSw.lng, bounds.getSouth(), wrappedNe.lng, bounds.getNorth()].join(',');
	    }
	  }),
	  goobiViewer: L.SolrHeatmapBaseQueryAdapter.extend({
	    ajaxOptions: function(bounds) {
	        let options = {
	          url: this._solrQuery(bounds)
	        };
	        return options;
	      },
	      ajaxOptionsForSearchHits: function(bounds) {
	        let options = {
	     	  url: this._searchHitsSolrQuery(bounds)
	   		};
	        return options;
	      },
	      responseFormatter: function(data) {
	        return {
	            "WKT_COORDS" : data
	        }
	      },
	      _solrQuery: function(bounds) {
	        let b = this._getBoundsForQuery(bounds);
	        let region = this.layer._mapViewToWkt(b);
	        let query = this.layer._heatmapUrl.replace("{solrField}", this.options.field) + '?' + 
	                "region=" + encodeURIComponent(region) + '&' + 
		            "query=" + this.options.filterQuery;
		    if(this.options.facetQuery) {
		    	query += '&facetQuery=' + this.options.facetQuery;
		    }
		    return query;
	      },
	      _searchHitsSolrQuery: function(bounds) {
	          bounds = this._getBoundsForQuery(bounds);
	          let region = this.layer._mapViewToWkt(bounds);
		      let query = this.layer.featureUrl.replace("{solrField}", this.options.field) + '?' + 
		                "region=" + encodeURIComponent(region) + '&' + 
		                "labelField=" + this.options.labelField + '&' + 
		                "query=" + this.options.filterQuery;
	       	  if(this.options.facetQuery) {
	    	  	query += '&facetQuery=' + this.options.facetQuery;
	           }
	    	  return query;
		  },
		  _getBoundsForQuery(bounds) {
		  	   if (bounds === undefined) {
	          let rawBounds = this.layer._mapToAdd.getBounds();
	          let east = rawBounds.getEast() > 180 ? 180 : rawBounds.getEast();
	          let west = rawBounds.getWest() < -180 ? -180 : rawBounds.getWest();
	          bounds = new L.latLngBounds(L.latLng(rawBounds.getNorth(), west), L.latLng(rawBounds.getSouth(), east));
	        	}
	       		return bounds;
	       },
	    })
	  
	  }
	
	/**
	* A Leaflet extension to be used for adding a SolrHeatmap layer to a Leaflet map
	*/
	L.SolrHeatmap = L.GeoJSON.extend({
	  options: {
	    solrRequestHandler: 'select',
	    type: 'geojsonGrid',
	    colors: ['#f1eef6', '#d7b5d8', '#df65b0', '#dd1c77', '#980043'],
	    maxSampleSize: Number.MAX_SAFE_INTEGER,  // for Jenks classification
	    queryAdapter: 'default',
	    queryRadius: 40, // In pixels, used for nearby query
	  },
	
	  visible: true,
	
	  initialize: function(heatmapUrl, featureUrl, featureGroup, options) {
	    var _this = this;
	    L.setOptions(_this, options);
	    _this.featureGroup = featureGroup;
	    _this.queryAdapter = new L.SolrHeatmapQueryAdapters[this.options.queryAdapter](this.options, _this);
	    _this._heatmapUrl = heatmapUrl;
	    _this.featureUrl = featureUrl;
	    _this._layers = {};
	  },
	
	  onAdd: function (map) {
	    // Call the parent function
	    L.GeoJSON.prototype.onAdd.call(this, map);
	
	    map.on('moveend', this._resetLayer, this);
	  },
	
	  onRemove: function(map) {
	    // Call the parent function
	    L.GeoJSON.prototype.onRemove.call(this, map);
	    map.off('moveend', this._resetLayer, this);
	  },
	
	  beforeAdd: function() {
	    this._getData();
	  },
	
	  isVisible: function() {
	    return this.visible;
	  },
	
	  setVisible: function(visible) {
	      this.visible = visible;
	      this._resetLayer();
	      this.featureGroup.setVisible(visible);
	  },
	
	  _resetLayer: function() {
	    if(this.clusterMarkers) {
	      this._clearLayers();
	      this._getData();
	    }
	  },
	
	  _queryNearby: function(bounds) {
	    var _this = this;
	    var startTime = Date.now();
	    var options = _this.queryAdapter.ajaxOptions(bounds);
	    options.success = function(data) {
	      _this.nearbyResponseTime = Date.now() - startTime;
	      data.bounds = bounds;
	      _this.fireEvent('nearbyQueried', data);
	    }
	    $.ajax(options);
	  },
	
	  requestNearby: function(layerPoint) {
	    var dist = this.options.queryRadius;
	    var bounds = L.latLngBounds(
	      this._map.layerPointToLatLng([layerPoint.x + dist, layerPoint.y + dist]),
	      this._map.layerPointToLatLng([layerPoint.x - dist, layerPoint.y - dist])
	    );
	    this._queryNearby(bounds);
	  },
	
	
	
	  _computeHeatmapObject: function(data) {
	    var _this = this;
	    _this.facetHeatmap = {},
	      facetHeatmapArray = _this.queryAdapter.responseFormatter(data)[this.options.field];
			
		if(Array.isArray(facetHeatmapArray)) {
		    // Convert array to an object
		    $.each(facetHeatmapArray, function(index, value) {
		      if ((index + 1) % 2 !== 0) {
		        // Set object keys for even items
		        _this.facetHeatmap[value] = '';
		      }else {
		        // Set object values for odd items
		        _this.facetHeatmap[facetHeatmapArray[index - 1]] = value;
		      }
		    });
	    } else {
	    	this.facetHeatmap = facetHeatmapArray;
	    }
	
	    this._computeIntArrays();
	  },
	
	  _clearLayers: function() {
	    var _this = this;
	
	    switch (_this.options.type) {
	      case 'geojsonGrid':
	        _this.clearLayers();
	        break;
	      case 'clusters':
	        _this.clusterMarkers.clearLayers();
	        break;
	      case 'heatmap':
	    _this._map.removeLayer(_this.heatmapLayer);
	    break;
	    }
	  },
	  
	
	  _createGeojson: function() {
	    var _this = this;
	    var geojson = {};
	
	    geojson.type = 'FeatureCollection';
	    geojson.features = [];
	
	    $.each(_this.facetHeatmap.counts_ints2D, function(row, value) {
	      if (value === null) {
	        return;
	      }
	
	      $.each(value, function(column, val) {
	        if (val === 0) {
	          return;
	        }
	
	        var newFeature = {
	          type: 'Feature',
	          geometry: {
	            type: 'Polygon',
	            coordinates: [
	              [
	                [_this._minLng(column), _this._minLat(row)],
	                [_this._minLng(column), _this._maxLat(row)],
	                [_this._maxLng(column), _this._maxLat(row)],
	                [_this._maxLng(column), _this._minLat(row)],
	                [_this._minLng(column), _this._minLat(row)]
	              ]
	            ]
	          },
	          properties: {
	            count: val
	          }
	        };
	        geojson.features.push(newFeature);
	      });
	    });
	    _this.addData(geojson);
	    var colors = _this.options.colors; 
	    var classifications = _this._getClassifications(colors.length);
	    _this._styleByCount(classifications);
	  },
	
	  _createHeatmap: function(){
	    var _this = this;
	    var heatmapCells = [];
	    var cellSize = _this._getCellSize() * .75;
	    var colors = _this.options.colors; 
	    var classifications = _this._getClassifications(colors.length - 1);
	    var maxValue = classifications[classifications.length - 1];
	    var gradient = _this._getGradient(classifications);
	
	    $.each(_this.facetHeatmap.counts_ints2D, function(row, value) {
	      if (value === null) {
	        return;
	      }
	
	      $.each(value, function(column, val) {
	        if (val === 0) {
	          return;
	        }
	  var scaledValue = Math.min((val / maxValue), 1);
	  var current = [_this._minLat(row), _this._minLng(column), scaledValue];
	  heatmapCells.push(current);
	  // need to create options object to set gradient, blu, radius, max
	      })
	    });
	
	    // settting max due to bug
	    // http://stackoverflow.com/questions/26767722/leaflet-heat-issue-with-adding-points-with-intensity
	    var options = {max: .0001, radius: cellSize, gradient: gradient};
	    var heatmapLayer = L.heatLayer(heatmapCells, options);
	    heatmapLayer.addTo(_this._map);
	    _this.heatmapLayer = heatmapLayer;
	  },
	
	  // heatmap display need hash of scaled counts value, color pairs
	  _getGradient: function (classifications){
	    var gradient = {};
	    var maxValue = classifications[classifications.length - 1];
	    var colors = _this.options.colors; 
	    // skip first lower bound, assumed to be 0 from Jenks
	    for (var i = 1 ; i < classifications.length ; i++)
	  gradient[classifications[i] / maxValue] = colors[i];
	    return gradient;
	  },
	
	  // compute size of heatmap cells in pixels
	  _getCellSize: function(){
	    _this = this;
	    var mapSize = _this._map.getSize();  // should't we use solr returned map extent?
	    var widthInPixels = mapSize.x; 
	    var heightInPixels = mapSize.y;
	    var heatmapRows = _this.facetHeatmap.rows;
	    var heatmapColumns = _this.facetHeatmap.columns;
	    var sizeX = widthInPixels / heatmapColumns;
	    var sizeY = heightInPixels / heatmapRows;
	    var size = Math.ceil(Math.max(sizeX, sizeY));
	    return size;
	},
	
	  _setRenderTime: function() {
	    var _this = this;
	    _this.renderTime = (Date.now() - _this.renderStart);
	  },
	  
	  _createMarker(count) {
	  
	    return this.featureGroup.getClusterIcon(count);
	  
	//  	let background = this.featureGroup.config.markerIcon.markerColor;
	//    let color = this.featureGroup.config.markerIcon.iconColor;
	//    return new L.DivIcon({ html: '<div style="background-color:'+background+'; color:'+color+'"><span>' + count + '</span></div>', className: 'geomap-heatmap-marker', iconSize: new L.Point(40, 40) });
	  },
	
	  _createClusters: function() {
			var _this = this;
			_this.clusterMarkers = new L.MarkerClusterGroup({
	      	maxClusterRadius: 140,
	      	iconCreateFunction: function(cluster) {
	       		return _this._createMarker(_this._computeTotalChildHits(cluster));
	       	}
	    });
		_this.featureGroup.removeAllMarkers();
	
	    $.each(_this.facetHeatmap.counts_ints2D, function(row, value) {
	      if (value === null) {
	        return;
	      }
	
	      $.each(value, function(column, val) {
	        if (val === 0) {
	          return;
	        }
	
	        var bounds = new L.latLngBounds([
	          [_this._minLat(row), _this._minLng(column)],
	          [_this._maxLat(row), _this._maxLng(column)]
	        ]);
	        
	        let marker = new L.Marker(bounds.getCenter(), {
	          icon: L.divIcon({
	          	iconSize: [0,0]
	          }),
	          count: val,
	          bounds : bounds
	        });
	        marker.on('add', e => {
	        	setTimeout(() => _this._expandMarker(e.target), 0);
	        });
	        //marker.on('click', e => _this._expandMarker(e.target));
	        _this.clusterMarkers.addLayer(marker);
	      });
	    });
	 
	    _this._map.addLayer(_this.clusterMarkers);
	  },
	  
	  _expandMarker(marker) {
	  		var visibleOne = this.clusterMarkers.getVisibleParent(marker);
		    //console.log("expand ", marker, visibleOne);
		    if(visibleOne === marker) {
				let bounds = marker.options.bounds;
			    if(bounds && this.queryAdapter.ajaxOptionsForSearchHits) {
			        $.ajax(this.queryAdapter.ajaxOptionsForSearchHits(bounds))
			        .then(res => {
	        			res.forEach(geoJson => {
	                let m = this.featureGroup.addMarker(geoJson);
	                //console.log("added ", geoJson, " to ", marker);
	        			});
	        		});
			       		
	        		if(marker.options.count) {
	        			marker.options.count = 0;
	        		}
	        	}
	    	}
	  },
	
	  _computeTotalChildHits(cluster) {
	  	let count = 0;
	  	// if(cluster._childClusters && cluster._childClusters.length > 0) {
	  	// 	count += cluster._childClusters.map(child => this._computeTotalChildHits(child)).reduce((a, b) => a + b, 0)
	  	// }
	  	// if(cluster._markers && cluster._markers.length > 0) {
	  	// 	count += cluster._markers.map(child => child.options.count ? child.options.count : 0).reduce((a, b) => a + b, 0)
	    // }
	    count +=  cluster.getAllChildMarkers().map(child => child.options.count ? child.options.count : 0).reduce((a, b) => a + b, 0);
	  	if(cluster.options && cluster.options.count) {
	  		count += cluster.options.count;
	  	}
	  	return count;
	  },
	
	  _computeIntArrays: function() {
	    var _this = this;
	
	    _this.lengthX = (_this.facetHeatmap.maxX - _this.facetHeatmap.minX) / _this.facetHeatmap.columns;
	    _this.lengthY = (_this.facetHeatmap.maxY - _this.facetHeatmap.minY) / _this.facetHeatmap.rows;
	
	    switch (_this.options.type) {
	      case 'geojsonGrid':
	        _this._createGeojson();
	        break;
	      case 'clusters':
	        _this._createClusters();
	        break;
	      case 'heatmap':
	        _this._createHeatmap();
	        break;
	    }
	    _this._setRenderTime();
	  },
	
	  _getClassifications: function(howMany)
	  {
	    var _this = this;
	    var one_d_array = [];
	    for(var i = 0; i < _this.facetHeatmap.counts_ints2D.length; i++) {
	      if (_this.facetHeatmap.counts_ints2D[i] != null) {
	        one_d_array = one_d_array.concat(_this.facetHeatmap.counts_ints2D[i]);
	      }
	    }
	    var sampled_array = _this._sampleCounts(one_d_array);
	
	    var series = new geostats(sampled_array);
	    var scale = _this.options.colors; 
	    var classifications = series.getClassJenks(howMany);
	    return classifications;
	  },
	
	  _styleByCount: function(classifications) {
	    var _this = this;
	    var scale = _this.options.colors;
	
	    _this.eachLayer(function(layer) {
	      var color;
	      $.each(classifications, function(i, val) {
	        if (layer.feature.properties.count >= val) {
	          color = scale[i];
	        }
	      });
	      layer.setStyle({
	        fillColor: color,
	        fillOpacity: 0.5,
	        weight: 0
	      });
	    });
	  },
	
	  // Jenks classification can be slow so we optionally sample the data
	  // typically any big sample of counts are much the same, don't need to classify on all of them
	  _sampleCounts: function(passedArray) {
	    var _this = this;
	    if (passedArray.length <= _this.options.maxSampleSize) {
	      return passedArray;   // array too small to sample
	    };
	
	    var maxValue = Math.max.apply(Math, passedArray);
	    var sampledArray = [];
	    var period = Math.ceil(passedArray.length / _this.options.maxSampleSize);
	    for (i = 0 ; i < passedArray.length ; i = i + period) {
	      sampledArray.push(passedArray[i]);
	    }
	
	    sampledArray.push(maxValue);  // make sure largest value gets in, doesn't matter much if duplicated
	    return sampledArray
	  },
	
	  _minLng: function(column) {
	    return this.facetHeatmap.minX + (this.lengthX * column);
	  },
	
	  _minLat: function(row) {
	    return this.facetHeatmap.maxY - (this.lengthY * row) - this.lengthY;
	  },
	
	  _maxLng: function(column) {
	    return this.facetHeatmap.minX + (this.lengthX * column) + this.lengthX;
	  },
	
	  _maxLat: function(row) {
	    return this.facetHeatmap.maxY - (this.lengthY * row);
	  },
	
	  _getData: function() {
	    if(this.visible) {
	      var _this = this;
	      var startTime = Date.now();
	      var options = _this.queryAdapter.ajaxOptions();
	      options.success = function(data) {
	        _this.responseTime = Date.now() - startTime;
	        _this.renderStart = Date.now();
	        _this._computeHeatmapObject(data);
	        _this.fireEvent('dataAdded', data);
	      }
	      $.ajax(options);
	    }
	  },
	
	  _mapViewToEnvelope: function(bounds) {
	    if (this._map === undefined) {
	      return ':"Intersects(ENVELOPE(-180, 180, 90, -90))"';
	    }
	    if (bounds === undefined) {
	      bounds = this._map.getBounds();
	    }
	    var wrappedSw = bounds.getSouthWest().wrap();
	    var wrappedNe = bounds.getNorthEast().wrap();
	    return ':"Intersects(ENVELOPE(' + wrappedSw.lng + ', ' + wrappedNe.lng + ', ' + bounds.getNorth() + ', ' + bounds.getSouth() + '))"';
	  },
	
	  _mapViewToWkt: function(bounds) {
	    let map = this._map ? this._map : this._mapToAdd;
	    if (map === undefined) {
	      return '["-180 -90" TO "180 90"]';
	    }
	    if (bounds === undefined) {
	      bounds = map.getBounds();
	    }
	    var wrappedSw = bounds.getSouthWest().wrap();
	    var wrappedNe = bounds.getNorthEast().wrap();
	    return '["' + wrappedSw.lng + ' ' + bounds.getSouth() + '" TO "' + wrappedNe.lng + ' ' + bounds.getNorth() + '"]';
	  }
	});
	
	L.solrHeatmap = function(heatmapUrl, featureUrl, featureGroup, options) {
	  return new L.SolrHeatmap(heatmapUrl, featureUrl, featureGroup, options);
	};
}

var viewerJS = ( function( viewer ) {
    'use strict'; 
        
    // default variables
    var _debug = false;
    
    var _defaults = {
    		mapType: "MANUAL", // or "SOLR_QUERY",
    		openSearchOnMarkerClick: true,
    		documentIdToHighlight: undefined,
    		pagesToShow: [],
            map: {
	            mapId : "geomap",
	            language: "en",
	            iconPath: "/resources/images/map",
	        }
    }
    
    viewer.GeoMapCms = function(config) {
 		this.config = $.extend( true, {}, _defaults, config );
 		if(_debug)console.log("Initialize CMS-Geomap with config", config);
 		//Hightlight the marker belonging to a given SOLR document
    	let highlightDocumentId = this.config.documentIdToHighlight;
    	if(highlightDocumentId) {
    		//console.log("highlight", highlightDocumentId);
    	    this.config.map.layers.map(layer => layer.features).flat().filter(f => f.properties.documentId == highlightDocumentId).forEach(f => f.properties.highlighted = true);
    	}
    	if(this.config.pagesToShow) {
			this.config.map.layers.map(layer => layer.features).flat().filter(f => !this.config.pagesToShow.includes(f.properties.page) && f.properties.page !== undefined).forEach(f => f.properties.visible = false);

		}
		this.geoMap = new viewerJS.GeoMap(this.config.map);
   }
   
   viewer.GeoMapCms.prototype.init = function(view) {
   
	    this.geoMap.layers.forEach(layer => {
			layer.language = this.config.map.language;
			//when clicking on features with an associated link, open that link
	    	layer.onFeatureClick.subscribe(feature => {
//				console.log("click on feature ", feature);
	   	       if(feature.properties?.link && !feature.properties.entities?.filter(e => e.visible !== false).filter(e => e.title?.length > 0).length && !feature.properties.highlighted) {
	   	           $(layer.config.search.loader).show();
	   	           window.location.assign(feature.properties.link);
	   	       }
	   	    });
	   	    //link to search url on feature click
	    	if(layer.config.search.openSearchOnMarkerClick) {
				let searchUrlTemplate = layer.config.search.searchUrlTemplate;
	            layer.onFeatureClick.subscribe( (feature) => { 
					// viewerJS.notifications.confirm("Do you want to show search results for this location?")
					// .then(() => {
						let featuresToShow = feature.properties?.entities?.filter(e => e.visible !== false).filter(e => e.title?.length > 0);
//						console.log("click for search ", featuresToShow, feature.properties.count, feature.properties.link);
						if(featuresToShow.length == 0 && (feature.properties.count > 1 || !feature.properties?.link?.length))  {
							$(layer.config.search.loader).show();
							let queryUrl = searchUrlTemplate.replace("{lng}", feature.geometry.coordinates[0]);
							queryUrl = queryUrl.replace("{lat}", feature.geometry.coordinates[1]);
//							console.log("open search url ", queryUrl);
							window.open(queryUrl, layer.config.search.linkTarget);
						} 
					// })
	            });
	        }
		});
	    return this.geoMap.init(view);
	}
	
	return viewer;

} )( viewerJS || {}, jQuery );
var viewerJS = ( function ( viewer ) {
	'use strict';

	// default variables
	var _debug = false;

	var _defaults = {
		areaString: "",
		map: {
			mapId: "geomap",
			language: "en",
			iconPath: "/resources/images/map",
			hitsLayer: {
				allowMovingFeatures: false,
				popoverOnHover: true,
				popover: $( "<div><p data-metadata='title'></p></div>" ),
				clusterMarkers: true,
				style: {
					fillOpacity: 0.02
				},
				markerIcon: {
					icon: "fa-number",
					svg: true,
					prefix: "fa",
					iconRotate: 0
				}
			},
			areaLayer: {
				style : {
					fillColor : "#d9534f",
					color : "#d9534f",
					fillOpacity : 0.3,
				}
			}
		},
		heatmap: {
			enabled: true,
			heatmapUrl: "/viewer/api/v1/index/spatial/heatmap/{solrField}",
			featureUrl: "/viewer/api/v1/index/spatial/search/{solrField}",
			mainQuery: "BOOL_WKT_COORDS:*",
			facetQuery: "",
			labelField: "LABEL",
		}, 
		search: {
			$loader: $( "[data-loader='geoFacet']" ),
			$searchButton: $( "[data-geofacet='execute']" )
		},
		buttons: {
			$searchWithFacets: $( "[data-geofacet='trigger-execute']" ),
			$resetFacets: $( "[data-geofacet='reset']" ),
			$cancelEditMode: $( "[data-geofacet='cancel']" ),
			$facetInput: $( "[data-geofacet='feature']" ),
			$toggleMarkers: $( "[data-geofacet='toggleMarkers']" ),
			$toggleMarkersEditMode: $( "[data-geofacet='toggleMarkersFullscreen']" ),
			$openEditMode: $("#expandFacetMap"),
		},
		editMode: {
			$editModeWrapper: $('#widgetGeoFacettingOverlay'),
			$editModeMap: $("#geoFacettingOverlayMap"),
			enableAddressSearch : true,
			addressSearchPlaceholder : "Address"
		}
	}

	viewer.GeoMapFacet = function ( config ) {
		this.config = $.extend( true, {}, _defaults, config );
		if ( _debug ) console.log( "Initialize Facet-Geomap with config", config );
		this.geoMap = new viewerJS.GeoMap( this.config.map );
	}


	viewer.GeoMapFacet.prototype.init = function (features,  view ) {
		this.area = this.getArea( this.config.areaString );
		this.features = this.config.heatmap.enabled ? {} : features;
		this.geoMap.init(view);

		this.drawLayer = this.initDrawLayer();
		this.hitsLayer = this.initHitsLayer(this.features);
		if(this.config.heatmap.enabled) {
			this.heatmap = this.initHeatmap();
		}


		this.config.buttons.$toggleMarkers.on("click", () => {
			this.hitsLayer?.setVisible(!this.hitsLayer.isVisible());
			this.heatmap?.setVisible(!this.heatmap.isVisible());
		})

		$(this.config.buttons.$openEditMode).on("click", e => this.openEditMode());

		// close map overlay with escape
		$(document).on('keyup', e => {
			var $overlayMap = $( this.config.editMode.$editModeMap );
			if ( $overlayMap.length && $overlayMap.is(":visible")) {
				if (e.key == "Escape") {
					$(this.config.buttons.$cancelEditMode).click();
				}
			}
		});
	}

	viewer.GeoMapFacet.prototype.initHitsLayer = function (features) {
		//console.log("init hits layer ", this.config.map.hitsLayer);
		this.config.map.hitsLayer.language = this.config.map.language;
		let hitsLayer = new viewerJS.GeoMap.featureGroup(this.geoMap, this.config.map.hitsLayer)
		hitsLayer.init(features, false);
		hitsLayer.onFeatureClick.subscribe(f => {
			console.log("clicked on ", f);
			if(f.properties && f.properties.link) {
				$(this.config.search.loader).show();
				window.location.assign(f.properties.link);
			}
		})

		return hitsLayer;
	}

	viewer.GeoMapFacet.prototype.initHeatmap = function () {
		let heatmapQuery = this.config.heatmap.mainQuery;
		let heatmapFacetQuery = this.config.heatmap.facetQuery;
		
		let heatmap = L.solrHeatmap(this.config.heatmap.heatmapUrl, this.config.heatmap.featureUrl, this.hitsLayer, {
			field: "WKT_COORDS",
			type: "clusters",
			filterQuery: heatmapQuery,
			facetQuery: heatmapFacetQuery,
			labelField: this.config.heatmap.labelField,
			queryAdapter: "goobiViewer"    
		});
		heatmap.addTo(this.geoMap.map);
		return heatmap;
	}

	viewer.GeoMapFacet.prototype.initDrawLayer = function() {
		this.config.map.areaLayer.language = this.config.map.language;
		let drawLayer = new viewerJS.GeoMap.featureGroup(this.geoMap, this.config.map.areaLayer);
		if(this.area) {	                    	    
			switch(this.area.type) {
				case "polygon":
					this.shape = drawLayer.drawPolygon(this.area.vertices, true);
					break;
				case "circle":
					this.shape = drawLayer.drawCircle(this.area.center, this.area.radius, true);
					break;
				case "rectangle":
					this.shape = drawLayer.drawRectangle([this.area.vertices[0], this.area.vertices[2]], true);
					break;
			}
			this.config.buttons.$resetFacets.addClass("active");
			this.config.buttons.$resetFacets.on("click", () => {
				this.config.buttons.$facetInput.val("");
				this.config.buttons.$searchWithFacets.click();
			});
		}
		return drawLayer;
	}

	viewer.GeoMapFacet.prototype.openEditMode = function() {
		viewerJS.overlay.open(this.config.editMode.$editModeWrapper, false, true, $node => {
			$("body").append($node);
			$node.hide();
		})
		.then(overlay => {
			overlay.node.show();
			this.config.buttons.$searchWithFacets.off().on("click", () => {
				//console.log("trigger search");
				this.config.search.$searchButton.click();
				this.config.search.$loader.show();
			});
			this.config.buttons.$cancelEditMode.off().on("click", () => {
				overlay.close();
			})
			if(this.mapTag) {
				this.mapTag.forEach(tag => tag.unmount(true));
			}
			console.log("area layer", this.config.map.areaLayer)
			this.mapTag = riot.mount(this.config.editMode.$editModeMap, "geomapsearch", {
				inactive: false,
				area : this.area,
				features : this.features,
				toggleFeatures: this.config.buttons.$toggleMarkersEditMode.get(0),
				search_enabled: this.config.editMode.enableAddressSearch,
				search_placeholder: this.config.editMode.addressSearchPlaceholder,
				hitsLayer: this.config.map.hitsLayer,
				areaLayer: this.config.map.areaLayer,
				heatmap: this.config.heatmap,
				onFeatureSelect: area => {
					console.log("Set facetting area", area);
					sessionStorage.setItem("geoFacet", JSON.stringify(area));
					this.config.buttons.$facetInput.val(area ? JSON.stringify(area) : "");
				}
			});
		}); 
	} 

	viewer.GeoMapFacet.prototype.getArea = function(areaString) {
		let area = areaString.length > 0 ? JSON.parse(areaString) : undefined;
		if(area) {
			let storedAreaString = sessionStorage.getItem("geoFacet");
			if(storedAreaString) {
				let storedArea = JSON.parse(storedAreaString);
				for(let v=0; v<area.vertices.length; v++) {
					for(let c=0; c<area.vertices[v].length; c++) {
						if(area.vertices[v][c] != storedArea.vertices[v][c]) {
							return area;
						}
					}
				}
				return storedArea;
			}
		}
		return area;
	}


	return viewer;

} )( viewerJS || {}, jQuery );
var viewerJS = ( function ( viewer ) {
	'use strict';

	// default variables
	var _debug = false;

	var _defaults = {
		submitSearchSelector: '',
		inputSearchSelector: '',
		opts: {
			area : '',
			search_enabled: true,
			search_placeholder: "Address",
			reset_button: $("[data-feature='reset']"),
			msg: {
				action__toggle_map_markers : "toggle markers"
			},
			hitsLayer: {
				allowMovingFeatures: false,
				popoverOnHover: true,
				popover: $( "<div><p data-metadata='title'></p></div>" ),
				clusterMarkers: true,
				style: {
					fillOpacity: 0.02
				},
				markerIcon: {
					icon: "fa-number",
					svg: true,
					prefix: "fa",
					iconRotate: 0
			    }
			},
			heatmap: {
				enabled: true,
				heatmapUrl: "/viewer/api/v1/index/spatial/heatmap/{solrField}",
				featureUrl: "/viewer/api/v1/index/spatial/search/{solrField}",
				mainQuery: "BOOL_WKT_COORDS:*",
				facetQuery: "",
				labelField: "LABEL",
			},
			areaLayer: {
				style : {
					fillColor : "#d9534f",
					color : "#d9534f",
					fillOpacity : 0.3,
				}
			}
		}
	}

	viewer.GeoMapSearch = function ( config ) {
		this.config = $.extend( true, {}, _defaults, config );
		if ( _debug ) console.log( "Initialize Search-Geomap with config", config );
	}


	viewer.GeoMapSearch.prototype.init = function ( view ) {
		this.config.opts.onFeatureSelect = (feature) => this.setSearchString(JSON.stringify(feature));
		riot.mount("#geoMapSearch", "geomapsearch", this.config.opts);
	}

	viewer.GeoMapSearch.prototype.setSearchString = function(feature) {
		//console.log("set search feature ", feature);
		sessionStorage.setItem("geoFacet", feature);
		$(this.config.inputSearchSelector).val(feature);
		if(!feature) {
			$(this.config.submitSearchSelector).attr("disabled", "disabled");
		} else {
			$(this.config.submitSearchSelector).removeAttr("disabled");
		}
	}


    // console.log("viewer ", viewer);
	return viewer;

} )( viewerJS || {}, jQuery );
var cmsJS = ( function() {
    'use strict';
    
    var _debug = false;
    var cms = {};
    
    /**
     * Method which initializes the CMS.
     * 
     * @method init
     * @example
     * 
     * <pre>
     * cmsJS.init();
     * </pre>
     */
    cms.init = function() {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'cmsJS.init' );
            console.log( '##############################' );
        }
        
        // AJAX Loader Eventlistener
        jsf.ajax.addOnEvent( function( data ) {
            var ajaxstatus = data.status; // Can be "begin", "complete" and "success"
            var ajaxloader = document.getElementById( "AJAXLoader" );
            
            if ( ajaxloader ) {
                switch ( ajaxstatus ) {
                    case "begin": // This is called right before ajax request is been
                        // sent.
                        ajaxloader.style.display = 'block';
                        break;
                    
                    case "complete": // This is called right after ajax response is
                        // received.
                        ajaxloader.style.display = 'none';
                        break;
                    
                    case "success": // This is called when ajax response is successfully
                        // processed.
                        // NOOP.
                        break;
                }
            }
        } );
    };
    
    cms.dataTables_de = {
        "sEmptyTable": "Keine Daten in der Tabelle vorhanden",
        "sInfo": "_START_ bis _END_ von _TOTAL_ Einträgen",
        "sInfoEmpty": "0 bis 0 von 0 Einträgen",
        "sInfoFiltered": "(gefiltert von _MAX_ Einträgen)",
        "sInfoPostFix": "",
        "sInfoThousands": ".",
        "sLengthMenu": "_MENU_ Einträge anzeigen",
        "sLoadingRecords": "Wird geladen...",
        "sProcessing": "Bitte warten...",
        "sSearch": "Suchen",
        "sZeroRecords": "Keine Einträge vorhanden.",
        "oPaginate": {
            "sFirst": "Erste",
            "sPrevious": "Zurück",
            "sNext": "Nächste",
            "sLast": "Letzte"
        },
        "oAria": {
            "sSortAscending": ": aktivieren, um Spalte aufsteigend zu sortieren",
            "sSortDescending": ": aktivieren, um Spalte absteigend zu sortieren"
        }
    };
    
    cms.dataTables_en = {
        "sEmptyTable": "No data available in table",
        "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
        "sInfoEmpty": "Showing 0 to 0 of 0 entries",
        "sInfoFiltered": "(filtered from _MAX_ total entries)",
        "sInfoPostFix": "",
        "sInfoThousands": ",",
        "sLengthMenu": "Show _MENU_ entries",
        "sLoadingRecords": "Loading...",
        "sProcessing": "Processing...",
        "sSearch": "Search:",
        "sZeroRecords": "No matching records found",
        "oPaginate": {
            "sFirst": "First",
            "sLast": "Last",
            "sNext": "Next",
            "sPrevious": "Previous"
        },
        "oAria": {
            "sSortAscending": ": activate to sort column ascending",
            "sSortDescending": ": activate to sort column descending"
        }
    };
    
    cms.dataTables_es = {
        "sProcessing": "Procesando...",
        "sLengthMenu": "Mostrar _MENU_ registros",
        "sZeroRecords": "No se encontraron resultados",
        "sEmptyTable": "Ningún dato disponible en esta tabla",
        "sInfo": "Mostrando registros del _START_ al _END_ de un total de _TOTAL_ registros",
        "sInfoEmpty": "Mostrando registros del 0 al 0 de un total de 0 registros",
        "sInfoFiltered": "(filtrado de un total de _MAX_ registros)",
        "sInfoPostFix": "",
        "sSearch": "Buscar:",
        "sUrl": "",
        "sInfoThousands": ",",
        "sLoadingRecords": "Cargando...",
        "oPaginate": {
            "sFirst": "Primero",
            "sLast": "Último",
            "sNext": "Siguiente",
            "sPrevious": "Anterior"
        },
        "oAria": {
            "sSortAscending": ": Activar para ordenar la columna de manera ascendente",
            "sSortDescending": ": Activar para ordenar la columna de manera descendente"
        }
    };
    
    return cms;
    
} )( jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    var _debug = false;
    var _previewStatus = '';
    var _defaults = {
        selectedPageID: null,
        inputFields: null,
        prevBtn: null,
        prevDescription: null,
        saveBtn: null,
        sortablesConfig: {}
    };
    
    cms.createPage = {
        /**
         * Method which initializes the CMS create page module.
         * 
         * @method init
         * @param {Object} settings
         */
        init: function( settings ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.createPage.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.createPage.init: settings - ', settings );
            }
            
            $.extend( true, _defaults, settings );
            
            if ( _defaults.selectedPageID === null ) {
                cmsJS.createPage.disablePreview();
                _defaults.prevDescription.show();
            }
            
            // listen to changes on input fields
            _defaults.inputFields.on( 'change input paste', function() {
                cmsJS.createPage.disablePreview();
                _defaults.prevDescription.show();
            } );
            
            cmsJS.createPage.initSortables( _defaults );
            cmsJS.createSlider.initStyleOptions();
            
            // check preview status and open new tab
            if ( sessionStorage.getItem( 'previewStatus' ) === 'false' ) {
                _defaults.prevBtn.attr( 'disabled', true );
                _defaults.prevDescription.show();
            }
            else {
                _defaults.prevBtn.attr( 'disabled', false );
                _defaults.prevDescription.hide();
                
                _defaults.prevBtn.on( 'click', function( event ) {
                	var url = $( this ).attr( 'data-previewUrl' );
                    window.open( url, url );
                } );
            }
        },
        
        /**
         * Method which
         * 
         * @method initSortables
         * @param {Object} config
         */
        initSortables: function( config ) {
            if ( _debug ) {
                console.log( 'cmsJS.createPage.initSortables: config - ', config );
            }
            
            config.sortablesConfig.visibleItemList = $( config.sortablesConfig.visibleItemList );
            config.sortablesConfig.availableItemList = $( config.sortablesConfig.availableItemList );
            if ( config.sortablesConfig.availableItemList.length > 0 ) {
                cmsJS.sortableList.init( 0, false, config );
                config.sortablesConfig.editButton.on( 'click', function() {
                    if ( $( this ).hasClass( 'fa-pencil-square-o' ) ) {
                        $( this ).removeClass( 'fa-pencil-square-o' ).addClass( 'fa-times' );
                    }
                    else {
                        $( this ).removeClass( 'fa-times' ).addClass( 'fa-pencil-square-o' );
                    }
                    $( this ).parent( '.sidebar-editor-widget-item-header' ).next( '.sidebar-editor-widget-item-body' ).slideToggle();
                } );
                
                config.sortablesConfig.availableItemList.on( 'sortbeforestop', function( event, ui ) {
                    if ( $( ui.item ).parent().attr( 'id' ) === 'visibleItemList' ) {
                        cmsJS.createPage.disablePreview();
                    }
                } );
                
                config.sortablesConfig.visibleItemList.on( 'sortbeforestop', function() {
                    cmsJS.createPage.disablePreview();
                } );
            }
            else {
                if ( _debug )
                    console.log( "No sortable list elements available" );
                return false;
            }
        },

        /**
         * Method which disables the preview button by setting a local storage value.
         * 
         * @method disablePreview
         */
        disablePreview: function() {
            if ( _debug ) {
                console.log( '---------- cmsJS.createPage.disablePreview() ----------' );
            }
            
            sessionStorage.setItem( 'previewStatus', 'false' );
        },
        
        /**
         * Method which enables the preview button by setting a local storage value.
         * 
         * @method enablePreview
         */
        enablePreview: function() {
            if ( _debug ) {
                console.log( '---------- cmsJS.createPage.enablePreview() ----------' );
            }
            
            sessionStorage.setItem( 'previewStatus', 'true' );
        },
    };


    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    var _debug = false;
    
    cms.createSlider = {
        /**
         * Method which initializes CMS backend slider functionalities
         * 
         * @method init
         * @param {Object} settings
         */
        init: function( settings ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.createSlider.init' );
                console.log( '##############################' );
            }
            
            /**
            *	initialize sliders only after document load to wait after 
            */
            $(document).ready(() => {
	            cmsJS.createSlider.initStyleOptions();
            });

        },
        
        /**
        * Initializes the list of options for any elements with data-options="slider-styles" 
        * Possible values for the option list are taken from viewerJS.slider.js
        */
        initStyleOptions: function() {
        	$("[data-options='slider-styles']").each((index, element) => {
        		if(_debug)console.log("add options to", element);
        		let $select = $(element);
	        	let styles = viewerJS.slider.styles.keys();
	        	let value = $select.attr("data-value");
	        	if(_debug)console.log("add options to dropdown", $select, styles);
    			for (let style of styles) { 
    				if(value == style) {
    					$select.append("<option value='"+style+"' selected='selected'>" +style+ "</option>");
    				} else {
	    				$select.append("<option value='"+style+"'>" +style+ "</option>");
    				}
    			}
    			//trigger the dropdown once to set the style in the java bean
    			$select.trigger("change");   		
        	});
        },

    };
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _defaults = {
        mapId: "geomap",
        displayLanguage : "de",
        supportedLanguages: ["de", "en"],
        popover: "#geoMapPopoverTemplate",
        allowEditFeatures: false,
        featuresInput: "#featuresInput",
        viewInput: "#viewInput",
        metadataArea: "#featureForm",
        loader: ".ajax_loader",
        msg: {
            emptyMarker: "...",
            titleLabel: "title",
            titleHelp: "help title",
            descLabel: "description",
            descHelp: "help description",
            deleteLabel: "delete"
        }
    };
    
    cms.GeoMapEditor = function(config) {
        this.config = $.extend({}, _defaults, config);
        this.currentFeature = undefined;
        this.onDeleteClick = new rxjs.Subject();
        this.onMetadataUpdate = new rxjs.Subject();
        this.metadataProvider = new rxjs.Subject();
        
        this.geoMap = new viewerJS.GeoMap({
            language: this.config.displayLanguage,
            layers: [{
            	language: this.config.displayLanguage,
	            popover: this.config.popover,
	            emptyMarkerMessage: this.config.msg.emptyMarker,
	            allowMovingFeatures: this.config.allowEditFeatures,
            }],
        });
        
        
        this.geoMap.onMapRightclick
        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures), rxjs.operators.map(geojson => this.addFeature(geojson)))
        .subscribe(() => this.saveFeatures());
        
        this.geoMap.onMapClick
        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures))
        .subscribe(() => this.setCurrentFeature());
        
        this.geoMap.onMapMove
        .subscribe(() => this.saveView())
        
        this.onDeleteClick
        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures), rxjs.operators.map(() => this.deleteCurrentFeature()))
        .subscribe(() => this.saveFeatures());
        
        this.onMetadataUpdate
        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures), rxjs.operators.map((metadata) => this.updateCurrentFeatureMetadata(metadata)))
        .subscribe(() => this.saveFeatures());
    
        if(this.config.loader) {
            viewerJS.jsfAjax.begin.subscribe((e) => {
                if($(e.source).closest("#mapPanel").length > 0) {                    
                    $(this.config.loader).show();
                }
            });
            viewerJS.jsfAjax.complete.subscribe(() => $(this.config.loader).hide());
        }
    }
    
    cms.GeoMapEditor.prototype.init = function(defaultView) {
        this.geoMap.init(this.getView(defaultView))
        .then( () => {
	        
	        if($("metadataEditor").length > 0) {  
	            if(this.metadataEditor) {
	                this.metadataEditor.forEach(component => {
	                    component.unmount(true);
	                })
	            }
	            this.metadataEditor = riot.mount("metadataEditor", {
	                languages: this.config.supportedLanguages,
	                metadata: undefined,
	                provider: this.metadataProvider,
	                currentLanguage: this.config.displayLanguage,
	                updateListener: this.onMetadataUpdate,
	                deleteListener : this.onDeleteClick,
	                deleteLabel : this.config.msg.deleteLabel
	            });
	        }
		});
        
    }
    
    cms.GeoMapEditor.prototype.addFeatureGroup = function(config, features) {
		let featureGroup = this.geoMap.addFeatureGroup(config, features);
		featureGroup.onFeatureClick
	        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures),
	        	  rxjs.operators.takeWhile(f => this.isInActiveGroup(f)))
	        .subscribe(geojson => this.setCurrentFeature(geojson, true));
	    featureGroup.onFeatureMove
	        .pipe(rxjs.operators.takeWhile(() => this.config.allowEditFeatures), rxjs.operators.map(geojson => this.setCurrentFeature(geojson)))
	        .subscribe(() => this.saveFeatures());
	    featureGroup.onFeatureMove.subscribe(f => console.log("Moving feature ", f))
	    return featureGroup;
	};

    
    cms.GeoMapEditor.prototype.addFeature = function(geojson) {
		console.log("add feature ", geojson, " to ", this.activeFeatureGroup);
        if(this.activeFeatureGroup) {
			console.log("Add feature ", geojson, " to active group ", this.activeFeatureGroup);		
	        this.currentFeature = geojson;
	        this.activeFeatureGroup.addMarker(geojson).openPopup();
        	this.updateMetadata(geojson);
		}
    }
    
    cms.GeoMapEditor.prototype.saveFeatures = function() {
	    if(this.activeFeatureGroup) {
	    	//temporarily remove layer property of features to avoid cyclic references while serializing
	    	this.activeFeatureGroup.getFeatures()?.forEach(f => f.layer = undefined);
	        $(this.config.featuresInput).val(JSON.stringify(this.activeFeatureGroup.getFeatures()));
	        this.activeFeatureGroup.getFeatures()?.forEach(f => f.layer = this.activeFeatureGroup);
	    }
    }
    
    cms.GeoMapEditor.prototype.saveView = function() {
        $(this.config.viewInput).val(JSON.stringify(this.geoMap.getView()));
    }

    cms.GeoMapEditor.prototype.isInActiveGroup = function(feature) {
		return this.activeFeatureGroup?.getFeatures().includes(feature);
	}


    /**
     * Updates the content of the metadata editor with the content of the given geojson object
     * Also scrolls to the top of the metadata edtor (config.metadataArea)
     */
    cms.GeoMapEditor.prototype.updateMetadata = function(geojson) {
        let metadataList = [
            {   
                property: "title",
                tyle: "text",
                label: this.config.msg.titleLabel,
                value: geojson ? geojson.properties.title : "",
                required: false,
                helptext: this.config.msg.titleHelp,
                editable: geojson != undefined
            },
            {   
                property: "description",
                type:"longtext",
                label: this.config.msg.descLabel,
                value: geojson ? geojson.properties.description: "",
                required: false,
                helptext: this.config.msg.descHelp,
                editable: geojson != undefined
            }
        ]
        this.metadataProvider.next(metadataList);
        if(geojson && this.config.metadataArea) {
            $("html, body").scrollTop($(this.config.metadataArea).offset().top)
        }
    }
    
    /**
     * Set the current feature to the given feature if it isn't already the current feature or 'deselectIfCurrent' is false
     * Otherwise, set the current feature to undefined, effectively unselecting the given feature
     * Update the metadata editor with the current feature
     */
    cms.GeoMapEditor.prototype.setCurrentFeature = function(geojson, deselectIfCurrent) {
        if(_debug)console.log("set current feature ", geojson);
        if(deselectIfCurrent && this.currentFeature == geojson) {
            this.currentFeature = undefined;
            this.updateMetadata();
        } else {        
            this.currentFeature = geojson;
            this.updateMetadata(geojson);
        }
    }
    
    cms.GeoMapEditor.prototype.deleteCurrentFeature = function() {
        if(this.currentFeature && this.activeFeatureGroup) {
            this.activeFeatureGroup.removeMarker(this.currentFeature);
            this.currentFeature = undefined;
            this.updateMetadata();
        }
    }
    
    cms.GeoMapEditor.prototype.updateCurrentFeatureMetadata = function(metadata) {
        if(this.activeFeatureGroup && this.currentFeature && metadata) {                                                
            this.currentFeature.properties[metadata.property] = metadata.value;
            this.activeFeatureGroup.updateMarker(this.currentFeature.id);
        }
    }
    
    cms.GeoMapEditor.prototype.getView = function(view) {
        if(!view) {
            view = $(this.config.viewInput).val();
            if(!view) {
                view = this.geoMap.config.initialView;
            } else {                
                view = JSON.parse(view);
            }
            if(this.activeFeatureGroup?.getFeatures()?.length > 0) {            
                return this.geoMap.getViewAroundFeatures(this.activeFeatureGroup.getFeatures(), view.zoom);
            } else {           
                return view;
            }
        } else {
            return view;
        }
    }

    cms.GeoMapEditor.prototype.updateView = function(view) {
        if(!view) {
            view = $(this.config.viewInput).val();
            if(!view) {
                view = this.geoMap.config.initialView;
            } else {                
                view = JSON.parse(view);
            }
            if(this.activeFeatureGroup?.getFeatures()?.length > 0) {            
                this.geoMap.setView(this.geoMap.getViewAroundFeatures(this.activeFeatureGroup.getFeatures(), view.zoom));
            } else {           
                this.geoMap.setView(view);
            }
        } else {
            this.geoMap.setView(view);
        }
       
    }
    
    /**
     * Update all map features from the content of the config.featuresInput field
     */
    cms.GeoMapEditor.prototype.updateFeatures = function() {

        let features = JSON.parse($(this.config.featuresInput).val())
        if(_debug)console.log("update features", features);
        features.forEach( feature => {
            this.activeFeatureGroup?.addMarker(feature);
        })
    }
    
    cms.GeoMapEditor.prototype.setAllowEditFeatures = function(allow) {
        this.config.allowEditFeatures = allow;
        if(this.activeFeatureGroup) {			
	        this.activeFeatureGroup.config.allowMovingFeatures = allow;
	        this.activeFeatureGroup.markers.filter(m => m.dragging).forEach(marker => {
	            if(allow) {
	                marker.dragging.enable();
	            } else {
	                marker.dragging.disable();
	            }
	        })
		}
    }

        
       
    return cms;
    
} )( cmsJS || {}, jQuery );
var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _map = {};
    var _mapEnlarged = {};
    var _features = [];
    var _centerCoords = [];
    var _defaults = {
        appUrl: '',
        locations: '',
        mapboxAccessToken: '',
        mapBoxContainerSelector: 'widgetGeoLocationsMap',
        mapBoxContainerEnlargedSelector: 'widgetGeoLocationsMapEnlarged',
        mapBoxStyle: 'mapbox://styles/lirumgbv/cii024wxn009aiolzgy2zlycj',
        msg: {
            propertiesLink: ''
        }
    };
    
    cms.geoLocations = {
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cms.geoLocations.init' );
                console.log( '##############################' );
                console.log( 'cms.geoLocations.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            if ( $( '#widgetGeoLocationsMap' ).length > 0 ) {
                mapboxgl.accessToken = _defaults.mapboxAccessToken;
                
                // get map data and infos
                _centerCoords = _getCenterCoords( _defaults.locations );
                _features = _getMapFeatures( _defaults.locations );
                
                // create map
                _map = new mapboxgl.Map( {
                    container: _defaults.mapBoxContainerSelector,
                    style: _defaults.mapBoxStyle,
                    center: _centerCoords,
                    zoom: 12.5,
                    interactive: true
                } );
                
                // build markers
                _map.on( 'style.load', function() {
                    _map.addSource( "markers", {
                        "type": "geojson",
                        "data": {
                            "type": "FeatureCollection",
                            "features": _features
                        }
                    } );
                    
                    _map.addLayer( {
                        "id": "markers",
                        "type": "symbol",
                        "source": "markers",
                        "layout": {
                            "icon-image": "pin",
                            "icon-allow-overlap": true
                        }
                    } );
                    
                    _map.addControl( new mapboxgl.FullscreenControl() );
                    _map.addControl( new mapboxgl.NavigationControl() );
                    
                    $("#" + _defaults.mapBoxContainerSelector).closest(".widget").show();
                } );
                
                // add popups
                _map.on( 'click', 'markers', function( e ) {
                    new mapboxgl.Popup().setLngLat( e.features[ 0 ].geometry.coordinates ).setHTML( e.features[ 0 ].properties.infos ).addTo( _map );
                    
                    // GAUGS: save collection to local storage for slider use
                    $( '.mapboxgl-popup-content a' ).on( 'click', function( event ) {
                        event.preventDefault();
                        var url = $( this ).attr( 'href' );
                        var collection = $( this ).attr( 'data-collection' );
                        
                        if ( collection === 'false' ) {
                            sessionStorage.setItem( 'sliderImagesFrom', 0 );
                        }
                        else {
                            sessionStorage.setItem( 'sliderImagesFrom', collection );
                        }
                        window.location.href = url;
                    } );
                } );
            }
            
        }
    };
    
    /**
     * Method which returns an object of map features.
     * 
     * @method _getMapFeatures
     * @param {String} infos A JSON-String which contains the feature infos.
     * @returns {Array} An array of features.
     */
    function _getMapFeatures( infos ) {
        if ( _debug ) {
            console.log( '---------- _getMapFeatures() ----------' );
            console.log( '_getMapFeatures: infos - ', infos );
        }
        
        var features = [];
        var collection = '';
        var infos = JSON.parse( infos );
        
        $.each( infos.locations, function( key, location ) {
            // GAUGS: special condition to get the right collection number for image
            // slider
            if ( location.link != undefined ) {
                if ( location.link.indexOf( '/sammlung/' ) != -1 ) {
                    var str = location.link;
                    collection = str.replace( '/sammlung/', '' ).replace( '/', '' );
                }
            }
            
            var feature = {
                'type': 'Feature',
                'geometry': {
                    'type': 'Point',
                    'coordinates': [ location.longitude, location.latitude ]
                },
                'properties': {
                    'infos': location.infos + '<br /><a href="' + _defaults.appUrl + location.link + '" data-collection="' + ( ( collection !== '' ) ? collection : 'false' )
                            + '">' + _defaults.msg.propertiesLink + '</a>'
                }
            }

            features.push( feature );
        } );
        
        return features;
    }
    
    /**
     * Method which returns an array of coordinates for centering the map.
     * 
     * @method _getCenterCoords
     * @param {String} infos A JSON-String which contains the feature infos.
     * @returns {Array} An array of coords.
     */
    function _getCenterCoords( infos ) {
        if ( _debug ) {
            console.log( '---------- _getCenterCoords() ----------' );
        }
        
        var coords = [];
        var infos = JSON.parse( infos );
        
        if ( infos.centerLocation.longitude != '' || infos.centerLocation.latitude != '' ) {
            coords.push( infos.centerLocation.longitude );
            coords.push( infos.centerLocation.latitude );
        }
        else {
            coords.push( infos.locations[ 0 ].longitude );
            coords.push( infos.locations[ 0 ].latitude );
        }
        
        return coords;
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _data = null;
    var _lazyGrid = null;
    var _defaults = {
        $grid: null,
        loaderSelector: '.tpl-masonry__loader',
		language: 'de'
    };
    
    // DOM-Elements
    var $gridItem = null;
    var $gridItemImage = null;
    var $gridItemImageLink = null;
    var $gridItemTitle = null;
    var $gridItemTitleLink = null;
    var $gridItemCaption = null;
    var $gridItemCaptionHeading = null;
    var $gridItemCaptionLink = null;
    
    cms.masonry = {
        /**
         * Method which initializes the Masonry Grid.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {Object} config.$grid An jQuery object which represents the grid
         * container.
         * @param {Object} data An data object which contains the images sources for the
         * grid.
         */
        init: function( configuration, data ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.masonry.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.masonry.init: config - ', configuration );
                console.log( 'cmsJS.masonry.init: data - ', data );
            }
            
            var config = $.extend( true, {}, _defaults, configuration );
            
            // show loader
            $( config.loaderSelector ).show();
            
            // render grid
            _renderMasonryGrid( data, config );
            
            let $images = config.$grid.find('img');
            let promises = [];
            $images.each( (index,element) => {
            	let promise = new Promise((res, rej) => {
            		element.onload = e => res(e);
            		element.onerror = e => rej(e);
            	});
            	promises.push(promise);
            });
            
            Promise.allSettled(promises)
            .then( array => {
            	//console.log("all images loaded in ", config.$grid, array);
                // init Masonry after all images have loaded
                config.$grid.masonry( {
                    itemSelector: '.grid-item',
                    columnWidth: '.grid-sizer',
                    gutter: '.gutter-sizer',
                    percentPosition: true
                } );
            })
            .catch( e => {
            	console.log("error when trying to detect all images loaded", e);
            });

            // fade in grid after rendering
            config.$grid.on( 'layoutComplete', function( event, laidOutItems ) {
                // hide loader 
                $( config.loaderSelector ).hide();
                // show images
                config.$grid.addClass( 'ready' );
            } );
            
        }
    };
    
    /**
     * Method which renders the masonry grid.
     * 
     * @method _renderMasonryGrid
     * @param {Object} data An data object which contains the images sources for the grid.
     */
    function _renderMasonryGrid( data, config ) {
        if ( _debug ) {
            console.log( '---------- _renderMasonryGrid() ----------' );
            console.log( '_renderMasonryGrid: data = ', data );
        }
        
        // create items
        data.mediaItems.forEach( function( item ) {
            // grid item
            $gridItem = $( '<div />' );
            if ( item.important ) {
                $gridItem.addClass( 'grid-item important ' + item.tags.join(' ') );
            }

            else {
                $gridItem.addClass( 'grid-item ' + item.tags.join(' '));
            }
            
            let label = viewerJS.getMetadataValue(item.label, config.language );
            let description = viewerJS.getMetadataValue(item.description, config.language );
            
            let image = item.image["@id"];
            if(item.image.service) { 
                image = item.image.service["@id"] + "/full/max/0/default.jpg";
            }
            

            // grid item title
            if(label) {                
                $gridItemTitle = $( '<div />' );
                if ( item.link ) {
                    $gridItemTitleLink = $( '<a />' );
                    $gridItemTitleLink.attr( 'href', item.link );
                    $gridItemTitleLink.attr( 'title', label );
                }
                $gridItemTitle.addClass( 'grid-item-title' );
                $gridItemTitle.text( label );
                if ( item.link  ) {
                    $gridItemTitleLink.append( $gridItemTitle );
                    $gridItem.append( $gridItemTitleLink );
                }
                else {
                    $gridItem.append( $gridItemTitle );
                }
            }
            
            // grid item caption
            if ( description ) {
                $gridItemCaption = $( '<div />' );
                $gridItemCaption.addClass( 'grid-item-caption' );
                $gridItemCaption.html( '<span>' + description + '</span>');
                
                // grid item caption heading
                $gridItemCaptionHeading = $( '<h2 />' );
                $gridItemCaptionHeading.addClass( 'h3' );
                $gridItemCaptionHeading.text( label );
                $gridItemCaption.prepend( $gridItemCaptionHeading );
                
                if ( item.link !== '' ) {
                    // grid item caption link
                    $gridItemCaptionLink = $( '<a />' );
                    $gridItemCaptionLink.attr( 'href', item.link );
                    $gridItemCaptionLink.attr( 'title', label );
                    
                    // append to grid item
                    $gridItemCaptionLink.append( $gridItemCaption );
                    $gridItem.append( $gridItemCaptionLink );
                }
                else {
                    $gridItem.append( $gridItemCaption );
                }
            }
            
            // grid item image
            $gridItemImage = $( '<img />' );
            $gridItemImage.attr( 'src', image );
            $gridItemImage.attr( 'alt', label );
            $gridItemImage.addClass( 'img-fluid' );
             
            if ( item.link !== '' ) {
                // grid item image link
                $gridItemImageLink = $( '<a />' );
                $gridItemImageLink.attr( 'href', item.link );
                $gridItemImageLink.attr( 'title', label );
                $gridItemImageLink.append( $gridItemImage );
                $gridItem.append( $gridItemImageLink );
            }
            else {
                $gridItem.append( $gridItemImage );
            }
            
            // append to grid
            config.$grid.append( $gridItem );
        } );
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _defaults = {
    		allowEdit: true,
    		forceGrid: false,
    		isMediaSelectModal: false
    };
    var _adminCmsMediaGrid = '';
    
    cms.media = {
        /**
         * @description Method which initializes the media module.
         * @method init
         * @param {Object} config The config object.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.media.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.media.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            // init events
            this.initEventListeners();
            
            // check if media select modal is open
            this.checkMediaSelectModal( _defaults.isMediaSelectModal );
        },
        /**
         * @description Method to check if the media select modal exist.
         * @method checkMediaSelectModal
         * @param {Boolean} modal The status of the media select modal.
         * */
        checkMediaSelectModal: function( modal ) {
        	if ( _debug ) {
        		console.log( 'EXECUTE: checkMediaSelectModal' );
        		console.log( '--> modal: ', modal );
        	}
        	
        	if ( modal ) {
        		$( 'html' ).addClass( 'no-overflow' );
        	}
        	else {
        		$( 'html' ).removeClass( 'no-overflow' );            	
        	}        	
        },
        /**
         * @description Method to reload all event listeners.
         * @method onReload
         * @param {Object} data The ajax data object from jsf.
         * */
        onReload: function( data ) {
        	if ( _debug ) {
        		console.log( 'EXECUTE: onReload' );
        		console.log( '--> data: ', data );
        	}

        	if ( data && data.status == 'begin' ) {
            	cms.media.removeEventListeners();
            } 
            else if ( !data || data.status == 'success' ) {
            	cms.media.initEventListeners();
            }
        },
        /**
         * @description Method to initialize all events.
         * @method initEventListeners
         * */
        initEventListeners: function() {
            // select all media items
            $( '#selectAllMediaItems' ).on( 'change', function() {
            	if ( this.checked ) {
                    $( 'input[name*="selectMediaItem"]' ).each( function() {
                    	$( this ).prop( 'checked', true );
                    } );
                }
            	else {
            		$( 'input[name*="selectMediaItem"]' ).each( function() {
            			$( this ).prop( 'checked', false );
            		} );            		
            	}
            } );
            
            // reset bulk actions
            $( '#selectAllMediaItems, input[name*="selectMediaItem"]' ).on( 'change', function() {
            	$( '#bulkActionSelect' ).val( 'bulk' );
            	$( '[data-action="cancel"]' ).click();
            } );
            
            // bulk action edit
            $( '#bulkActionSelect' ).on( 'change', function() {
            	var action = $( this ).val();
            	
            	switch ( action ) {
            		case 'edit':
            			_bulkActionEdit();
            			break;
            		case 'delete':
            			var bulkDelete = confirm( _defaults.msg.bulkDeleteConfirm );
            			
            			if ( bulkDelete ) {
            				$('#deleteSelectedItemsButton').click();
            			}
            			else {
            				$( '#selectAllMediaItems' ).prop( 'checked', false );
            				$( 'input[name*="selectMediaItem"]' ).each( function() {
                    			$( this ).prop( 'checked', false );
                    		} );
            				$( this ).val( 'bulk' );
            			}
            			break;
            	}
            } );
			
			// switch file view
			_adminCmsMediaGrid = sessionStorage.getItem( 'adminCmsMediaGrid' );
			
			if ( _defaults.forceGrid ) {
				$( '[data-switch="list"]' ).removeClass( 'active' );
				$( '.admin-cms-media__files' ).addClass( 'grid' );
			} 
			else if ( sessionStorage.getItem( 'adminCmsMediaGrid' ) == undefined || sessionStorage.getItem( 'adminCmsMediaGrid' ) == '' ) {
				sessionStorage.setItem( 'adminCmsMediaGrid', true );
				_adminCmsMediaGrid = sessionStorage.getItem( 'adminCmsMediaGrid' );
				_setMediaGridStatus( _adminCmsMediaGrid );
			}
			else {
				_setMediaGridStatus( _adminCmsMediaGrid );			
			}

			$( '[data-switch="list"]' ).on( 'click', function() {
				$( this ).addClass( 'active' );
				$( '[data-switch="grid"]' ).removeClass( 'active' );
				$( '.admin-cms-media__files' ).removeClass( 'grid' );
				$( '#selectAllMediaItems, #bulkActionSelect' ).prop( 'disabled', false ).removeClass( 'disabled' );
				sessionStorage.setItem( 'adminCmsMediaGrid', false );
			});
			$( '[data-switch="grid"]' ).on( 'click', function() {
				$( this ).addClass( 'active' );
				$( '[data-switch="list"]' ).removeClass( 'active' );
				$( '.admin-cms-media__files' ).addClass( 'grid' );
				$( '#selectAllMediaItems, #bulkActionSelect' ).prop( 'disabled', true ).addClass( 'disabled' );
				sessionStorage.setItem( 'adminCmsMediaGrid', true );
			});
			
            // show/hide edit actions for media file
            _setFileCancelClick( false );
            
            $( '[data-action="edit"]' ).on( 'click', function() {
            	_toggleEditMode( $( this ).parents( '.admin-cms-media__file' ), false );
            	$( this ).parent().removeClass( 'in');
            	$( this ).parent().next().addClass('in');
			});
			
			// enlarge file
            if( _defaults.allowEdit ) {
				$( '.admin-cms-media__file-image, .admin-cms-media__file-close' ).on( 'click', function() {
					var $thisFile = $( this ).parents( '.admin-cms-media__file' ); 
					
					// show modal
					$thisFile.toggleClass( 'fixed' );
					$( '.admin-cms-media__overlay' ).toggle();
	
					// set modal events				
					if ( $thisFile.hasClass( 'fixed' ) ) {
						_setFileCancelClick( true );
						_setFileKeyEvents( true );
						_toggleEditMode( $( '.admin-cms-media__file' ), true );					
					}
					else {
						_setFileCancelClick( false );
						_setFileKeyEvents( false );
						$( '[data-action="cancel"]' ).click();
					}
				} );
            }
			
			// navigate through overlays
			$( '.admin-cms-media__file' ).first().find( '.admin-cms-media__file-prev' ).addClass( 'disabled' );
			$( '.admin-cms-media__file' ).last().find( '.admin-cms-media__file-next' ).addClass( 'disabled' );
			
			$( '.admin-cms-media__file-next' ).on( 'click', function() {
				if ( $( this ).parent().is( '.admin-cms-media__file:last' ) ) {
					$( this ).addClass( 'disabled' );
					return false;
				}
				else {
					$( this ).removeClass( 'disabled' );
					$( this ).parent().removeClass( 'fixed' ).next().addClass( 'fixed' );
				}
			} );
			$( '.admin-cms-media__file-prev' ).on( 'click', function() {
				if ( $( this ).parent().is( '.admin-cms-media__file:first' ) ) {
					$( this ).addClass( 'disabled' );
					return false;
				}
				else {
					$( this ).removeClass( 'disabled' );
					$( this ).parent().removeClass( 'fixed' ).prev().addClass( 'fixed' );
				}
			} );
        },
        /**
         * @description Method to remove all events.
         * @method removeEventListeners
         * */
        removeEventListeners: function() {
            // select all media items
            $( '#selectAllMediaItems' ).off();
            
            // reset bulk actions
            $( '#selectAllMediaItems, input[name*="selectMediaItem"]' ).off();
            
            // bulk action edit
            $( '#bulkActionSelect' ).off();
			
			// switch file view
			_adminCmsMediaGrid = sessionStorage.getItem( 'adminCmsMediaGrid' );

			$( '[data-switch="list"]' ).off();
			$( '[data-switch="grid"]' ).off();            
            $( '[data-action="edit"]' ).off();
			
			// enlarge file
			$( '.admin-cms-media__file-image, .admin-cms-media__file-close' ).off();
			
			// navigate through overlays			
			$( '.admin-cms-media__file-next' ).off();
			$( '.admin-cms-media__file-prev' ).off();			
			$( '.admin-cms-media__file' ).off( 'mouseover' ).off( 'mouseout' ).off( 'keydown' );	
			$( '[data-action="cancel"]' ).off();
        }
    };
    
    /**
     * @description Method to set the status of the media item grid and the switches.
     * @method _setMediaGridStatus
     * @param {String} status The status of the media item grid.
     * */
    function _setMediaGridStatus( status ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setMediaGridStatus' );
    		console.log( '--> status: ', status );
    	}
    	
    	if ( status === 'true' ) {
			$( '.admin-cms-media__files' ).addClass( 'grid' );
			$( '[data-switch="list"]' ).removeClass( 'active' );
			$( '[data-switch="grid"]' ).addClass( 'active' );
			$( '#selectAllMediaItems, #bulkActionSelect' ).prop( 'disabled', true ).addClass( 'disabled' );
		}
		else {
			$( '.admin-cms-media__files' ).removeClass( 'grid' );					
			$( '[data-switch="list"]' ).addClass( 'active' );
			$( '[data-switch="grid"]' ).removeClass( 'active' );
			$( '#selectAllMediaItems, #bulkActionSelect' ).prop( 'disabled', false ).removeClass( 'disabled' );
		}
    }

    /**
     * @description Method to set multiple media items to edit mode.
     * @method _bulkActionEdit
     * */
    function _bulkActionEdit() {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _bulkActionEdit' );
    	}
    	
    	$( '.admin-cms-media__file' ).each( function() {
    		var $file = $( this ),
    		    $cbStatus = $file.find( 'input[name*="selectMediaItem"]' ).prop( 'checked' ),
    		    $editButton = $file.find( '[data-action="edit"]' );
    		
    		if ( $cbStatus ) {
    			$editButton.click();
    		}
    	} );
    }
    
    /**
     * @description Method to switch the file edit mode.
     * @method _toggleEditMode
     * @param {Object} item A jQuery object which contains the current media file.
     * @param {Boolean} modal Trigger to switch between modal and list files.
     * */
    function _toggleEditMode( item, modal ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _toggleEditMode' );
    		console.log( '--> item: ', item );
    		console.log( '--> modal: ', modal );
    	}
    	
    	if ( modal ) {
    		item.each( function() {
    			$( this ).find( '.admin-cms-media__file-metadata-view' ).removeClass( 'in');
    			$( this ).find( '.admin-cms-media__file-metadata-edit' ).addClass( 'in');
    			$( this ).find( '.admin-cms-media__file-actions-view' ).removeClass( 'in' );
    			$( this ).find( '.admin-cms-media__file-actions-edit' ).addClass( 'in' );
    		} );
    	}
    	else {
    		item.find( '.admin-cms-media__file-metadata-view' ).removeClass( 'in');
    		item.find( '.admin-cms-media__file-metadata-edit' ).addClass( 'in');
    	}
    	
    }
    
    /**
     * @description Method to set the keyboard events for the media file modal.
     * @method _setFileKeyEvents
     * @param {Boolean} modal Trigger to switch between modal and list files.
     * */
    function _setFileKeyEvents( modal ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setFileKeyEvents' );
    		console.log( '--> modal: ', modal );
    	}
    	
    	if ( modal ) {
    		$( '.admin-cms-media__file' ).off().on( 'keydown', function( e ) {
    			var code = e.keyCode || e.which;
    			var isInput = e.target.tagName.toLowerCase().match( /input|select|textarea/ );
    			
    			if ( isInput ) {
    				return;
    			}
    			else {
    				switch ( code ) {
    				// esc
    				case 27:
    					$( this ).find( '[data-action="cancel"]' ).click();
    					$( '.admin-cms-media__file' ).off( 'keydown' );
    					break;
    					// left
    				case 37:
    					if ( $( this ).is( '.admin-cms-media__file:first' ) ) {
    						return false;
    					}
    					else {
    						$( this ).removeClass( 'fixed' ).prev().addClass( 'fixed' ).focus();	    					
    					}	    				
    					break;
    					// right
    				case 39:
    					if ( $( this ).is( '.admin-cms-media__file:last' ) ) {
    						return false;
    					}
    					else {
    						$( this ).removeClass( 'fixed' ).next().addClass( 'fixed' ).focus();
    					}	    				
    					break;
    				}    				
    			}
    		} );
    	}
    	else {
    		$( '.admin-cms-media__file' ).off( 'keydown' );		
    	}
    }
    
    /**
     * @description Method to set the click event for media file cancel button.
     * @method _setFileCancelClick
     * @param {Boolean} modal Trigger to switch between modal and list files.
     * */
    function _setFileCancelClick( modal ) {
    	if ( _debug ) {
    		console.log( 'EXECUTE: _setFileCancelClick' );
    		console.log( '--> modal: ', modal );
    	}
    	
    	if ( modal ) {
    		$( '[data-action="cancel"]' ).off().on( 'click', function() {
				$( this ).parents( '.admin-cms-media__file' ).toggleClass( 'fixed' );
				$( '.admin-cms-media__overlay' ).toggle();
				_setFileCancelClick( false );
				$( '[data-action="cancel"]' ).click();
			});
    	}
    	else {
    		$( '[data-action="cancel"]' ).off().on( 'click', function() {
				$( this ).parents( '.admin-cms-media__file' ).find( '.admin-cms-media__file-metadata-view' ).addClass( 'in');
				$( this ).parents( '.admin-cms-media__file' ).find( '.admin-cms-media__file-metadata-edit' ).removeClass( 'in');
				$( this ).parent().removeClass( 'in' );
				$( this ).parent().prev().addClass( 'in' );
			});
    	}
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    var _debug = false;
    
    cms.modules = {
    	/**
         * @description Method which initializes the cms modules.
         * @method init
         * @param {Object} config The config object.
         */
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.modules.init' );
                console.log( '##############################' );
            }
            
            this.initEventListeners();
            this.cleanUp();
            
            // jsf ajax event
            if ( typeof jsf !== 'undefined' ) {
            	jsf.ajax.addOnEvent( function( data ) {
            		var ajaxstatus = data.status;
            		
            		switch (ajaxstatus) {
            		case 'begin':
            			break;
            		case 'complete':
            			break;
            		case 'success':
            			if ( $( '.cms-module__option-message, .input_form__option-message' ).length > 0 ) {
            				cmsJS.modules.setValidationStatus( data.source.id );							
            			}
            			
            			break;
            		}
            	});            	
            }
        },
        /**
		 * @description Method to set the validation status.
		 * @method setValidationStatus
		 * @param {String} source The id of the element which fired the ajax request,
		 */
        setValidationStatus: function( source ) {
        	if ( _debug ) {
        		console.log( 'EXECUTE: setValidationStatus' );
        		console.log( '--> source: ', source );
        	}
        	
        	var stripedSource,
        		status;
        	
        	if ( source.indexOf( ':' ) > -1 ) {
        		stripedSource = source.match(/.*:(.*)/)[1];        		
        		status = $( '[id*="' + stripedSource + '"]' ).parents( '.cms-module__option-control, .input_form__option_control' ).find( '.cms-module__option-message-status, .input_form__option-message-status' );
        	}
        	else {
        		stripedSource = source;       		
        		status = $( '#' + stripedSource ).parents( '.cms-module__option-control, .input_form__option_control' ).find( '.cms-module__option-message-status, .input_form__option-message-status' );
        	}

        	if ( status.hasClass( 'success' ) ) {
        		$( '[id*="' + stripedSource + '"]' ).parents( '.cms-module__option-control, .input_form__option_control' ).find( '.cms-module__option-message-mark, .input_form__option-message-mark' ).addClass( 'success' );
        		$( '[id*="' + stripedSource + '"]' ).addClass( 'success' );
        	}
        	else if ( status.hasClass( 'warning' ) ) {
        		$( '[id*="' + stripedSource + '"]' ).parents( '.cms-module__option-control, .input_form__option_control' ).find( '.cms-module__option-message-mark, .input_form__option-message-mark' ).addClass( 'warning' );
        		$( '[id*="' + stripedSource + '"]' ).addClass( 'warning' );
        	}
        	else if ( status.hasClass( 'danger' ) ) {
        		$( '[id*="' + stripedSource + '"]' ).parents( '.cms-module__option-control, .input_form__option_control' ).find( '.cms-module__option-message-mark, .input_form__option-message-mark' ).addClass( 'danger' );
        		$( '[id*="' + stripedSource + '"]' ).addClass( 'danger' );
        	}
        },
        /**
         * @description Method to clean up modules.
         * @method cleanUp
         */
        cleanUp: function() {
        	if ( _debug ) {
        		console.log( 'EXECUTE: cleanUp' );
        	}
        	
        	if ( $( '.cms-module__option-message ul' ).length > 0 ) {
        		$( '.cms-module__option-message ul' ).empty();
        	}
        },
        
        /** 
         * @description Method to initialize all event listeners.
         * @method initEventListeners
         */
        initEventListeners: function() {
            // toggle input helptext
            $( 'body' ).off('click.helptext').on( 'click.helptext', '[data-toggle="helptext"]', function() {
            	$( this ).toggleClass( 'in' );
            	
            	let forId = $(this).attr("for");
            	let $input;
            	if(forId) {
            	    $input = $("#" + forId);
            	    $input.toggleClass( 'in' );
            	} else {
            	    $input = $( this ).closest( '.cms-module__option-group' ).find( '.cms-module__option-control, .cms-module__option-dropdown' );            	    
            	    $input.toggleClass( 'in' );
            	    $input.find( '.cms-module__option-control-helptext' ).toggleClass( 'in' );
            	}
            	
            } );
            
            // toggle add new item accordeon
            $( 'body' ).off('click.toggle-items').on( 'click.toggle-items', '[data-toggle="available-items"]', function() {
            	if ( $( this ).hasClass( 'in' ) ) {
            		$( this ).toggleClass( 'in' );
                	$( this ).parent().find( '.cms-menu__available-items-toggle' ).slideToggle( 'fast', function() {
                		// focus first input if available
                		$( '.cms-menu__available-items-toggle .cms-module__option-group' ).first().find( '.form-control' ).focus();
                	} );
            	}
            	else {
            		$( '[data-toggle="available-items"], .cms-menu__available-items-toggle' ).each( function() {
            			$( '[data-toggle="available-items"]' ).removeClass( 'in' );
            			$( '.cms-menu__available-items-toggle' ).slideUp( 'fast' );
            		} );
            		
            		$( this ).toggleClass( 'in' );
            		$( this ).parent().find( '.cms-menu__available-items-toggle' ).slideToggle( 'fast', function() {
            			// focus first input if available
            			$( '.cms-menu__available-items-toggle .cms-module__option-group' ).first().find( '.form-control' ).focus();
            		} );            		
            	}
            } );
            
            // toggle option dropdown
            $( 'body' ).off('click.option-dropdown').on( 'click.option-dropdown', '[data-toggle="option-dropdown"]', function() {
            	$( this ).next().slideToggle( 'fast' );
            } );
            $( document ).on( 'click', function( event ) {
            	if ( $( event.target ).closest( '.cms-module__option-dropdown' ).length ) {	
            		return;
            	}
            	else {            		
            		$( '.cms-module__option-dropdown' ).find( 'ul' ).hide();
            	}
            } );
        }
    };
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _defaults = {
        rssFeedSelector: '.tpl-rss__feed',
        msg: {
            continueReading: 'Weiterlesen'
        }
    };
    
    cms.rssFeed = {
        /**
         * Method which initializes the RSS Feed.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {Object} data An data object which contains the images sources for the
         * grid.
         */
        init: function( config, data ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.rssFeed.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.rssFeed.init: config - ', config );
                console.log( 'cmsJS.rssFeed.init: data - ', data );
            }
            
            $.extend( true, _defaults, config );
            
            // render RSS Feed
            _renderRssFeed( data );
        }
    };
    
    /**
     * Method which renders the RSS feed into the DOM.
     * 
     * @method _renderRssFeed
     * @param {Object} data The RSS information data object.
     */
    function _renderRssFeed( data ) {
        if ( _debug ) {
            console.log( '---------- _renderRssFeed() ----------' );
            console.log( '_renderRssFeed: data = ', data );
        }
        
        // DOM elements
        var rssItem = null;
        var rssItemTitle = null;
        var rssItemTitleHeading = null;
        var rssItemTitleLink = null;
        var rssItemRow = null;
        var rssItemColLeft = null;
        var rssItemColRight = null;
        var rssItemImageWrapper = null;
        var rssItemDocTypeH3 = null;
        var rssItemImage = null;
        var rssItemImageLink = null;
        var rssItemDate = null;
        var rssItemTime = null;
        var rssItemMetadata = null;
        var rssItemMetadataKey = null;
        var rssItemMetadataValue = null;
        var rssItemLinkWrapper = null;
        var rssItemLink = null;
        
        // create items
        data.items.forEach( function( item ) {
            // create item wrapper
            rssItem = $( '<div />' );
            rssItem.addClass( 'tpl-rss__item' );
            
            // create item content
            rssItemRow = $( '<div />' ).addClass( 'row' );
            
            // left
            rssItemColLeft = $( '<div />' ).addClass( 'col-12 col-md-4' );
            // rssItemDocTypeH3 = $( '<h2 />' ).text( item.docType );
            rssItemImageWrapper = $( '<div />' ).addClass( 'tpl-rss__item-image' );
            rssItemImageLink = $( '<a />' ).attr( 'href', item.link );
            rssItemImage = $( '<img />' ).attr( 'src', item.description.image ).addClass( 'img-fluid' );
            // add alt attr
            rssItemImage.attr( 'alt', item.title );
            rssItemImageLink.append( rssItemImage );
            rssItemImageWrapper.append( rssItemImageLink );
            //console.log("item image", item.description.image);
            if(item.description.image) {
            	rssItemColLeft.append( rssItemImageWrapper );
			}             
            
            // right  
            rssItemColRight = $( '<div />' ).addClass( 'col-12 col-md-8' );
            
            // create item title
            rssItemTitle = $( '<div />' ).addClass( 'tpl-rss__item-title' );
            rssItemTitleHeading = $( '<h2 />' );
            rssItemTitleHeading.addClass('h3');
            rssItemTitleLink = $( '<a />' ).attr( 'href', item.link ).text( item.title );
            rssItemTitleHeading.append( rssItemTitleLink );
            rssItemTitle.append( rssItemTitleHeading );
                        
            // create metadata
            rssItemMetadata = $( '<dl />' ).addClass( 'tpl-rss__item-metadata dl-horizontal' );
            item.description.metadata.forEach( function( metadata ) {
                rssItemMetadataKey = $( '<dt />' ).text( metadata.label + ':' );
                rssItemMetadataValue = $( '<dd />' ).text( metadata.value );
                rssItemMetadata.append( rssItemMetadataKey ).append( rssItemMetadataValue );
            } );
            // link to work
            rssItemLinkWrapper = $( '<div />' ).addClass( 'tpl-rss__item-link' );
            // rssItemLink = $( '<a />' ).attr( 'href', item.link ).addClass( 'btn btn--full' ).text( _defaults.msg.continueReading );
            rssItemLinkWrapper.append( rssItemLink );

            // append to col right
            rssItemColRight.append( rssItemTitle ).append( rssItemDate ).append( rssItemMetadata ).append( rssItemLinkWrapper);
            
            // append to row
            rssItemRow.append( rssItemColLeft ).append( rssItemColRight );
            
            // create item
            rssItem.append( rssItemRow );
            
            $( _defaults.rssFeedSelector ).append( rssItem );
        } );
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    var _debug = false;
    var _levelIndent = 0;
    var _allowMultipleOccurances = false;
    var _inputField = null;
    var _sortingAttribute = 'sortposition';
    var _config = {};
    
    cms.sortableList = {
        /**
         * Method which initializes the CMS sortable list items and sets events.
         * 
         * @method init
         * @param {String} indent
         * @param {Boolean} allowMultiple
         * @param {Object} config
         */
        init: function( indent, allowMultiple, config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.sortableList.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.sortableList.init: indent - ', indent );
                console.log( 'cmsJS.sortableList.init: allowMultiple - ', allowMultiple );
                console.log( 'cmsJS.sortableList.init: inputTextField - ', config.sortablesConfig.componentListInput );
            }
            
            _levelIndent = indent;
            _allowMultipleOccurances = allowMultiple;
            _inputField = config.sortablesConfig.componentListInput;
            _config = config;
            
            // validation
            if ( _inputField === null ) {
                console.warn( "Input field for item order not found: No order information can be saved!" );
            }
            if ( config.sortablesConfig.visibleItemList.length === 0 ) {
                console.error( "No container for active items found. Cannot initialize sortable" );
            }
//            if ( config.sortablesConfig.availableItemList.length === 0 ) {
//                console.error( "No container for available items found. Cannot initialize sortable" );
//            }
            
            _updateAllSortIcons();
            
            if ( _debug ) {                
                console.log( "Make sortable ", config.sortablesConfig.visibleItemList );
            }
            $(config.sortablesConfig.visibleItemList).sortable( {
                update: _serializeVisibleItems,
                connectWith: config.sortablesConfig.availableItemList
            } );
            
            if ( _debug ) {                
                console.log( "Make sortable ", config.sortablesConfig.availableItemList );
            }
            $(config.sortablesConfig.availableItemList).sortable( {
                update: _serializeVisibleItems,
                connectWith: config.sortablesConfig.visibleItemList,
                helper: "clone"
            } );
            
            _serializeVisibleItems();
            $( config.sortablesConfig.availableItemList ).on( "sortbeforestop", _handleBeforeDropFromAvailable );
            $( config.sortablesConfig.visibleItemList ).on( "sortbeforestop", _handleBeforeDropFromVisible );
            $( config.sortablesConfig.availableItemList ).on( "sortstop", _handleDrop );
            $( config.sortablesConfig.visibleItemList ).on( "sortstop", _handleDrop );
            
            // toggle edit visible item
            $( '[data-toggle="edit-visible-item"]' ).on( 'click', function() {
            	$( this ).toggleClass( 'in' );
            	$( this ).parent().next( '.cms-menu__visible-item-edit-wrapper' ).slideToggle( 'fast' );
            } );

            // toggle edit available item
            $( '[data-toggle="edit-available-item"]' ).on( 'click', function() {
            	$( this ).toggleClass( 'in' );
            	$( this ).parent().next( '.cms-menu__available-item-edit-wrapper' ).slideToggle( 'fast' );
            } );
            
            // fix menu save on scroll
            if($( '.cms-menu__save' ).length > 0) {                
                _fixMenuSave();
                $( window ).on( 'resize, orientationchange', function() {
                    _fixMenuSave();
                } );
            }
            
        },
        
        remove: function(element) {
            if ( _debug ) {
                console.log( 'cmsJS.sortableList.remove: element - ', element );
            }
            var item = _getJQueryItem( element );
            item.remove();
            _updateAllSortIcons();
            _serializeVisibleItems();
        },
        
        /**
         * Method which
         * 
         * @method decreaseLevel
         * @param {String} element
         * @param {String} applyToNext
         */
        decreaseLevel: function( element, applyToNext ) {
            if ( _debug ) {
                console.log( 'cmsJS.sortableList.decreaseLevel: element - ', element );
                console.log( 'cmsJS.sortableList.decreaseLevel: applyToNext - ', applyToNext );
            }
            
            var item = _getJQueryItem( element );
            var level;
            
            if ( _getLevel( item ) > 0 ) {
                level = _changePos( item, -1 );
                if ( applyToNext ) {
                    var nextItem = item.next();
                    while ( nextItem !== null && _getLevel( nextItem ) > _getLevel( item ) + 1 ) {
                        cms.sortableList.decreaseLevel( nextItem, false );
                        nextItem = nextItem.next();
                    }
                }
            }
            
            _serializeVisibleItems();
            _updateAllSortIcons();
        },
        
        /**
         * Method which
         * 
         * @method increaseLevel
         * @param {String} element
         * @param {String} applyToNext
         */
        increaseLevel: function( element, applyToNext ) {
            if ( _debug ) {
                console.log( 'cmsJS.sortableList.increaseLevel: element - ', element );
                console.log( 'cmsJS.sortableList.increaseLevel: applyToNext - ', applyToNext );
            }
            var item = _getJQueryItem( element );
            var prevItem = item.prev();
            
            if ( _getLevel( item ) <= _getLevel( prevItem ) ) {
                _changePos( item, 1 );
                if ( applyToNext ) {
                    var nextItem = item.next();
                    while ( nextItem !== null && _getLevel( nextItem ) >= _getLevel( item ) ) {
                        cms.sortableList.increaseLevel( nextItem, false );
                        nextItem = nextItem.next();
                    }
                }
            }
            
            _serializeVisibleItems();
            _updateAllSortIcons();
        },
        
        save: function( ajaxData ) {
            if ( typeof ajaxData === "undefined" || ajaxData.status === "begin" ) {
                _serializeVisibleItems();
            }
        }
    };
    
    /**
     * (Privat) Method which
     * 
     * @method _handleBeforeDropFromAvailable
     * @param {String} event
     * @param {String} ui
     */
    function _handleBeforeDropFromAvailable( event, ui ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _handleBeforeDropFromAvailable: event - ', event );
            console.log( 'cmsJS.sortableList _handleBeforeDropFromAvailable: ui - ', ui );
        }
        
        var $item = $( ui.item );

        var $radioMenues = $item.find("table");
        $radioMenues.each(function(index, element) {
        	var $checkboxes = $(element).find("input");
        	if($checkboxes.length > 0) {
        		var anychecked = false;
        		$checkboxes.each(function(index, element) {
        			if($(element).prop('checked')) {
        				anychecked = true;
        				return false;
        			}
        		})
        		if(!anychecked) {
        			$checkboxes.first().prop('checked', true);
        		}
        	}
        })
        if ( _allowMultipleOccurances && $item.parent().attr( "id" ) === "visibleItemList" ) {
            $item.clone().appendTo( $( _config.sortablesConfig.availableItemList ) );
        }
        
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _handleBeforeDropFromAvailable
     * @param {String} event
     * @param {String} ui
     */
    function _handleBeforeDropFromVisible( event, ui ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _handleBeforeDropFromVisible: event - ', event );
            console.log( 'cmsJS.sortableList _handleBeforeDropFromVisible: ui - ', ui );
        }
        
        var item = $( ui.item );
        if ( _allowMultipleOccurances && item.parent().attr( "id" ) === $( _config.sortablesConfig.availableItemList ).attr( "id" ) ) {
            ui.item.remove();
        }
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _handleDrop
     */
    function _handleDrop() {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _handleDrop' );
        }
        _updateAllSortIcons();
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _updateAllSortIcons
     */
    function _updateAllSortIcons() {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _updateAllSortIcons' );
        }
        
        var childrenVL = $( _config.sortablesConfig.visibleItemList ).children( "li" );
        childrenVL.each( function() {
            if ( $( this ).attr( _sortingAttribute ) != null ) {
                _updateSortIcons( $( this ) );
            }
        } );
        
        var childrenAL = $( _config.sortablesConfig.availableItemList ).children( "li" );
        childrenAL.each( function() {
            if ( $( this ).attr( _sortingAttribute ) != null ) {
                _updateSortIcons( $( this ) );
            }
        } );
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _updateSortIcons
     * @param {Object} item
     */
    function _updateSortIcons( item ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _updateSortIcons: item - ', item );
        }
        
        var parent = item.parent();
        
        if ( parent.attr( "id" ) === $(_config.sortablesConfig.visibleItemList).attr( "id" ) ) {
            item.children( '.menu-item__level' ).show();
            if ( _getLevel( item.prev() ) === -1 ) {
                while ( _getLevel( item ) > 0 ) {
                    cms.sortableList.decreaseLevel( item );
                }
            }
            
            if ( _getLevel( item ) === 0 ) {
                item.find( '.left' ).css( "visibility", "hidden" );
//                item.find( '.right' ).css( "visibility", "hidden" );
                item.css( "margin-left", "0px" );
            }
            else {
                item.find( '.left' ).css( "visibility", "visible" );
//                item.find( '.right' ).css( "visibility", "visible" );
                item.css( "margin-left", _getLevel( item ) * _levelIndent + "px" );
            }
            
            if ( _getLevel( item ) > _getLevel( item.prev() )) {
//                item.find( '.left' ).css( "visibility", "visible" );
                item.find( '.right' ).css( "visibility", "hidden" );
            }
            else {
//                item.find( '.left' ).css( "visibility", "visible" );
                item.find( '.right' ).css( "visibility", "visible" );
            }
        }
        else {
            item.children( '.menu-item__level' ).hide();
        }
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _getJQueryItem
     * @param {Object} element
     */
    function _getJQueryItem( element ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _getJQueryItem: element - ', element );
        }
        
        var item = $( element );
        
        while ( item !== null && item.attr( _sortingAttribute ) === undefined ) {
            item = item.parent();
        }
        
        return item;
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _getLevel
     * @param {Object} item
     */
    function _getLevel( item ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _getLevel: item - ', item );
        }
        
        var pos = item.attr( _sortingAttribute );
        
        if ( pos === null || pos === undefined ) {
            return -1;
        }
        
        var curLevel = pos.substr( pos.indexOf( '?' ) + 1 );
        var level = parseInt( curLevel );
        
        return level;
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _changePos
     * @param {Object} item
     * @param {String} diff
     */
    function _changePos( item, diff ) {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _changePos: item - ', item );
            console.log( 'cmsJS.sortableList _changePos: diff - ', diff );
        }
        
        var pos = item.attr( _sortingAttribute );
        
        if ( pos === null || pos === undefined ) {
            return -1;
        }
        
        var curLevel = pos.substr( pos.indexOf( '?' ) + 1 );
        var curItem = pos.substr( pos.indexOf( '_' ) + 1 );
        var curItemInt = parseInt( curItem );
        var level = parseInt( curLevel ) + diff;
        item.attr( _sortingAttribute, "item_" + curItemInt + '?' + level );
        
        return level;
    }
    
    /**
     * (Privat) Method which
     * 
     * @method _serializeVisibleItems
     */
    function _serializeVisibleItems() {
        if ( _debug ) {
            console.log( 'cmsJS.sortableList _serializeVisibleItems' );
        }
        
        var postData = $( _config.sortablesConfig.visibleItemList ).sortable( "serialize", {
            key: "item",
            attribute: _sortingAttribute
        } );
        
        if ( _inputField !== null ) {
            _inputField.value = postData;
            // postData = $("#itemOrderInput").val();
        }
    }
    
    /**
     * Method which sets menu save button to position fixed on scroll.
     * 
     * @method _fixMenuSave
     * */
    function _fixMenuSave() {
    	if ( _debug ) {
            console.log( 'cmsJS.sortableList _fixMenuSave' );
        }
    	
    	var menuSaveOffsetTop = $( '.cms-menu__save' ).offset().top;
    	var menuEditorWidth = $( '.cms-menu__editor' ).width();
    	var menuEditorOffsetRight = $( '.cms-menu__editor' ).offset().left + menuEditorWidth;
    	var menuSavePositionRight = $( window ).width() - menuEditorOffsetRight;
    	
    	$( window ).on( 'scroll', function() {
    		if ( ( window.pageYOffset + 15 ) > menuSaveOffsetTop ) {
    			$( '.cms-menu__save' ).addClass( 'fixed' ).css( 'right', menuSavePositionRight + 'px' );
    		}
    		else {
    			$( '.cms-menu__save' ).removeClass( 'fixed' );
    		}
    	} );
    }
    
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    // variables
    var _debug = false;
    var _data = null;
    var _defaults = {
        gridSelector: '.tpl-static-grid__grid'
    };
    
    // DOM elements
    var _grid = null;
    var _gridRow = null;
    var _gridCol = null;
    var _gridTile = null;
    var _gridTileTitle = null;
    var _gridTileTitleLink = null;
    var _gridTileTitleH4 = null;
    var _gridTileImage = null;
    var _gridTileImageLink = null;
    
    cms.staticGrid = {
        /**
         * Method which initializes the Masonry Grid.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.gridSelector The selector for the grid container.
         * @param {Object} data An data object which contains the images sources for the
         * grid.
         */
        init: function( config, data ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.staticGrid.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.staticGrid.init: config - ', config );
                console.log( 'cmsJS.staticGrid.init: data - ', data );
            }
            
            $.extend( true, _defaults, config );
            
            // render grid
            _grid = _buildGrid( data );
            $( _defaults.gridSelector ).append( _grid );
        }
    };
    
    /**
     * Method to build the elements of the static grid.
     * 
     * @method _buildGrid
     * @param {Object} data A JSON data object which contains the image informations.
     * @returns {Object} An jQuery object which contains all grid elements.
     */
    function _buildGrid( data ) {
        if ( _debug ) {
            console.log( '---------- _buildGrid() ----------' );
            console.log( '_buildGrid: data = ', data );
        }
        
        _gridRow = $( '<div class="row" />' );
        
        data.mediaItems.forEach( function( item ) {
            _gridCol = $( '<div class="col-6 col-sm-3" />' );
            // tile
            _gridTile = $( '<div class="grid-tile" />' );
            // title
            _gridTileTitle = $( '<div class="grid-tile__title" />' );
            _gridTileTitleH4 = $( '<h3 />' );
            _gridTileTitleLink = $( '<a />' );
            if ( item.url !== '' ) {
                _gridTileTitleLink.attr( 'href', item.link );
            }
            else {
                _gridTileTitleLink.attr( 'href', '#' );
            }
            
            let label = viewerJS.getMetadataValue(item.label, _defaults.language );
            _gridTileTitleLink.attr( 'title', label);
            _gridTileTitleLink.append( label );
            _gridTileTitleH4.append( _gridTileTitleLink );
            
            // image
            let image = item.image["@id"];
            _gridTileImage = $( '<div class="grid-tile__image" />' );
            _gridTileImage.css( 'background-image', 'url(' + image + ')' );
            _gridTileImageLink = $( '<a />' );
            if ( item.url !== '' ) {
                _gridTileImageLink.attr( 'href', item.link );
            }
            else {
                _gridTileImageLink.attr( 'href', '#' );
            }
            // concat everything
            _gridTileTitle.append( _gridTileTitleH4 );
            _gridTile.append( _gridTileTitle );
            _gridTileImage.append( _gridTileImageLink );
            _gridTile.append( _gridTileTitle );
            _gridTile.append( _gridTileImage );
            _gridCol.append( _gridTile );
            _gridRow.append( _gridCol );
        } );
        
        return _gridRow;
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var cmsJS = ( function( cms ) {
    'use strict';
    
    var _debug = false;
    var _defaults = {
        inputFieldId: 'tagInput',
        tagListId: 'tagList',
        autoSuggestUrl: '',
        msg: {
            addTagLabel: 'Tag hinzufügen'
        }
    };
    
    cms.tagList = {
        tags: [],
        $tagListElement: null,
        autoSuggestUrl: null,
        /**
         * Method which initializes the tag list.
         * 
         * @method init
         * @param {Object} config An config object which overwrites the defaults.
         * @param {String} config.inputFieldId The Selector for the tag input field.
         * @param {String} config.tagList The Selector for the tag list.
         * @param {String} config.autoSuggestUrl The URL for the tag auto suggest.
         * @param {Object} config.msg An object with message keys.
         */
        init: function( config ) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'cmsJS.tagList.init' );
                console.log( '##############################' );
                console.log( 'cmsJS.tagList.init: config - ', config );
            }
            
            $.extend( true, _defaults, config );
            
            this.$inputField = $( '#' + _defaults.inputFieldId );
            
            if ( this.$inputField.length === 0 ) {
                console.log( 'Data input field not found' );
            }
            
            this.$tagListElement = $( '#' + _defaults.tagListId );
            
            if ( this.$tagListElement.length === 0 ) {
                throw 'Tag list element not found';
            }
            
            this.autoSuggestUrl = _defaults.autoSuggestUrl;
            this.tags = _readTags( this.$inputField );
            _renderList( this.tags, this.$tagListElement );
            
        },
        /**
         * Method which adds a tag to the list.
         * 
         * @method addTag
         * @param {String} tagName The current tag name.
         */
        addTag: function( tagName ) {
            if ( _debug ) {
                console.log( '---------- cms.tagList.addTag() ----------' );
                console.log( 'cmsJS.tagList.addTag: tagName = ', tagName );
            }
            
            var containedTag = this.getTag( tagName );
            if ( containedTag ) {
                var duration = 200;
                $( containedTag ).fadeOut( duration / 2, function() {
                    $( containedTag ).fadeIn( duration / 2 );
                } );
            }
            else {
                if ( this.$tagListElement ) {
                    _createListElement( tagName, this.$tagListElement );
                }
                this.saveTags();
            }
        },
        /**
         * Method which deletes a tag from the list.
         * 
         * @method deleteTag
         * @param {Object} tag The current tag to delete.
         */
        deleteTag: function( tag ) {
            if ( _debug ) {
                console.log( '---------- cms.tagList.deleteTag() ----------' );
                console.log( 'cmsJS.tagList.deleteTag: tag = ', tag );
            }
            
            tag.remove();
            this.saveTags();
        },
        /**
         * Method to save the tag list.
         * 
         * @method saveTags
         */
        saveTags: function() {
            if ( _debug ) {
                console.log( '---------- cms.tagList.saveTags() ----------' );
            }
            
            _writeTags( cms.tagList.$tagListElement.children( '[id$=_item]' ), cms.tagList.$inputField );
        },
        /**
         * Method to ...
         * 
         * @method contains
         */
        contains: function( tagName ) {
            if ( _debug ) {
                console.log( '---------- cms.tagList.contains() ----------' );
                console.log( 'cmsJS.tagList.contains: tagName = ', tagName );
            }
            
            var found = false;
            var $tags = cms.tagList.$tagListElement.children( '[id$=_item]' );
            
            $tags.each( function() {
                var text = $( this ).text();
                if ( tagName.trim().toUpperCase() === text.trim().toUpperCase() ) {
                    found = true;
                    
                    return false;
                }
            } );
            
            return found;
        },
        /**
         * Method to ...
         * 
         * @method close
         */
        close: function() {
            if ( _debug ) {
                console.log( '---------- cms.tagList.close() ----------' );
            }
            
            this.$inputField.off();
            this.$tagListElement.off();
            this.$tagListElement.find( '.tag-terminator' ).off();
            this.$tagListElement.find( 'input' ).off();
        },
        /**
         * Method to get all tags.
         * 
         * @method getTags
         */
        getTags: function() {
            if ( _debug ) {
                console.log( '---------- cms.tagList.getTags() ----------' );
            }
            
            return cms.tagList.$tagListElement.children( '[id$=_item]' );
        },
        /**
         * Method to get all tag values.
         * 
         * @method getTagValues
         */
        getTagValues: function() {
            if ( _debug ) {
                console.log( '---------- cms.tagList.getTagValues() ----------' );
            }
            
            var values = cmsJS.tagList.getTags().map( function( index, tag ) {
                return $( tag ).text();
            } );
            
            return values;
        },
        /**
         * Method to get a single tag.
         * 
         * @method getTag
         */
        getTag: function( value ) {
            if ( _debug ) {
                console.log( '---------- cms.tagList.getTag() ----------' );
                console.log( 'cmsJS.tagList.getTag: value = ', value );
            }
            
            var selectedTag = undefined;
            
            cmsJS.tagList.getTags().each( function( index, tag ) {
                if ( cmsJS.tagList.getValue( tag ).trim().toUpperCase() === value.trim().toUpperCase() ) {
                    selectedTag = tag;
                    
                    return false;
                }
            } );
            
            return selectedTag;
        },
        /**
         * Method to get a single Value.
         * 
         * @method getValue
         */
        getValue: function( tag ) {
            if ( _debug ) {
                console.log( '---------- cms.tagList.getValue() ----------' );
                console.log( 'cmsJS.tagList.getValue: tag = ', tag );
            }
            
            return $( tag ).text();
        }
    };
    
    /**
     * Method to ...
     * 
     * @method _readTags
     * @param {Object} $input ...
     */
    function _readTags( $input ) {
        if ( _debug ) {
            console.log( '---------- _readTags() ----------' );
            console.log( '_readTags: $input = ', $input );
        }
        
        var tagString = $input.val();
        
        if ( !tagString ) {
            tagString = '[]';
        }
        
        if ( tagString.length > 0 ) {
            if ( _debug ) {
                console.log( '---------- _readTags() ----------' );
                console.log( 'tagString: ', tagString );
            }
            
            try {
                var tagList = JSON.parse( tagString );
                return tagList;
            }
            catch ( error ) {
                console.log( 'Error reading tags from ' + tagString );
                
                return [];
            }
        }
        else {
            return [];
        }
    }
    
    /**
     * Method to ...
     * 
     * @method _writeTags
     * @param {Object} $tags ...
     * @param {Object} $input ...
     */
    function _writeTags( $tags, $input ) {
        if ( _debug ) {
            console.log( '---------- _writeTags() ----------' );
            console.log( '_writeTags: $tags = ', $tags );
            console.log( '_writeTags: $input = ', $input );
        }
        
        var tags = [];
        
        $tags.each( function() {
            if ( $( this ).text().length > 0 ) {
                tags.push( $( this ).text() );
            }
        } )

        var tagString = JSON.stringify( tags );
        
        $input.val( tagString );
    }
    
    /**
     * Method to ...
     * 
     * @method _renderList
     * @param {Array} tags ...
     * @param {Object} $ul ...
     */
    function _renderList( tags, $ul ) {
        if ( _debug ) {
            console.log( '---------- _renderList() ----------' );
            console.log( '_renderList: tags = ', tags );
            console.log( '_renderList: $ul = ', $ul );
        }
        
        var count = 0;
        var ulId = $ul.attr( 'id' );
        for ( var index = 0; index < tags.length; index++ ) {
            var tag = tags[ index ];
            _createListElement( tag, $ul, count );
            count++;
        }
        
        _createTagInputElement( $ul.parent() );
    }
    
    /**
     * Method to ...
     * 
     * @method _createListElement
     * @param {String} value ...
     * @param {Object} $parent ...
     * @param {Number} count
     */
    function _createListElement( value, $parent, count ) {
        if ( _debug ) {
            console.log( '---------- _createListElement() ----------' );
            console.log( '_createListElement: value = ', value );
            console.log( '_createListElement: $parent = ', $parent );
            console.log( '_createListElement: count = ', count );
        }
        
        if ( !count ) {
            count = $parent.children( '[id$=_item]' ).length;
        }
        
        var ulId = $parent.attr( 'id' );
        var $tagInput = $( '.tag-input' );
        var $li = $( '<li/>' );
        $li.attr( 'id', ulId + '_' + count + '_item' );
        var $liText = $( '<span class="tag label"/>' );
        $liText.text( value );
        var $terminator = $( '<span />' );
        $terminator.addClass( 'tag-terminator' );
        $terminator.on( 'click', _handleClickTerminator );
        $li.append( $liText );
        $liText.append( $terminator );
        
        if ( $tagInput.length > 0 ) {
            $li.insertBefore( $tagInput );
        }
        else {
            $parent.append( $li );
        }
    }
    
    /**
     * Method to ...
     * 
     * @method _createTagInputElement
     * @param {Object} $parent ...
     */
    function _createTagInputElement( $parent ) {
        if ( _debug ) {
            console.log( '---------- _createTagInputElement() ----------' );
            console.log( '_createTagInputElement: $parent = ', $parent );
        }
        
        var $container = $( '.media-modal__tags' );
        var sizeCount = 1;
        var ulId = $parent.attr( 'id' );
        var $inputListElement = $( '<li />' );
        $inputListElement.addClass( 'tag-input' );
        var $input = $( '<input type="text" />' );
        $input.attr( 'id', ulId + '_inputField' );
        $input.attr( 'size', sizeCount );
        $inputListElement.append( $input );
        $parent.find( 'ul' ).append( $inputListElement );
        
        // handler
        $container.on( 'click', function() {
            $input.focus();
        } );
        $input.on( 'change', _handleInputChange );
        $input.on( 'keypress', function( event ) {
            // change size of input
            sizeCount++;
            $input.attr( 'size', sizeCount );
            
            // press enter
            if ( event.keyCode == 13 ) {
                sizeCount = 1;
                $input.attr( 'size', sizeCount );
                
                return _handleInputChange( event );
            }
        } );
        
        // autocomplete
        $input.autocomplete( {
            source: function( request, response ) {
                $.ajax( {
                    url: cms.tagList.autoSuggestUrl + request.term + '/',
                    type: 'GET',
                    datatype: 'json',
                } ).then( function( data ) {
                    response( data );
                } )
            },
            appendTo: $input.parent(),
            select: function( event, ui ) {
                _handleInputChange( event, ui.item.value );
            }
        } );
    }
    
    /**
     * Method to ...
     * 
     * @method _handleInputChange
     * @param {Object} event ...
     * @param {String} text ...
     */
    function _handleInputChange( event, text ) {
        if ( _debug ) {
            console.log( '---------- _handleInputChange() ----------' );
            console.log( '_handleInputChange: event = ', event );
            console.log( '_handleInputChange: text = ', text );
            console.log( 'on change occured in: ', event.target );
        }
        if ( !text || text.length === 0 ) {
            text = $( event.target ).val();
        }
        if ( text.trim().length > 0 ) {
            cms.tagList.addTag( text );
            $( event.target ).val( '' );
        }
        event.preventDefault();
        event.stopPropagation();
        
        return false;
    }
    
    /**
     * Method to ...
     * 
     * @method _handleClickTerminator
     * @param {Object} event ...
     */
    function _handleClickTerminator( event ) {
        if ( _debug ) {
            console.log( '---------- _handleClickTerminator() ----------' );
            console.log( '_handleClickTerminator: event = ', event );
            console.log( 'Click on: ', event.currentTarget );
        }
        
        var $li = $( event.target ).parent().parent();
        cms.tagList.deleteTag( $li );
    }
    
    return cms;
    
} )( cmsJS || {}, jQuery );

var adminJS = ( function() {
    'use strict';
    
    var _debug = false; 
    var admin = {};
    
    /**
     * @description Method which initializes the admin module. 
     * @method init
     */
    admin.init = function() {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'adminJS.init' );
            console.log( '##############################' );
        }
        // Initialize sticky elements for admin pages
        viewerJS.stickyElements.init({initAdmin:true});

		// Initialize copy to clipboard scripts for admin pages
		viewerJS.clipboard.init();
    };

    return admin;
    
} )( jQuery );


$( document ).ready(function() {

	// toggle help text for admin forms
	$("body").on("click", '[data-toggle="helptext"]', function() {
		$(this).closest('.form-group').children('.admin__form-input, .admin__license-functions-help').find('.admin__form-help-text').toggleClass('in');
		$(this).parents().siblings('.admin__form-help-text').toggleClass('in');
		$('.-refreshHCsticky').hcSticky('refresh', {});
	});

// hide license functions if open access toggle is yes
	// check if toggle yes on page load
	if ($('.openAccessToggle input:nth-of-type(2)').prop('checked')) {
			  $('.admin__license-functions').hide();
		  }
	// check if toggle status changes
	$(".openAccessToggle input").change(function(){
	  if ($('.openAccessToggle input:nth-of-type(2)').is(':checked'))
	   $('.admin__license-functions').animate({
		    height: "toggle",
		    opacity: "toggle"
		}, 250);
	  else if ($('.openAccessToggle input:nth-of-type(1)').is(':checked'))
	   $('.admin__license-functions').animate({
		    height: "toggle",
		    opacity: "toggle"
		}, 250);
	});

// toggle next cms right block after radio button
		// check if toggle yes on page load

	// $("body").on("click", '[data-toggle="helptext"]', function()
			
	$('.blockAfterRadioToggler').each(function() {
		if ($(this).find("input:nth-of-type(2)").prop('checked')) {
			$(this).next('.admin__license-selectable-block').hide();
		}
	});
 
	// check if radio button status changes
	$("body").one("click", '.blockAfterRadioToggler', function(event) { 
		$('.blockAfterRadioToggler input').change(function() {
			if ($(this).parent('.admin__radio-switch').find('input:nth-of-type(1)').is(':checked')) {
				$(this).closest('.blockAfterRadioToggler').next('.admin__license-selectable-block').animate({
			    opacity: "toggle"
				}, 250);
			}
			else if ($(this).parent('.admin__radio-switch').find('input:nth-of-type(2)').is(':checked')) {
				$(this).closest('.blockAfterRadioToggler').next('.admin__license-selectable-block').animate({
			    opacity: "toggle"
				}, 250);
			}
		});
	});

	// pdf quota radio switch - change color of box according to state
	$('#pdf_download_quota_info_box').each(function() {
		if ($(this).find("input:nth-of-type(1)").prop('checked')) {
			$(this).children('.admin__default-block').addClass('-gray-box');
		}
	}); 
	$("body").on("click", '#pdf_download_quota_info_box', function() {
		if ($('#pdf_download_quota_info_box').find("input:nth-of-type(1)").prop('checked')) {
			$('#pdf_download_quota_info_box').children('.admin__default-block').addClass('-gray-box');
		}
		else {
			$('#pdf_download_quota_info_box').children('.admin__default-block').removeClass('-gray-box');
		}
	});	

	// vertical language tabs focus effect
	$("body").on("focus", ".admin__language-tabs-vertical-textarea", function() {
		$(this).siblings('.admin__language-tabs-vertical').find('.admin__language-tab-vertical.active a').css({"border-color": "#3365a9", "border-right-color": "#fff"})
	});

	$("body").on("focusout", ".admin__language-tabs-vertical-textarea", function() {
		$(this).siblings('.admin__language-tabs-vertical').find('.admin__language-tab-vertical.active a').css({"border-color": "#ccc", "border-right-color": "#fff"})
	});
	
	// hiding the new tab option for cms menus if link value is '#'
	$('.cms-module__option-url').each(function() {
		if ($(this).val() == "#") {
			$(this).parent().parent().next(".cms-module__option-group").hide();
		}
	});
	// check if form input value changes
	$('.cms-module__option-url').each(function() {
		$(this).on('keyup change ready', function() {
			if ($(this).val() == "#") {
				$(this).parent().parent().next(".cms-module__option-group").fadeOut();
			}
			else {
				$(this).parent().parent().next(".cms-module__option-group").fadeIn();
			}
		});
	});

// END DOCUMENT READY
});



adminJS.codemirror = function(element, mode, readonly, config) {

	const baseConfig = {
		lineNumbers: true,
		mode: mode,
		theme: "default",
		autofocus: false,
		indentUnit: 2,
		tabSize: 2,
		styleActiveLine: true,
		indentWithTabs: true,
		extraKeys: {
			"F11": function(cm) {
				cm.setOption("fullScreen", !cm.getOption("fullScreen"));
			},
			"Esc": function(cm) {
				if (cm.getOption("fullScreen")) {
					cm.setOption("fullScreen", false);
				}
			},
			"Ctrl-D": function(cm) {
				cm.setOption("theme", cm.getOption("theme") == "default" ? "dracula" : "default");
			},
			"Ctrl-S": (cm) => {
				// if ( _debug ) {
				console.log('manually saved with key combo');
				// }
				if (!readonly) {
					document.querySelector('[data-cm="save"]').click();
				}
			},
			"Ctrl-E": "findPersistent",
		}
	}

	const cmConfig = $.extend(true, {}, baseConfig, config ? config : {});

	const cm = CodeMirror.fromTextArea(element, cmConfig);
	
	return {
		element: element,
		mode: cmConfig.mode,
		codemirror: cm
	}

}
var adminJS = ( function( admin ) {
    'use strict';
    
    const _debug = false;
    const _default = {
    	currentFileIsReadable: false,
    	currentFileIsWritable: false,
    	currentFilePath: undefined,
    }

    admin.configEditor = {
    	cmEditor: undefined,
    	dirty: false,
        /**
         * @description Method which initializes the codemirror editor in the backend.
         * @method init
         */
        init: function(config) {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'adminJS.configEditor.init' );
                console.log( '##############################' );
            }
            
            this.config = $.extend(true, {}, _default, config);
            if(_debug) {console.log("configEditor config", this.config)};

			this.initTextArea();
			this.initOnBeforeUnload();
			this.initWebsocket();
			this.initTooltipHelpers();
        },
        initWebsocket: function() {
        	this.socket = new viewerJS.WebSocket(window.location.host, window.currentPath, viewerJS.WebSocket.PATH_CONFIG_EDITOR_SOCKET);
			this.socket.onOpen.subscribe(() => {
				let messageObject = {
					fileToLock: this.config.currentFilePath
				}
				let message = JSON.stringify(messageObject);
				if(_debug)console.log("sending message", message);
				this.socket.sendMessage(message);
			});
        },
        initOnBeforeUnload: function() {
	        window.addEventListener('beforeunload',(event) => {
	        	if(this.dirty) {
	        		event.returnValue = false;
	        	} 
	        });
        },
        isReadOnly: function() {
        	return this.config.currentFileIsReadable && !this.config.currentFileIsWritable;

        },
		initTooltipHelpers: function () {
			var _this = this;
			$(document).ready( () => {
				  $('.-isNotReadable').tooltip({title: _this.config.fileNotReadableMsgKey, placement: "top"});
			});
			
			$( ".admin__config-editor-backup-single-entry" ).hover(
					  function() {
					    $(this).find('.admin__config-editor-backup-single-entry-icon .fa-download').tooltip('show');
					  }, function() {
					    $(this).find('.admin__config-editor-backup-single-entry-icon .fa-download').tooltip('hide');
					  }
			);
		},
        initTextArea: function() {
				var activeLineToggler;
				var type;
				var theme;
				
				// GET THE CURRENT FILE TYPE OF CHOSEN FILE
				let fileTypeElement = document.getElementById("currentConfigFileType");
				if ( _debug ) {
					console.info("Loaded file type = " + fileTypeElement.innerHTML.trim());
				}
				if (fileTypeElement !== null){
					type = fileTypeElement.innerHTML.trim(); // "properties" or "xml"
				} else {
					type = "xml";
				}
				if (typeof type == "undefined") {
					type = "xml";
				}
				if (typeof theme == "undefined") {
					theme = "default";
				}
				if ( _debug ) {
					console.log("type changed to = " + type);
				}
				// TARGETED TEXTAREA WITH CODE CONTENT
				var targetTextArea = document.getElementById('editor-form:editor');
				
				if (fileTypeElement.innerHTML.trim() == ''){
					activeLineToggler = false;
				} else {
					activeLineToggler = true;
				}
			
				// INIT EDITOR MAIN
				this.cmEditor = adminJS.codemirror(targetTextArea, type, this.isReadOnly(), {
					theme: theme,
					styleActiveLine: activeLineToggler,
				}).codemirror;
				
				// check if readOnly mode for current file should be active
				if (this.isReadOnly() == true) {
					this.cmEditor.setOption("readOnly", true);
				}
				
				if ( _debug ) {
					console.log("CodeMirror Editor constructed!");
				}
			
				// CLEAR EDITOR AND SHOW AN OVERLAY IF NO FILE SELECT
				if (fileTypeElement.innerHTML.trim() == '') {
					this.cmEditor.setValue("");
					this.cmEditor.clearHistory();
					$('[data-cm="overlay"]').show();
				}
				else {
					this.cmEditor.focus();
					$('[data-cm="overlay"]').hide();
				}
				// listen for CodeMirror changes
				var startEditorValue = this.cmEditor.getValue();
				var debounce = null;
				
				this.cmEditor.on('change', () => {
					// debounce for good performance
				   	clearTimeout(debounce);
					   debounce = setTimeout(() => {
						var newEditorValue = this.cmEditor.getValue();                  
						if ((this.cmEditor.doc.changeGeneration() == 1) || (startEditorValue == newEditorValue)) {
							if ( _debug ) {
								console.log('editor is clean');
							}
							this.dirty = false;
							 this.hideOverlayBar();
						} else {
							if ( _debug ) {
							console.log('editor not clean');
							}
							this.dirty = true;
							this.showOverlayBar();
						}
						if ( _debug ) {
							console.log('debounced');
						}
				   }, 350);               
				}); 
			
				// SAVE BUTTON FUNCTIONAL
					$('[data-cm="save"]').on('click', () => {
						this.cmEditor.save();
						this.dirty = false;
						if ( _debug ) {
							console.log('editor is saved by clicked button');
						}
					});
					
				// CANCEL BUTTON FUNCTION
				// RESETS ALL EDITS
				$('[data-cm="cancel"]').on('click', () => {
					var startContent = this.cmEditor.getTextArea().value;
					this.cmEditor.setValue(startContent);
					this.cmEditor.clearHistory();
				});
			
			},
		showOverlayBar: function(fixed) {
			$('.admin__overlay-bar').addClass('-slideIn');
			if(fixed) {
				$('.admin__overlay-bar').addClass('-fixed');
			}
		},
		hideOverlayBar: function() {
			if(!$('.admin__overlay-bar').hasClass("-fixed")) {
				$('.admin__overlay-bar').removeClass('-slideIn');
				$('.admin__overlay-bar').addClass('-slideOut');
				$('.admin__overlay-bar').on('animationend webkitAnimationEnd', function() { 
					$('.admin__overlay-bar').removeClass('-slideOut');
				});
			}
		},
		loadBackup: function(data) {
			console.log("load backup ", data.status);
			if(data.status === "success") {
				$(document).ready(() => {						
					setTimeout(adminJS.configEditor.showOverlayBar(true));
				})
			}
		}
	}
	
	return admin;
    
} )( adminJS || {}, jQuery );
var adminJS = ( function( admin ) {
    'use strict';
    
    var _debug = false;

    admin.licenceToggle = {
        /**
         * @description Method which creates a smooth js toggle for access rights settings.
         * @method init
         */
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'adminJS.licenceToggle.init' );
                console.log( '##############################' );
            }

		function elementLicenceTogglerFunction() {
		
			// WATCH CHANGES
			
			var $watchedElements = $("[data-watched-element]");
			
			$("body").one("click", $($watchedElements), function(event) {
				$($watchedElements).find('input').change(function() {
					
					// console.log($(this));
					
					let clickedWatchedElement = $(this).closest($watchedElements);
					// console.log(clickedWatchedElement);
					let id = $(this).closest($watchedElements).attr("data-watched-element");
					let keepFunctionsVisible = $('[data-target-visibility="keepVisible"]');
					let redirectInputField = $('[data-target-redirect="input"]')
					
					var watchedElementsInputsNo = $($watchedElements).find('.admin__radio-switch input:nth-of-type(1)');
					var watchedElementInputThis = $(clickedWatchedElement).find('.admin__radio-switch input:nth-of-type(1)');
					
					var clickedWatchedElementYes = '';
					if ($(clickedWatchedElement).find('input:nth-of-type(2)').is(':checked')) {
						var clickedWatchedElementYes = true;
						// console.log('toggle on yes');
					} else {
						var clickedWatchedElementYes = false;
						// console.log('toggle on no');
					}
		
		            switch (true) {
		                case (id == 'exclusiveAndInput'):
							// IF CHECKBOX YES
							if (clickedWatchedElementYes == true) {
								// console.log('exlusiveandinput is true')
								$($watchedElements).not(clickedWatchedElement).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								// $(watchedElementsInputsNo).not(watchedElementInputThis).prop('checked', true);
							}
							// IF CHECKBOX NO
							if (clickedWatchedElementYes == false) {
								// console.log('exlusiveandinput is false');
								$($watchedElements).not(clickedWatchedElement).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
							}
		                    break;
		                case (id == 'keepFunctions'):
							// IF CHECKBOX YES
							if (clickedWatchedElementYes == true) {
								// console.log('keepfunctions is true');
								$($watchedElements).not(clickedWatchedElement, keepFunctionsVisible).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(watchedElementsInputsNo).not(watchedElementInputThis).prop('checked', true);
							}
							// IF CHECKBOX NO
							if (clickedWatchedElementYes == false) {
								// console.log('keepfunctions is false');
								$($watchedElements).not(clickedWatchedElement).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
							}
		                    break;
		                case (id == 'exclusive'):
							if (clickedWatchedElementYes == true) {
							// IF CHECKBOX YES
								// console.log('exlusive is true');
								$($watchedElements).not(clickedWatchedElement).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
								$(watchedElementsInputsNo).not(watchedElementInputThis).prop('checked', true);
							}
							if (clickedWatchedElementYes == false) {
								// console.log('exlusive is false');
								$($watchedElements).not(clickedWatchedElement).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(keepFunctionsVisible).animate({
		                        	height: "show",
		                            opacity: 1
		                            }, 250);
								$(redirectInputField).animate({
		                        	height: "hide",
		                            opacity: 0
		                            }, 250);
							}
		                    break;
		                default:
		                    // console.log('default');
		            }
		
					});
				
					});
				}
				elementLicenceTogglerFunction();


        }
	}
	
	return admin;
    
} )( adminJS || {}, jQuery );
var adminJS = ( function( admin ) {
    'use strict';
    
    var _debug = false;

    admin.translationsEdit = {
        /**
         * @description Method which initializes the admin sidebar module.
         * @method init
         */
        init: function() {
            if ( _debug ) {
                console.log( '##############################' );
                console.log( 'adminJS.translationsEdit.init' );
                console.log( '##############################' );
            }
            
            viewerJS.jsfAjax.success.subscribe(function() {
            	
    			/* check if translations area contains zzz on ajax load */
        		$('.admin__translations-textarea').keyup(function() {
            		$('.admin__translations-textarea').each(function(i, obj) {
            		    if ($(this).val().indexOf('zzz') > -1 || (!$(this).val())) {
            		        $(this).parent().addClass('admin__form-input-highlight');
            		        $(this).parent().siblings('.admin__form-label').addClass('admin__form-label-highlight');
            		    }
            		    else {
            		        $(this).parent().removeClass('admin__form-input-highlight');
            		        $(this).parent().siblings('.admin__form-label').removeClass('admin__form-label-highlight');
            		    }
            		});
            		
        			/* check if global msg key identical on msg key up*/
    				var globalKey = $(this).parents('.admin__translations-fields').find('.admin__translations-global-key').text();

	    			if ((globalKey) != ($(this).val()) && ((globalKey) != "")){
	    			  $(this).parents('.admin__translations-fields').find('.admin__translations-global-hint').fadeIn('fast');
	    			}
	    			else {
	    				$(this).parents('.admin__translations-fields').find('.admin__translations-global-hint').fadeOut('fast');
	    			}
            		
      			});
    			
                /* show global msg keys if it differs on ajax load */
        			$('.admin__translations-fields').each(function(i, obj) {
        				var globalKey = $(this).find('.admin__translations-global-key').text();
        			if(_debug)console.log(globalKey);
       			  	if (!(globalKey) == "" && (globalKey) != ($(this).find('.admin__translations-textarea').val())) {
       				    $(this).find('.admin__translations-global-hint').fadeIn('fast');
       				    if(_debug)console.log('erfolg');
       				  }
        			else {
        				$(this).find('.admin__translations-global-hint').fadeOut('fast');
        			}

        			}); 
                });
  
                /* show global msg keys if it differs on page load */
   			$('.admin__translations-fields').each(function(i, obj) {
   				var globalKey = $(this).find('.admin__translations-global-key').text();
   			if(_debug)console.log(globalKey);

       		  if ((globalKey) !== "" && (globalKey) != ($(this).find('.admin__translations-textarea').val())) {
       		    $(this).find('.admin__translations-global-hint').fadeIn('fast');
       		    if(_debug)console.log('erfolg');
       		  }
   			else {
   				$(this).find('.admin__translations-global-hint').fadeOut('fast');
   			}

   			}); 

			/* check on any key up */
    		$('.admin__translations-textarea').keyup(function() {
    			
    			/* check if global msg key identical on msg key up*/
				var globalKey = $(this).parents('.admin__translations-fields').find('.admin__translations-global-key').text();

    			if ((globalKey) != ($(this).val()) && ((globalKey) != "")){
    			  $(this).parents('.admin__translations-fields').find('.admin__translations-global-hint').fadeIn('fast');
    			}
    			else {
    				$(this).parents('.admin__translations-fields').find('.admin__translations-global-hint').fadeOut('fast');
    			}

    			/* check if translations area contains zzz on msg key up*/
        		$('.admin__translations-textarea').each(function(i, obj) {
        		    if ($(this).val().indexOf('zzz') > -1 || (!$(this).val())) {
        		        $(this).parent().addClass('admin__form-input-highlight');
        		        $(this).parent().siblings('.admin__form-label').addClass('admin__form-label-highlight');
        		    }
        		    else {
        		        $(this).parent().removeClass('admin__form-input-highlight');
        		        $(this).parent().siblings('.admin__form-label').removeClass('admin__form-label-highlight');
        		    }
        		});
  			});

    		$( document ).ready(function() {
    			
    			// SEARCH FUNCTION
    			/* check for input value and show clear button */
    	        if(!$('.admin__translations-search-input').val() == ''){
    				$('.admin__translations-search-clear').show();
    	        }
    			$('.admin__translations-search-clear').click(function(){
        				/* clear value on click*/
        		    $('.admin__translations-search-input').val("");
        		    $('.admin__translations-search-clear').hide();	
        			    /* trigger empty search on click */
        			    $('.admin__translations-search-button').click();
    			});
    			
    			if($('.admin__table-entry').length == 0) {
    				$('.admin__table-content').append('<br/><p >#{msg.hitsZero}</p>');
    			}

    			
    			$('.admin__translations-search-input').keyup(function() {
        	        if ($('.admin__translations-search-input').val() == ''){
        				$('.admin__translations-search-clear').hide();
            		}
        	        
    			});
    		});
    		
            viewerJS.jsfAjax.success.subscribe(function() {
            	// SEARCH FUNCTION AJAX
    			/* check for input value and show clear button */
    	        if(!$('.admin__translations-search-input').val() == ''){
    				$('.admin__translations-search-clear').show();
    	        }
    			$('.admin__translations-search-clear').click(function(){
        				/* clear value on click*/
        		    $('.admin__translations-search-input').val("");
        		    $('.admin__translations-search-clear').hide();	
        			    /* trigger empty search on click */
        			    $('.admin__translations-search-button').click();
    			});
    			
    			if($('.admin__table-entry').length == 0) {
    				$('.admin__table-content').append('<br/><p >#{msg.hitsZero}</p>');
    			}
            });
        }
	} 
	
	return admin;
    
} )( adminJS || {}, jQuery );
var Crowdsourcing = ( function() {
    'use strict';
    
    var _debug = false; 
    
    var crowdsourcing = {};
    
    crowdsourcing.language = "de";
    crowdsourcing.fallbackLanguage = "en";
    
    /**
     * Check if a variable is a string
     */
    crowdsourcing.isString = function(variable) {
        return typeof variable === 'string' || variable instanceof String
    }
    
    /**
     * @return a deep copy of the given object 
     */
    crowdsourcing.deepCopy = function(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    
    /**
     * @return the identifier url for any json+ld object. Returns the original object if it was a string
     */
    crowdsourcing.getResourceId = function(resource) {
        if(crowdsourcing.isString(resource)) {
            return resource;
        } else if(resource.source) {
            return resource.source;
        } else if(resource.id) {
            return resource.id;
        } else if(resource["@id"]) {
            return resource["@id"];
        } else {
            return JSON.stringify(resource);
        }
    }
    
    /**
     * Set the colors to use for drawing frames on the image. All questions use the same color palette.
     * This may either be a list of color codes or an object returning a color on calling its next() method
     */
    crowdsourcing.setFrameColors = function(colors) {
        this.frameColors = colors;
    }

    
    /**
     * Returns a translation for the given message key in the given language. 
     * If language is undefined, the language property of Crowdsourcing is used
     * if no translation was found, the key itself is returned
     * Requires the method Crowdsourcing.initTranslations() to be called first 
     */
    crowdsourcing.translate = function(key, language) {
       if(!crowdsourcing.translator) {
           return key;
       } else {
           return crowdsourcing.translator.translate(key, language);
       }
    }
    
    crowdsourcing.loadTranslations = function(keys) {
        if(crowdsourcing.translator) {            
            return crowdsourcing.translator.addTranslations(keys);
        } else {
            throw "Translator not initialized";
        }
    }

    return crowdsourcing;
    
} )( jQuery );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';
 

    crowdsourcing.Annotation = function(anno) {
        let temp = crowdsourcing.deepCopy(anno ? anno : {});  
        Object.assign(this, temp);
        if(!anno) {
            this.setCreated(new Date());
        }
    }
    
    crowdsourcing.Annotation.prototype.setCreated = function(date) {
        
        //convert to UTC timezone
        var utc_timestamp = Date.UTC(date.getUTCFullYear(),date.getUTCMonth(), date.getUTCDate() , 
                date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        date = new Date(utc_timestamp);
        this.created = date.toISOString().replace(/\.\d{3}Z/, "Z"); //remove milliseconds to conform to format accepted by java
    }
    
    crowdsourcing.Annotation.prototype.setModified = function(date) {
        
        //convert to UTC timezone
        var utc_timestamp = Date.UTC(date.getUTCFullYear(),date.getUTCMonth(), date.getUTCDate() , 
                date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        date = new Date(utc_timestamp);
        this.modified = date.toISOString().replace(/\.\d{3}Z/, "Z"); //remove milliseconds to conform to format accepted by java
    }
    
    crowdsourcing.Annotation.prototype.getCreated = function() {
        return this.created ? Date.parse(this.created) : undefined;  
    }

    crowdsourcing.Annotation.prototype.getModified = function() {
        return this.modified ? Date.parse(this.modified) : undefined;  
    }
    
    /**
     * Default implementation: empty if no body is present
     */
    crowdsourcing.Annotation.prototype.isEmpty = function() {
        return this.body == undefined;
    }


    crowdsourcing.Annotation.prototype.setRegion = function(rect) {
        if(!this.target) {
            throw "Annotation needs a target before a fragment can be applied";
        } else {
            let newTarget = {
                source : Crowdsourcing.getResourceId(this.target),
                type: "SpecificResource",
                selector : {
                    type : "FragmentSelector",
                    conformsTo: "http://www.w3.org/TR/media-frags/",
                    value : "xywh=" + Math.round(rect.x) + "," + Math.round(rect.y) + "," + Math.round(rect.width) + "," + Math.round(rect.height)         
                }
            }
            if(this.target != newTarget) {                
                this.target = newTarget;
                this.setModified(new Date());
            }
        }
    }
    
    crowdsourcing.Annotation.prototype.getRegion = function() {
        if(this.target && this.target.selector && this.target.selector.type == "FragmentSelector") {
            let regex = /xywh=(\d+),(\d+),(\d+),(\d+)/;
            let match = regex.exec(this.target.selector.value);
            if(match) {
                return {
                    x : parseInt(match[1]),
                    y : parseInt(match[2]),
                    width : parseInt(match[3]),
                    height : parseInt(match[4]),
                }
            }
        } else {
            return undefined;
        }
    }
    
    crowdsourcing.Annotation.prototype.setBody = function(body) {
        this.body = body;
    }

    
    crowdsourcing.Annotation.prototype.setTarget = function(target) {
        if(this.target != target) {                
            this.setModified(new Date());
        }
        if(crowdsourcing.isString(target)) {
            this.target = target;
        } else if(target.source) {
            this.target = target.source;
        } else if(target.id) {
            this.target = target.id;
        } else if(target["@id"]) {
            this.target = target["@id"];
        } else {
            this.target = target;
        }
    }
    
    crowdsourcing.Annotation.prototype.getColor = function() {
        return this.color;
    }

    crowdsourcing.Annotation.prototype.setColor = function(color) {
        this.color = color;
    }  
    
    // USE ESCAPE TO GO BACK TO THUMBNAIL OVERVIEW
    $(document).keydown(function(event){ 
        var keyCode = (event.keyCode ? event.keyCode : event.which);   
        if (keyCode == 27) {
            $('.image-controls__action.thumbs').trigger('click');
        }
    });
    


    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';

    crowdsourcing.Annotation.AuthorityResource = function(annotation, context) {
        crowdsourcing.Annotation.call(this, annotation);
        if(!this.body) {
            this.body = {
                    type: "AuthorityResource",
                    "@context": context
            }
        }
    }
    crowdsourcing.Annotation.AuthorityResource.prototype = Object.create(crowdsourcing.Annotation.prototype);
    
    crowdsourcing.Annotation.AuthorityResource.prototype.getId = function() {
            return this.body.id;
    }
        
    crowdsourcing.Annotation.AuthorityResource.prototype.setId = function(uri) {
        if(this.body.id && this.body.id != uri) {                
            this.setModified(new Date());
        }
        this.body.id = uri;
    }

    crowdsourcing.Annotation.AuthorityResource.prototype.isEmpty = function() {
        if(this.getId() && this.getId().length > 0) {
            return false;
        } else {
            return true;
        }
    }
    
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';


    crowdsourcing.Annotation.Metadata = function(annotation, originalData) {
        crowdsourcing.Annotation.call(this, annotation);
        if(!this.body) {
            this.body = {
                    type: "Dataset",
                    format: "goobi-viewer-index",
                    data: {}
            }
        }
        $.extend(this.body.data, originalData);
    }
    
    crowdsourcing.Annotation.Metadata.prototype = Object.create(crowdsourcing.Annotation.prototype);
    
    crowdsourcing.Annotation.Metadata.prototype.getValue = function(field) {
            let value = this.body.data[field];
            if(!value) {
                return "";
            } else if(Array.isArray(value)) {                
                return value.join("; ");
            } else {
                return value;
            }
    }
        
    crowdsourcing.Annotation.Metadata.prototype.setValue = function(field, value) {
        if(this.body.data[field] != value) {                
            this.setModified(new Date());
        }
        this.body.data[field] = [value];
    }
    
    crowdsourcing.Annotation.Metadata.prototype.getFields = function() {
        return Object.keys(this.body.data);
    }

    /**
     * annotation is empty if body has no fields apart from id, context, type and format
     */
    crowdsourcing.Annotation.Metadata.prototype.isEmpty = function(text) {
        return this.getFields().length == 0;
    }
    
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';


    crowdsourcing.Annotation.Plaintext = function(annotation) {
        crowdsourcing.Annotation.call(this, annotation);
        if(!this.body) {
            this.body = {
                    type: "TextualBody",
                    format: "text/plain",
                    value: "",
            }
        }
    }
    
    crowdsourcing.Annotation.Plaintext.prototype = Object.create(crowdsourcing.Annotation.prototype);
    
    crowdsourcing.Annotation.Plaintext.prototype.getText = function() {
            return this.body.value;

    }
        
    crowdsourcing.Annotation.Plaintext.prototype.setText = function(text) {
        if(this.body.value != text) {                
            this.setModified(new Date());
        }
        this.body.value = text;
    }

    crowdsourcing.Annotation.Plaintext.prototype.isEmpty = function(text) {
        if(this.getText() && this.getText().length > 0) {
            return false;
        } else {
            return true;
        }
    }
    
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';


    crowdsourcing.Annotation.Richtext = function(annotation) {
        crowdsourcing.Annotation.call(this, annotation);
        if(!this.body) {
            this.body = {
                    type: "TextualBody",
                    format: "text/html",
                    value: "",
            }
        }
 
    }
    crowdsourcing.Annotation.Richtext.prototype = Object.create(crowdsourcing.Annotation.prototype);
    
    crowdsourcing.Annotation.Richtext.prototype.getText = function() {
            return this.body.value;

    }
        
    crowdsourcing.Annotation.Richtext.prototype.setText = function(text) {
        if(this.body.value != text) {                
            this.setModified(new Date());
        }
        this.body.value = text;
    }

    crowdsourcing.Annotation.Richtext.prototype.isEmpty = function(text) {
        if(this.getText() && this.getText().length > 0) {
            return false;
        } else {
            return true;
        }
    }
    
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';


    crowdsourcing.Annotation.GeoJson = function(annotation) {
        crowdsourcing.Annotation.call(this, annotation);
 
    }
    crowdsourcing.Annotation.GeoJson.prototype = Object.create(crowdsourcing.Annotation.prototype);
    
    crowdsourcing.Annotation.GeoJson.prototype.getLocation = function() {
        return this.body;
     
    }
    
    crowdsourcing.Annotation.GeoJson.prototype.setBody = function(geoJson) {
        this.body = geoJson;
    }
        
    crowdsourcing.Annotation.GeoJson.prototype.setGeometry = function(geometry) {
        if(!this.body) {            
            this.body = {
                    geometry : geometry
            }
        } else {
            this.body.geometry = geometry;
        }
    }
    
    crowdsourcing.Annotation.GeoJson.prototype.setView = function(view) {
        if(!this.body) {            
            this.body = {
                    view : view
            }
        } else {
            this.body.view = view;
        }
    }
    
    crowdsourcing.Annotation.GeoJson.prototype.setName = function(name) {
        if(!this.body) {            
            this.body = {
                    geometry : {},
                    view : {},
                    properties : {
                        name : name
                    }
            }
        } else if(!this.body.properties){
            this.body.properties = {
                    name : name
            }
        } else {
            this.body.properties.name = name;
        }
    }

    
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';

    crowdsourcing.AreaSelector = function(item, multiple, colors) {
        
        this.drawer = null;
        this.transformer = null;
        this.rects = [];
        this.finishedDrawing = new rxjs.Subject();
        this.finishedTransforming = new rxjs.Subject();
        this.lastRectangleId = -1;
        
        this.crowdsourcingItem = item;
        this.multiRect = multiple;
        this.colors = colors ? new ImageView.ColorIterator(colors) : new ImageView.ColorIterator(ImageView.ColorIterator.randomColor);
    }
    
    crowdsourcing.AreaSelector.prototype.init = function() {
        this.crowdsourcingItem.onImageOpen( (imageView) => {
        	//console.log("init drawer", imageView, this);
            if(!this.drawer) {
                this.createDrawer(imageView);
                this.createTransformer(imageView);
                
                this.crowdsourcingItem.onImageRotated( (degree) => {
                    this.rects.forEach(function(overlay) {
                        overlay.rect = overlay.rect.rotate(degree);
                    })
                });
            }
        });
        
    }

    crowdsourcing.AreaSelector.prototype.createDrawer = function (imageView) {
        this.drawer = new ImageView.Draw(imageView.viewer, this.getStyle("red"), function(e) {
            return e.shiftKey && this.allowDrawing();
        }.bind(this));
        this.drawer.finishedDrawing().subscribe(function(rect) {
            if(this.rect && !this.multiRect) {
                this.removeOverlay(this.rect)
            }
            rect.id = ++this.lastRectangleId;
            rect.style = this.drawer.style;
            this.drawer.style = this.getStyle();
    		rect.draw();
            if(this.transformer) {	   
    			this.transformer.addOverlay(rect);
            }
    		this.rect = rect;
    		this.rects.push(this.rect);
    	}.bind(this)) 
    	this.drawer.finishedDrawing().pipe(rxjs.operators.map((rect) => _getResultObject(rect, imageView))).subscribe(this.finishedDrawing);
    }
    
    crowdsourcing.AreaSelector.prototype.allowDrawing = function() {
        return true;
    }
    
    crowdsourcing.AreaSelector.prototype.reset = function() {
        this.colors.index = 0;
        this.rects.forEach(function(rect) {
            this.transformer.removeOverlay(rect);
            rect.remove();
        }.bind(this));
        this.rects = [];
    }

    crowdsourcing.AreaSelector.prototype.createTransformer = function(imageView) {
        this.transformer = new ImageView.Transform(imageView.viewer, this.drawStyle, (e) => !e.shiftKey); 
        this.transformer.finishedTransforming().pipe(rxjs.operators.map((rect) => _getResultObject(rect, imageView))).subscribe(this.finishedTransforming);

    }

    crowdsourcing.AreaSelector.prototype.getStyle = function(color) {
        let style = {
        		borderWidth: 2,
        		borderColor: color ? color : this.colors.next()
        }
        return style;
    }
    
    crowdsourcing.AreaSelector.prototype.getRect = function(id) {
        return this.rects.find( rect => rect.id == id);
    }
    
    crowdsourcing.AreaSelector.prototype.addOverlay = function(annotation, viewer) {
        if(annotation.getRegion()) {            
            let rect = ImageView.CoordinateConversion.scaleToOpenSeadragon(annotation.getRegion(), viewer, viewer.world.getItemAt(0).source)
            rect = rect.rotate(-viewer.viewport.getRotation());
            let overlay = new ImageView.Overlay(rect, viewer, this.getStyle());
            annotation.setColor(overlay.style.borderColor);
            overlay.id = ++this.lastRectangleId;
            annotation.overlayId = overlay.id;
            this.lastRectangleId = overlay.id;
            overlay.draw();
            if(this.transformer) {     
                this.transformer.addOverlay(overlay);
            }
            //console.log("%c add overlay " + annotation.getText(), "background: " + annotation.getColor());
            this.rects.push(overlay);
        }
    }

    crowdsourcing.AreaSelector.prototype.removeOverlay = function(object) {
        let rect = this.rects.find(rect => rect.id == object.overlayId);
        if(rect) {
            rect.remove();
            let index = this.rects.indexOf(rect);
            if(index > -1) {                
                this.rects.splice(index, 1);
            }
            if(this.rect == rect) {
                this.rect = undefined;
            }
            if(this.transformer) {              
                this.transformer.removeOverlay(rect)
            }
        }
    }
    
    crowdsourcing.AreaSelector.prototype.setDrawingStyle = function(style) {
        if(this.drawer) {
            this.drawer.style = style;
        }
    }

    
    crowdsourcing.AreaSelector.prototype.disableDrawer = function() {
        if(this.drawer) {
            this.drawer.active = false;
        }
    }
    
    crowdsourcing.AreaSelector.prototype.enableDrawer = function() {
        if(this.drawer) {
            this.drawer.active = true;
        }
    }
    
    crowdsourcing.AreaSelector.prototype.disableTransformer = function() {
        if(this.transformer) {
            this.transformer.active = false;
        }
    }
    
    crowdsourcing.AreaSelector.prototype.enableTransformer = function() {
        if(this.transformer) {
            this.transformer.active = true;
        }
    }
    
    function _getResultObject(rect, image) {
        let region = rect.rect.rotate(-image.getRotation());
        let scaledRegion = ImageView.CoordinateConversion.scaleToImage(region, image.viewer, image.viewer.world.getItemAt(0).source);
        scaledRegion.x = Math.max(0, scaledRegion.x);
        scaledRegion.y = Math.max(0, scaledRegion.y);
        let result = {
                id: rect.id,
                color: rect.style.borderColor,
                region: scaledRegion
        }
        return result;
    }

return crowdsourcing;

} )( Crowdsourcing );



var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';

    let _debug = false;
    const LOCAL_STORAGE_ITEM = "goobi_viewer_crowdsourcing_annotations";
    
    /**
     * Constructor for a new item. 
     * @param item  A json object built from CampaignItem.java containing the campaign item data
     * @param initialCanvasIndex the index of the canvas to open initially. If not used, index = 0 is used
     */
    crowdsourcing.Item = function(item, initialCanvasIndex) {
        if ( _debug ) {
            console.log( '##############################' );
            console.log( 'Crowdsourcing.Item' );
            console.log( 'Crowdsourcing.Item.canvases ', canvases );
            console.log( 'Crowdsourcing.Item.questions ', questions );
            console.log( '##############################' );
        }
        
        this.id = item.campaign.url;
        this.campaignId = item.campaign.id;
        this.recordIdentifier = item.recordIdentifier;
        this.reviewMode = false;
        this.showLog = item.campaign.showLog;
        if(this.showLog) {
            this.log = item.log;
        }
        this.translations = item.campaign.translations;
        this.questions = item.campaign.questions.map(question => new Crowdsourcing.Question(question, this));
        this.currentCanvasIndex = initialCanvasIndex ? initialCanvasIndex : 0;
        this.imageSource = item.source;
        this.metadata = item.metadata;
        this.pageStatisticMode = item.pageStatisticMode;
        //maps page numbers (1-based!) to one of the following status: blank, annotate, locked, review, finished
        this.pageStatusMap = viewerJS.parseMap(item.pageStatusMap);
        this.reviewActive = item.campaign.reviewMode != "NO_REVIEW";
        this.currentUser = {};
        this.imageOpenEvents = new rxjs.Subject();
        this.toggleImageViewEvents = new rxjs.Subject();
        this.imageRotationEvents = new rxjs.Subject();
        this.annotationRelaodEvents = new rxjs.Subject();
        this.itemInitializedSubject = new rxjs.Subject();
        this.statusMapUpdates = new rxjs.Subject();
        //Used to manually force imageControls to show thumbnail view
        this.setShowThumbs = new rxjs.Subject();
		//signals that there are annotations which have not been saved to the server
		//Is set on a per record or a per page basis depending on this.pageStatisticMode
		this.dirty = false;

        let firstAreaQuestion = this.questions.find(q => q.isRegionTarget());
        if(firstAreaQuestion) {
            firstAreaQuestion.active = true;
        }
        
        if(this.pageStatisticMode) {
	        this.initWebSocket();
        }        
        this.initKeyboardEvents();
        
        // console.log("initialized crowdsourcing item ", this);
        
    };
    
    crowdsourcing.Item.prototype.initKeyboardEvents = function() {
    	document.addEventListener('keyup', (event) => {
    		//don't handle events if an input element is focused
    		if($(event.target).closest("input").length > 0) {
    			return;
    		}
    		let keyName = event.key;
    		let targetIndex = undefined;
    		switch(keyName) {
    			case "ArrowLeft":
    				targetIndex = this.getPreviousAccessibleIndex(this.currentCanvasIndex);
    				break;
    			case "ArrowRight":
    				targetIndex = this.getNextAccessibleIndex(this.currentCanvasIndex);
    				break;
    		}
    		if(targetIndex != undefined) {
    			this.loadImage(targetIndex, true);
    		}
    				
    	});
    }
    
    
    crowdsourcing.Item.prototype.initWebSocket = function() {
 		this.socket = new viewerJS.WebSocket(window.location.host, window.currentPath, viewerJS.WebSocket.PATH_CAMPAIGN_SOCKET);
    	this.socket.onMessage.subscribe((event) => {
    		//console.log("received message ", event.data);
    		let data = JSON.parse(event.data);
    		if(data.status) {
    			this.handleMessage(data);
    		} else {
		    	this.handleLocks(data);   		
    		}
    		
    	});
    	this.onImageOpen((image) => {
    		//console.log("Call websocket on image open " + this.currentCanvasIndex);
    		let message = {
    			campaign : this.campaignId,
    			record : this.recordIdentifier,
    			page : this.currentCanvasIndex + 1,
    		}
    		this.socket.sendMessage(JSON.stringify(message));
    	});
    }
    
    crowdsourcing.Item.prototype.handleMessage = function(message) {
    	let status = message.status;
    	let messageKey = message.message;
    	if(status && messageKey) {
    		viewerJS.translator.addTranslations(messageKey)
    		.then( () => {
    			let message = viewerJS.translator.translate(messageKey);
    			viewerJS.notifications.notify(message, type);
    		});
    	}
    }
    
    
    crowdsourcing.Item.prototype.handleLocks = function(locks) {
    	this.buildPageStatusMap(locks);
    	if(this.isPageAccessible(this.currentCanvasIndex)) {
    		this.statusMapUpdates.next(this.pageStatusMap);
    	} else {
    		let targetIndex = this.getNextAccessibleIndex(this.currentCanvasIndex);
    		console.log("handle locks", targetIndex);
    		if(targetIndex == undefined) {
    			this.setShowThumbs.next(true);
    		} else {
    			//console.log("load next image: " + targetIndex);
	    		this.loadImage(targetIndex);
	    	}
    	}
    }
    
    crowdsourcing.Item.prototype.buildPageStatusMap = function(locks) {
    	this.pageStatusMap = new Map();
    	this.canvases.forEach((canvas, index) => {
	    	if(this.pageStatisticMode) {
	    		let status = locks[index+1];
	    		this.pageStatusMap.set(index, status ? status.toLowerCase() : "blank");
    		} else {
    			this.pageStatusMap.set(index, this.reviewMode ?  "review" : "annotate" );
    		}
    	});
    };
    
    crowdsourcing.Item.prototype.isPageAccessible = function(index) {
    	if(!this.pageStatisticMode) {
    		return index > -1 && index < this.canvases.length;
    	} else {    	
	    	let status = this.pageStatusMap.get(index);
	    	if(this.reviewMode) {
	    		return "review" == status;
	    	} else {
	    		return "annotate" == status || "blank" == status;
	    	}
    	}
    };
    
   crowdsourcing.Item.prototype.getNextAccessibleIndex = function(currentIndex) {
   		if(this.canvases.length == 1) {
   			return undefined;
   		} else if(currentIndex == this.canvases.length-1) {
   			return this.getNextAccessibleIndex(-1);
   		} else {
	   		for (let i = currentIndex+1; i < this.canvases.length; i++) { 
	   			if(this.isPageAccessible(i)) {
	   				return i;
	   			} 
	   		}
	   		return undefined;
   		}
   }
    
   crowdsourcing.Item.prototype.getPreviousAccessibleIndex = function(currentIndex) {
   		if(this.canvases.length == 1) {
   			return undefined;
   		} else if(currentIndex == 0) {
   			return this.getPreviousAccessibleIndex(this.canvases.length);
   		} else {
	   		for (let i = currentIndex-1; i > -1; i--) { 
	   			if(this.isPageAccessible(i)) {
	   				return i;
	   			} 
	   		}
	   		return undefined;
   		}
   }

    crowdsourcing.Item.prototype.setCurrentUser = function(id, name, avatar) {
        this.currentUser.userId = id;
        this.currentUser.name = name;
        this.currentUser.avatar = avatar;
    }
    
    /**
     * add a new message to the log and also to the messages to send back with the item status
     */
    crowdsourcing.Item.prototype.addLogMessage = function(message) {
        this.log.push(message);
        if(this.logEndpoint) {            
            return fetch(this.logEndpoint, {
                method: "POST",
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(message),
                cache: "no-cache",
                mode: 'cors',
            })
        }
    }


 
    /**
     * Takes an rxjs.Observable which should trigger every time a new image is
     */
    crowdsourcing.Item.prototype.notifyImageOpened = function(observable) {
        observable.subscribe(this.imageOpenEvents);
    }
    
    crowdsourcing.Item.prototype.notifyImageRotated = function(byDegrees) {
        this.imageRotationEvents.next(byDegrees);
    }
    
    crowdsourcing.Item.prototype.notifyImageViewChanged = function(viewThumbs) {
        this.toggleImageViewEvents.next(viewThumbs);
    }
    
    crowdsourcing.Item.prototype.onImageRotated = function(eventHandler, errorHandler, completedHandler) {
        this.imageRotationEvents.subscribe(eventHandler, errorHandler, completedHandler);
    }
    
    crowdsourcing.Item.prototype.onImageOpen = function(eventHandler, errorHandler, completedHandler) {
        this.imageOpenEvents.subscribe(eventHandler, errorHandler, completedHandler);
    }
    
    crowdsourcing.Item.prototype.onImageViewChanged = function(eventHandler, errorHandler, completedHandler) {
        this.toggleImageViewEvents.subscribe(eventHandler, errorHandler, completedHandler);
    }
    
    crowdsourcing.Item.prototype.notifyAnnotationsReload = function() {
        this.annotationRelaodEvents.next();
    }
    
    crowdsourcing.Item.prototype.onAnnotationsReload = function(eventHandler, errorHandler, completedHandler) {
        this.annotationRelaodEvents.subscribe(eventHandler, errorHandler, completedHandler);
    }
    
    crowdsourcing.Item.prototype.notifyItemInitialized = function() {
        this.itemInitializedSubject.next();
        this.itemInitializedSubject.notified = true;
    }
    
    crowdsourcing.Item.prototype.onItemInitialized = function(eventHandler, errorHandler, completedHandler) {
        this.itemInitializedSubject.subscribe(eventHandler, errorHandler, completedHandler);
        //If a notification happened before we subscribe, notify us now
        if(this.itemInitializedSubject.notified) {
            this.itemInitializedSubject.next();
            this.itemInitializedSubject.notified = false;
        }
    }
    
    crowdsourcing.Item.prototype.initViewer = function(imageSource) {
        this.canvases = _getCanvasList(imageSource);
        this.currentCanvasIndex = Math.max(0, Math.min(this.currentCanvasIndex, this.canvases.length-1));
        //build a simple page status map now that the canvas list is known
        if(!this.pageStatisticMode) {
        	this.buildPageStatusMap();
        }
    }
    
    crowdsourcing.Item.prototype.loadImage = function(index, requireConfirmation) {
        if(index == undefined) {
        	return;
        }
        //console.log("load image", this.dirty, requireConfirmation, index, this.currentCanvasIndex);
        if(this.pageStatisticMode && this.dirty && requireConfirmation && index != this.currentCanvasIndex) {
        	viewerJS.notifications.confirm(Crowdsourcing.translate("crowdsourcing__confirm_skip_page"))
        	.then( () => {
        		this.dirty = false;
	            this.currentCanvasIndex = index;
	        	if(this.setImageSource) {            
		            this.setImageSource(this.getCurrentCanvas());
	        	}
        	})
        	.catch(() => {});
        } else {
        	if(this.pageStatisticMode) {
        		this.dirty = false;
        	}
            this.currentCanvasIndex = index;
	        if(this.setImageSource) {            
		    	this.setImageSource(this.getCurrentCanvas());
	        }
        }
    }
    
    crowdsourcing.Item.prototype.getCurrentCanvas = function() {
        return this.canvases[this.currentCanvasIndex];
    }
    
    crowdsourcing.Item.prototype.getImageService = (canvas) =>  {
        return canvas.images[0].resource.service["@id"] + "/info.json";
    }
    
    crowdsourcing.Item.prototype.getImageId = (canvas) =>  {
        return canvas.images[0].resource.service["@id"];
    }

    crowdsourcing.Item.prototype.getCreator = function() {
        return {
            id: String(Crowdsourcing.user.id),
            type: "Person",
            name: Crowdsourcing.user.name,
        }
    }
    
    crowdsourcing.Item.prototype.createAnnotationMap = function(annotations) {
        let save = {
                campaign: this.id,
                manifest: this.imageSource,
                questions: []
            }
            
            this.questions.forEach(function(question) {
               let q = {
                    id: question.id,
                    pages: []
               } 
               save.questions.push(q);
            });
            
            this.addAnnotations(annotations, save);
            
            return save;
    }
    
    /**
    * From the given save, remove all annotations. If pageId and/or questionId are given
    * only delete from that page and/or question
    */
    crowdsourcing.Item.prototype.deleteAnnotations = function(save, pageId, questionId) {
	    if(!save) {
	    	return
	    }
    
        let questions = save.questions;
        if(questionId) {
            questions = questions.filter(q => q.id == questionId);
        }
        questions.forEach(function(question) {
            let pages = question.pages;
            if(pageId) {
                pages = pages.filter(p => p.id ==pageId);
            }
            pages.forEach(function(page) {
               page.annotations = []; 
            });
        })
        return save;
    }
    
    /**
    * Return list of annotations, optionally filtered by pageId and questionId
    */
    crowdsourcing.Item.prototype.loadAnnotations = function(pageId, questionId) {
        let annotations = [];
        let save = this.getFromLocalStorage();
		if(save) {
	        let questions = save.questions;
	        if(questionId) {
	            questions = questions.filter(q => q.id == questionId);
	        }
	        questions.forEach(function(question) {
	            let pages = question.pages;
	            if(pageId) {
	                pages = pages.filter(p => p.id ==pageId);
	            }
	            pages.forEach(function(page) {
	               annotations = annotations.concat(page.annotations) 
	            });
	        })
        }
        return annotations;
    }
    
    /**
    * Return a list of pages consisting of a pageId and an array of all annotations on that page; optionally filter by questionId 
    */
    crowdsourcing.Item.prototype.loadAnnotationPages = function(questionId, pageId) {
        let save = this.getFromLocalStorage();
        let pages = [];
        let questions = save.questions;
        if(questionId) {
            questions = questions.filter(q => q.id == questionId);
        }
        questions.forEach(function(question) {
            let questionPages = question.pages
            if(pageId) {
            	questionPages = questionPages.filter(page => pageId == page.id)
            }
            questionPages.forEach(function(page) {
               let pageToLoad = pages.find(p => p.id == page.id);
               if(!pageToLoad) {
                   pageToLoad = {
                       id: page.id,
                       annotations: []
                   }
                   pages.push(pageToLoad);
               }
               pageToLoad.annotations = pageToLoad.annotations.concat(page.annotations);
            });
        })
        return pages;
    }
    
    
    /**
    * Remove all annotations for the given pageId and questionId (all if pageId/questionId is not given) from local storage
    * and add the given annotations to local storage
    */
    crowdsourcing.Item.prototype.saveAnnotations = function(pageId, questionId, annotations) {
        let save = this.getFromLocalStorage();
        this.deleteAnnotations(save, pageId, questionId);
        this.addAnnotations(annotations, save);
        this.saveToLocalStorage(save);
        this.dirty = true;
    }
        
    crowdsourcing.Item.prototype.addAnnotations = function(annotations, save) {
        annotations.forEach(function(annotation) {
            let questionId = annotation.generator.id;
            let question = save.questions.find( q => q.id == questionId);
            let pageId = Crowdsourcing.getResourceId(annotation.target);
            if(question && pageId) {
                let page = question.pages.find( p => p.id == pageId);
                if(!page) {
                    page = {
                        id: pageId,
                        annotations: []
                    }
                    question.pages.push(page);
                }
                page.annotations.push(annotation);
            }
        });
        return save;
    }

    crowdsourcing.Item.prototype.saveToLocalStorage = function(save) {
        sessionStorage.setItem(LOCAL_STORAGE_ITEM, JSON.stringify(save));
    }
    
    crowdsourcing.Item.prototype.getFromLocalStorage = function() {
        let jsonString = sessionStorage.getItem(LOCAL_STORAGE_ITEM);
        let json = JSON.parse(jsonString);
        return json;
    }
    
    crowdsourcing.Item.prototype.setReviewMode = function(review) {
        this.reviewMode = review ? true : false;
    }

    crowdsourcing.Item.prototype.isReviewMode = function() {
        if (this.pageStatisticMode) {
            //console.log('statistic mode index ' + (this.currentCanvasIndex) + ': '  + (this.pageStatusMap.get(this.currentCanvasIndex)))
            return this.pageStatusMap.get(this.currentCanvasIndex) == 'review';
        } else {
            return this.reviewMode;
        }
    }
    
    crowdsourcing.Item.prototype.isReviewActive = function() {
        return this.reviewActive;
    }

    crowdsourcing.Item.prototype.getCurrentPageId = function() {
		let canvas = this.canvases[this.currentCanvasIndex];
		if(canvas) {
			return viewerJS.iiif.getId(canvas);
		} else {
			return undefined;
		}
    }
    
    crowdsourcing.Item.prototype.loadNextItem = function(requireConfirmation) {
	     let promise = Promise.resolve();
	     if(this.dirty && requireConfirmation) {
	     	promise = viewerJS.notifications.confirm(Crowdsourcing.translate("crowdsourcing__confirm_skip_page"))
	     }
	     promise.then( () => {
		     window.location.href = this.nextItemUrl;
	     })
	     .catch((e) => {});
	}
    
    /**
        get a list containing all canvas json items or canvas urls contained in the source object
        The source must be either a manifest, a range or a single canvas
    */

    function _getCanvasList(source) {
        let sourceType = source.type;
        if(!sourceType) {
            sourceType = source["@type"];
        }
        
        switch(sourceType) {
            case "sc:Manifest":
                return source.sequences[0].canvases;
            case "sc:Canvas":
                return [source];
            case "sc:Range":
                return source.canvases;
            default:
                console.log("Unknown source type, cannot retrieve canvases", source);
        }
    }
    
    return crowdsourcing;
    
} )( Crowdsourcing );

var Crowdsourcing = ( function(crowdsourcing) {
    'use strict';

    const COLORS = [" #e74c3c ", " #2980b9 ",  "#2ecc71 ", " #f1c40f ", " #9b59b6 ", " #d35400 ", " #1abc9c ", " #f06292 ", " #7e57c2 ", " #aed581 ",
          " #CCFF00 ", " #9575cd ", " #ff8a65 ", " #CC6699 ", " #CC6699 ", " #8e24aa ", " #d35400 ", " #e74c3c "]
    
    crowdsourcing.Question = function(question, item) {
        let temp = crowdsourcing.deepCopy(question);
        Object.assign(this, temp);
        
        this.item = item;
        this.questionType = Crowdsourcing.Question.getType(this);
        this.targetFrequency = this.targetFrequency;
        this.targetSelector = Crowdsourcing.Question.getSelector(this);

        this.annotations = [];
        this.currentAnnotationIndex = -1;
        this.colors = Crowdsourcing.frameColors ? Crowdsourcing.frameColors : COLORS;
    }
    
    crowdsourcing.Question.prototype.createAnnotation = function(anno) {
        throw "Must implement createAnnotation";
    }
    
    
    crowdsourcing.Question.prototype.loadAnnotationsFromLocalStorage = function() {
        this.annotations = this.getAnnotationsFromLocalStorage();
    }
    
    crowdsourcing.Question.prototype.setDrawingPermission = function() {
        if(this.areaSelector) {       
            if(this.item.isReviewMode()) {
                this.areaSelector.disableDrawer();
                this.areaSelector.disableTransformer();
            } else if(this.targetFrequency > 0 && this.targetFrequency <= this.annotations.length) {
                this.areaSelector.disableDrawer();
                this.areaSelector.enableTransformer();
            } else {
                this.areaSelector.enableDrawer();
                this.areaSelector.enableTransformer();
            }
        }
    }
    
    crowdsourcing.Question.prototype.initializeView = function(createNewAnnotation, onAddAnnotation, onUpdateAnnotation, focus) {
        if(createNewAnnotation) {
            this.createAnnotation = function(anno) {
                let annotation = createNewAnnotation(anno);
                annotation.generator = this.getGenerator();
                annotation.creator = this.item.getCreator();
                return annotation;
            }
        } else {
            throw "Must pass method to create new annotation";
        }
        
        switch(this.targetSelector) {
            //if target is whole source, load annotations just once
            case Crowdsourcing.Question.Selector.WHOLE_SOURCE:
                this.loadAnnotationsFromLocalStorage();
                this.item.onImageOpen(function() {
                    this.initAnnotations();
                }.bind(this));
                break;
            //if target is a rectangle region on page, initialize drawing on canvas
            case Crowdsourcing.Question.Selector.RECTANGLE:
                    this.initAreaSelector();
            //if target is page or region on page, load matching annotations on each image change
            case Crowdsourcing.Question.Selector.WHOLE_PAGE:
            default:
                this.item.onImageOpen(function() {
                    this.loadAnnotationsFromLocalStorage();
                    this.initAnnotations();
                }.bind(this));    
        }
        
        if(this.areaSelector) {            
            this.areaSelector.finishedDrawing.subscribe( (result) => {
                let anno = this.addAnnotation(result.id, result.region, result.color);
                this.focusCurrentAnnotation();
                onAddAnnotation(anno);
            });
            this.areaSelector.finishedTransforming.subscribe( (result) => {
                let anno = this.getAnnotationByOverlayId(result.id);
                this.setRegion(result.region, anno);
                onUpdateAnnotation(anno);
            });
        }
        
        if(focus)  {
            this.focusCurrentAnnotation = function() {
                if(this.currentAnnotationIndex > -1 && this.annotations && this.annotations.length > this.currentAnnotationIndex) {
                    window.setTimeout(() => focus(this.currentAnnotationIndex),1);
                }
            }
        }
    }
    
    /**
     * May be overwritten in initializeView to focus an element based on the annotationIndex
     */
    crowdsourcing.Question.prototype.focusCurrentAnnotation = function() {
        //noop
    }

    /**
     * Initializes the annotations for the current page
     */
    crowdsourcing.Question.prototype.initAnnotations = function() {
        switch(this.targetSelector) {
            case Crowdsourcing.Question.Selector.RECTANGLE:
                if(this.areaSelector) {                    
                    this.areaSelector.reset();
                    this.setDrawingPermission();
                    this.annotations
                    .forEach(anno => this.areaSelector.addOverlay(anno, this.item.image.viewer));
                    this.areaSelector.setDrawingStyle(this.areaSelector.getStyle());
                }
                break;
        }
    }
    
    crowdsourcing.Question.prototype.initAreaSelector = function() {
        this.areaSelector = new Crowdsourcing.AreaSelector(this.item, true, this.colors);
        this.areaSelector.allowDrawing = function() {
            return this.active === true
        }.bind(this);
        this.areaSelector.init();

    }
    
    crowdsourcing.Question.prototype.getAnnotation = function(id) {
        return this.annotations.find(anno => anno.id == id);
    }
    
    crowdsourcing.Question.prototype.getAnnotationByOverlayId = function(id) {
        return this.annotations.find(anno => anno.overlayId == id);
    }
    
    crowdsourcing.Question.prototype.getIndex = function(anno) {
        return this.annotations.indexOf(anno);
    }
    
    crowdsourcing.Question.prototype.getByIndex = function(index) {
        if(index > -1 && index < this.annotations.length) {            
            return this.annotations[index];
        } else {
            return undefined;
        }
    }

    crowdsourcing.Question.prototype.getImage = function(annotation) {
        return this.getImageUrl(annotation.getRegion(), this.item.getImageId(this.item.getCurrentCanvas()));
    }

    crowdsourcing.Question.prototype.setRegion = function(region, anno) {
        if(anno) {
            anno.setRegion(region);
            this.currentAnnotationIndex = this.getIndex(anno);
            this.saveToLocalStorage();
        }
    }

    crowdsourcing.Question.prototype.getImageUrl = function(rect, imageId) {
        let rotation = this.item.image ? this.item.image.getRotation() : 0;
        let url = imageId + "/" + rect.x + "," + rect.y + "," + rect.width + "," + rect.height + "/full/" + rotation + "/default.jpg";
        return url;
    }
    
    crowdsourcing.Question.prototype.getTarget = function() {
        if(this.targetSelector == Crowdsourcing.Question.Selector.WHOLE_SOURCE) {
            return this.item.imageSource;
        } else {            
            return this.item.getCurrentCanvas();
        }
    }
    
    crowdsourcing.Question.prototype.getTargetId = function() {
        let target = (this.targetSelector == Crowdsourcing.Question.Selector.WHOLE_SOURCE) ? this.item.imageSource : this.item.getCurrentCanvas();
        return crowdsourcing.getResourceId(target);
    }

    crowdsourcing.Question.prototype.deleteAnnotation = function(anno) {
        let index = this.getIndex(anno);
        if(index > -1) {            
            this.annotations.splice(index,1);
            if(this.currentAnnotationIndex >= index) {
                this.currentAnnotationIndex--;
            }
            if(this.areaSelector) {             
                this.areaSelector.removeOverlay(anno);
            }
            this.saveToLocalStorage();
        }
        this.setDrawingPermission();
    }
    
    crowdsourcing.Question.prototype.addAnnotation = function(id, region, color) {
        let annotation = this.createAnnotation();
        annotation.setTarget(this.getTarget());
        if(id !== undefined) {            
            annotation.overlayId = id;
        }
        if(region) {            
            annotation.setRegion(region);
        }
        if(color) {            
            annotation.setColor(color);
        }
        this.annotations.push(annotation);
        this.currentAnnotationIndex = this.annotations.length - 1;

        this.saveToLocalStorage();

        this.setDrawingPermission();
        return annotation;
    }

    crowdsourcing.Question.prototype.getGenerator = function() {
        return  {
            id: String(this.id),
            type: "Software"
        }
    }
    
    crowdsourcing.Question.prototype.setColors = function(colors) {
        this.colors = colors;
    }

    crowdsourcing.Question.prototype.isRegionTarget = function() {
        return this.targetSelector == Crowdsourcing.Question.Selector.RECTANGLE;
    }
    
    crowdsourcing.Question.prototype.deleteFromLocalStorage = function() {
        this.item.deleteAnnotations(save, this.getTargetId(), this.id);
    }
    
    crowdsourcing.Question.prototype.saveToLocalStorage = function() {
        let annotationsToSave = this.annotations;
        if(this.targetSelector == Crowdsourcing.Question.Selector.WHOLE_PAGE ||
            this.targetSelector == Crowdsourcing.Question.Selector.WHOLE_SOURCE) {
            annotationsToSave = annotationsToSave.filter(anno => !anno.isEmpty());
        }
        this.item.saveAnnotations(this.getTargetId(), this.id, annotationsToSave);
    }
    
    crowdsourcing.Question.prototype.getAnnotationsFromLocalStorage = function() {
        let targetId = this.targetSelector == Crowdsourcing.Question.Selector.WHOLE_SOURCE ? undefined : this.getTargetId();
        let annotations = this.item.loadAnnotations(targetId, this.id);
        annotations = annotations.map(anno => this.createAnnotation(anno));

        return annotations;
    }
    
    crowdsourcing.Question.prototype.mayAddAnnotation = function() {
        return this.targetFrequency == 0 || this.targetFrequency > this.annotations.length;
    }
    
    crowdsourcing.Question.prototype.isReviewMode = function() {
        return this.item.isReviewMode();
    }
    
    

    crowdsourcing.Question.Type = {};
    crowdsourcing.Question.Selector = {};

    
    crowdsourcing.Question.Type.PLAINTEXT = "PLAINTEXT";
    crowdsourcing.Question.Type.RICHTEXT = "RICHTEXT";
    crowdsourcing.Question.Type.DATE_PICKER = "DATE_PICKER";
    crowdsourcing.Question.Type.GEOLOCATION_POINT = "GEOLOCATION_POINT";
    crowdsourcing.Question.Type.GEOLOCATION_AREA = "GEOLOCATION_AREA";
    crowdsourcing.Question.Type.TRANSCRIPTION = "TRANSCRIPTION";
    crowdsourcing.Question.Type.KEY_VALUE_LIST = "KEY_VALUE_LIST";
    crowdsourcing.Question.Type.NORMDATA = "NORMDATA";
    crowdsourcing.Question.Type.METADATA = "METADATA";
    crowdsourcing.Question.Type.get = function(text) {
        return crowdsourcing.Question.Type[text];
    }
    crowdsourcing.Question.getType = function(question) {
        return crowdsourcing.Question.Type.get(question.questionType);
    }
    
    crowdsourcing.Question.Selector.MULTIPLE_PER_CANVAS = "WHOLE_SOURCE";
    crowdsourcing.Question.Selector.WHOLE_PAGE = "WHOLE_PAGE";
    crowdsourcing.Question.Selector.RECTANGLE = "RECTANGLE";
    crowdsourcing.Question.Selector.get = function(text) {
        return crowdsourcing.Question.Selector[text];
    }
    crowdsourcing.Question.getSelector = function(question) {
        return crowdsourcing.Question.Selector.get(question.targetSelector);
    }    
    
    return crowdsourcing;
    
} )( Crowdsourcing );
